---
title: "Using and Creating Metabolomics Data Annotation Resources"
author: "Philippine Louail, Johannes Rainer"
format: html
minimal: true
bibliography: creating-using-annotation-resources.bib
date: 'Compiled: `r format(Sys.Date(), "%B %d, %Y")`'
vignette: >
  %\VignetteIndexEntry{Using and Creating Metabolomics Data Annotation Resources}
  %\VignetteEngine{quarto::html}
  %\VignetteEncoding{UTF-8}
  %\VignetteDepends{Spectra,stringr,CompoundDb,MetaboAnnotation,AnnotationHub,MsBackendMgf,MsBackendMassbank,zen4R,BiocStyle,SpectriPy}
---

```{r setup, include=FALSE}
library(knitr)
library(quarto)
library(BiocStyle)
knitr::opts_knit$set(root.dir = './')
```

# Introduction

In this document we describe how annotation resources for untargeted
metabolomics data can be accessed, used, and also created/extended. The
respective reference data (in particular spectral libraries) are available from
a variety of sources which include among others:

- [GNPS](https://gnps.ucsd.edu/ProteoSAFe/static/gnps-splash.jsp): the Global
  Natural Products Social Molecular Networking (GNPS) is an open-access
  knowledge base for community-wide organization and sharing of raw, processed
  or identified MS/MS spectrometry data [@wang_sharing_2016].
- [MassBank](https://massbank.eu/MassBank/): MassBank is an open source mass
  spectral library for the identification of small chemical molecules of
  metabolomics, exposomics and environmental relevance [@neumann_massbank_2025].
- [HMDB](https://www.hmdb.ca/): the Human Metabolome Database (HMDB) is a freely
  available electronic database containing detailed information about small
  molecule metabolites found in the human body [@wishart_hmdb_2021].
- [MoNA](https://mona.fiehnlab.ucdavis.edu/): MassBank of North America (MoNA)
  is a metadata-centric, auto-curating repository for efficient storage and
  querying of mass spectral records.

While it is possible to download the data for all of these resources, the file
format, the extent of provided annotations as well as the encoding and naming of
the provided information, differs, making their import sometimes cumbersome. For
most of the resources and formats packages exist, but standardization and
harmonization of the annotation resource remains challenging.

In this document we show how spectral libraries from some of the public
resources can be imported into a data structures suitable for annotation
workflows of LC-MS/MS data and how the provided metadata information can be
extracted. Future work will focus on harmonization and standardization of the
data, further simplifying and streamlining its import, and on the support for
upcoming standard file types such as the new
[*mzSpecLib*](https://github.com/HUPO-PSI/mzSpecLib) format.

# Accessing and using spectral libraries

Spectral libraries are available from a variety of sources, such as GNPS,
MassBank, HMDB or MoNA. These libraries and resources generally use their own
data format or their own specific *flavour* of a standard file format.  Most of
these formats can be parsed directly by packages from the *RforMassSpectrometry*
initiative, such as the `r Biocpkg("MsBackendMgf")`, `r
Biocpkg("MsBackendMsp")`, `r Biocpkg("MsBackendMassbank")` and `r
Biocpkg("CompoundDb")` package. As a result, the data from these spectral
libraries will be available as a `Spectra` object which allows a direct
integration into R-based annotation workflows.

In this chapter we show how spectral libraries from GNPS and MassBank can be
loaded in a format for R-based annotation of LC-MS/MS data.

## Using spectral libraries from GNPS

[GNPS2](https://gnps2.org) provides collections of MS/MS spectral
libraries, integrating also information from other sources such as
[MassBank](https://massbank.eu/MassBank/) or
[MoNA](https://mona.fiehnlab.ucdavis.edu/). These can be downloaded in different
file formats (MGF, MSP or JSON) from the official [GNPS2
site](https://external.gnps2.org/gnpslibrary), but some of them are also
deposited on Zenodo or Figshare attributing individual data files with their own
DOI ensuring thus reproducibility.

In this section we download a subset of the GNPS library and show how such data
can be imported and used for MS2-based annotation workflows in R. For our
example we use the GNPS2 drug library available on
[Zenodo](https://doi.org/10.5281/zenodo.13892288). It represents a centralized
collection of reference spectra for drugs and their metabolites/analogs along
with structured pharmacologic metadata [@zhao_resource_2025]. Below we download
all resources related to the v4 of this library (DOI: 10.5281/zenodo.17232042)
from Zenodo to a temporary folder.

```{r, message = FALSE}
library(Spectra)
library(zen4R)

doi <- "10.5281/zenodo.17232042" # v4

#' download all data related to the DOI
pth <- tempdir()
download_zenodo(doi, path = pth, quiet = TRUE, timeout = 600)
dir(pth)
```

The spectral libraries are available in MGF file format. Below we read the first
25 lines of the MGF file to inspect the available spectrum metadata fields.

```{r}
mgf_fl <- file.path(pth, "GNPS_Drug_Library_Spectra_Drugs_and_Metabolites.mgf")
readLines(mgf_fl, n = 25)
```

The MGF format allows having additional, custom, fields to provide spectra
metadata on top of mandatory fields such as *PEPMASS* (for precursor *m/z*) or
*CHARGE* (for the precursor's charge). MGF files can be imported into a
`Spectra` object using the `r Biocpkg("MsBackendMgf")`, which supports to import
all metadata fields and rename and map them to specific spectra variables. Below
we define such a variable name mapping to map e.g. *MSLEVEL* to the spectra
variable `msLevel` and *NAME* to *spectrum_name*.

```{r}
library(MsBackendMgf)

#' Get the default spectra variable mapping
svm <- spectraVariableMapping(MsBackendMgf())
#' Add additional, custom, mappings
svm <- c(svm,
         msLevel = "MSLEVEL",
         spectrum_name = "NAME",
         inchi = "INCHI",
         smiles = "SMILES",
         exactmass = "EXACTMASS"
         )
```

We next import the MGF file into a `Spectra` object.

```{r}
#' import the MGF file
drug_ms2 <- Spectra(mgf_fl, source = MsBackendMgf(), mapping = svm)
```

For better integration into the R-based analysis workflows, we next reformat and
convert some of the imported spectra metadata. The *IONMODE* field encodes the
polarity in which MS/MS spectra were recorded as character strings `"Positive"`
and `"Negative"`. We convert these into the standard *polarity* encoding `0`
(negative) and `1` (positive).

```{r}
drug_ms2$polarity[which(drug_ms2$IONMODE == "Positive")] <- 1L
drug_ms2$polarity[which(drug_ms2$IONMODE == "Negative")] <- 0L
```

In the present data set only little *compound* annotations are provided. The
compound name is present in the name of the spectrum, along with other
spectrum-relevant information such as the adduct type and (in some cases) the
collision energy. In particular the adduct type might be interesting in
subsequent analyses and parsing this information from the spectrum name might be
helpful. Unfortunately, the format in which this information is encoded does not
seem to be very consistent:

```{r}
drug_ms2$spectrum_name |>
    head()
```

For these compounds, no charge or polarity information is provided, while for
other compounds the adduct encoding follows more the standardized format.

```{r}
drug_ms2$spectrum_name |>
    tail()
```

First examples how to extract and parse the adduct information are provided in
the next section. For the present examples we simply use the data as
provided. We first plot the first 4 reference spectra from the library.

```{r}
plotSpectra(drug_ms2[1:4])
```

Two things become apparent: firstly, *absolute* intensities are reported and
secondly, spectra seem to contain also very low abundant peaks, potentially
reflecting instrument noise. We therefore next filter the fragment spectra
removing peaks with an intensity lower than 1% of the maximum peak intensity and
scale the intensities of all spectra to a total sum of 1. Of course, this
cleaning approach should by no means be taken as the one *standard* way to clean
a spectral library.

```{r}
drug_ms2 <- drug_ms2 |>
    #' remove peaks with intensity < 1% max intensity
    filterIntensity(intensity = function(x, ...) {
        x > max(x, na.rm = TRUE) / 100
    }) |>
    #' scale intensities to a total sum of 1
    scalePeaks()
```

We plot the first 4 spectra again to evaluate the impact of this processing.

```{r}
plotSpectra(drug_ms2[1:4])
```

The number of fragment peaks per spectrum was thus reduced and intensities are
now relative to the total intensity sum.

This `Spectra` object, imported from an MGF file, can now be used in an
MS2-based annotation workflow, e.g. to match the MS/MS spectra of the
identified significant features from the *Complete end-to-end LC-MS/MS
metabolomics data analysis* workflow. Below we load the respective `Spectra`
object.

```{r}
#' load the MS2 spectra for significant features
fl <- system.file("extdata", "spectra_significant_fts.RData",
                  package = "Metabonaut")
load(fl) # ms2_ctr_fts
ms2_ctr_fts
```

This `Spectra` object contains the measured MS/MS spectra for features found to
have significant differences in abundances between the compared groups. Below we
use functionality from the `r Biocpkg("MetaboAnnotation")` to match these
fragment spectra against the GNPS2 drug library.

```{r}
#' match the experimental spectra against the GNPS2 drug library
library(MetaboAnnotation)
res <- matchSpectra(ms2_ctr_fts, drug_ms2,
                    CompareSpectraParam(tolerance = 0.1))
#' restrict data to matching spectra
res <- res[whichQuery(res)]
res <- pruneTarget(res)
```

And, not unexpectedly, most fragment spectra match to reference spectra for
caffeine.

```{r}
res$target_spectrum_name |> unique()
```

To summarize, through packages such as `r Biocpkg("MsBackendMgf")`, `r
Biocpkg("MsBackendMsp")` it is easily possible to integrate public (or in-house)
spectral reference libraries in MGF or MSP file format into R-based annotation
workflows.

### Importing and cleaning GNPS MGF files using Python's *matchms* library

As an alternative to the data processing in R, it is also possible to import and
clean the GNPS MGF file in Python (using the *matchms* library) and make that
data available in R through the `MsBackendPy` `Spectra` backend of the `r
Biocpkg("SpectriPy")` package [@graeve_spectripy_2025].

```{r}
#' load the required SpectriPy package; this will also install
#' eventually required Python libraries and dependencies
library(SpectriPy)
```

We next import the MGF file in Python using the *matchms* library
[@huber_matchms_2020].

```{python}
import matchms
from matchms.importing import load_from_mgf

#' import the fragment spectra from the MGF file
s_py = list(load_from_mgf(r.mgf_fl))
```

We next clean and harmonize the metadata fields using the respective functions
from the *matchms* library (still in Python). More information on the available
filters and additional filtering options are described in the
[*matchms.filtering*
documentation](https://matchms.readthedocs.io/en/latest/api/matchms.filtering.html)
or [@de_jonge_reproducible_2024].

```{python, warning = FALSE}
from matchms.filtering import default_filters, clean_adduct

#' apply filters to clean the spectra metadata
s_py_clean = []
for s in s_py:
    s = default_filters(s)
    s = clean_adduct(s)
    s_py_clean.append(s)

#' delete the unfiltered data
del s_py
```

To access the cleaned spectra data we create next a `Spectra` object using
*SpectriPy*'s `MsBackendPy` backend.

```{r}
#' reference the MS data in R
s_py <- Spectra("s_py_clean", source = MsBackendPy())
spectraVariables(s_py)
```

The *adduct* information was now harmonized by the filtering workflow in Python:

```{r}
#' get the unique adduct types
table(s_py$adduct)
```

The `s_py` `Spectra` object could now be used in R-based annotation workflows.
Note also that all MS data for this `Spectra` object is still stored in Python
and any data is translated *on-the-fly* from Python to R upon request. For
higher performance, it would also be possible to copy the full data from Python
to R by changing the backend of the `Spectra` object to `MsBackendMemory` with
`s_py <- setBackend(s_py, MsBackendMemory())`.

```{r, echo = FALSE, message = FALSE}
#' clean up temp dir
unlink(dir(pth, full.names = TRUE), recursive = TRUE)
```

## Using MassBank data

MassBank was one of the first open-source and open access cross-vendor mass
spectral libraries [@neumann_massbank_2025]. All content, which is validated
using automatic pipelines, is under version control and versioned releases are
pushed to an independent data repository. The easiest way to use MassBank
annotations in R is to get the respective database from Bioconductor's
*AnnotationHub*. This is also described in more detail in the *MS1-based
annotation* section in the main [end-to-end
workflow](https://rformassspectrometry.github.io/Metabonaut/articles/a-end-to-end-untargeted-metabolomics.html). Below
we first load the respective library and the list of available annotations from
AnnotationHub.

```{r, message = FALSE}
library(AnnotationHub)
#' load annotation metadata
ah <- AnnotationHub()
```

AnnotationHub can then be queried for MassBank records:

```{r}
mb <- query(ah, "MassBank")
data.frame(id = names(mb), description = mb$title)
```

And a specific MassBank release can then be loaded using the respective
AnnotationHub identifier. Below we load data from MassBank release *2023.11*.

```{r}
mb <- ah[["AH116166"]]
mb
```

The result is returned as a `CompDb` object from the `r Biocpkg("CompoundDb")`
package which can be directly used with the annotation functions from the `r
Biocpkg("MetaboAnnotation")` package. While this approach is convenient and
fast, not all MassBank releases are available through *AnnotationHub*.

As an alternative, the whole MassBank data can also be downloaded from either
the [MassBank GitHub page](https://github.com/MassBank/MassBank-data/releases)
or from [Zenodo](https;//zenodo.org). The DOI
[10.5281/zenodo.3378723](https://doi.org/10.5281/zenodo.3378723) links to all
available MassBank releases and resolves to the latest one. For our example, we
download the MassBank release *2025.10* from Zenodo using it's version-specific
DOI 10.5281/zenodo.17432277 :

```{r, message = FALSE}
library(Spectra)
library(zen4R)

doi <- "10.5281/zenodo.17432277"

pth <- tempdir()
download_zenodo(doi, path = pth, quiet = TRUE, timeout = 600)
dir(pth)
```

The archive contains several thousands of *.txt* files in MassBank format, one
for each spectrum. We next unzip the archive to the same temporary folder and
get the listing of all data files.

```{r}
#' unzip the archive
unzip(file.path(pth, dir(pth)[1L]), exdir = pth)

#' get the file listing
dr <- dir(pth, pattern = "MassBank-MassBank", full.names = TRUE)
fls <- dir(dr, recursive = TRUE, pattern = "txt$", full.names = TRUE)
length(fls)
```

Each of these files contains the data of a spectrum, the associated compound,
the instrumentation used and the data provider. The data is encoded in a
MassBank-specific file format, which can be imported using the
`MsBackendMassbank()` backend from the `r Biocpkg("MsBackendMassbank")`
package. Below we import the full MassBank release as a `Spectra` object using
the `MsBackendMassbank()` backend.

```{r, message = FALSE}
library(MsBackendMassbank)
#' import the full MassBank data as a Spectra object
s_mb <- Spectra(fls, source = MsBackendMassbank())
s_mb
```

Metadata and annotations of the compound are available as additional spectra
variables, such as `"name"`, `"smiles"`, `"formula"`, `"inchi"` etc. The full
list of available spectra metadata is:

```{r}
#' available spectra variables/metadata
spectraVariables(s_mb)
```

Note that the `metaBlocks` parameter could be used to import additional metadata
fields. In comparison to the metadata from the GNPS MGF file used in the
previous section, the spectra variables/metadata from MassBank are (more or
less) well standardized and harmonized. Also, much more compound-specific
information are available such as the chemical formula or exact mass of the
compound. This `Spectra` object can now also be used to calculate spectral
similarities between experimental and reference spectra, e.g. using the
`matchSpectra()` function. Below we calculate match the fragment spectra from
the main end-to-end vignette against the imported MassBank release 2025.10 data.

```{r}
#' match the experimental spectra against the GNPS2 drug library
res <- matchSpectra(ms2_ctr_fts, s_mb,
                    CompareSpectraParam(tolerance = 0.1))
#' restrict data to matching spectra
res <- res[whichQuery(res)]
res <- pruneTarget(res)
```

The experimental spectra match against spectra of compounds with the following
unique InChI:

```{r}
res$target_inchi |>
    unique()
```

The names (including aliases) of the compounds are:

```{r}
res$target_name |>
    unlist() |>
    unique()
```

```{r, echo = FALSE, message = FALSE}
#' clean the temporary directory
unlink(dir(pth, full.names = TRUE), recursive = TRUE)
```

# Creating or expanding annotation resources

In the previous chapter we have seen how annotation libraries provided in public
MS data file formats such as MGF or MSP can be imported and used in R. Of
course, any MS data in a `Spectra` object can then also be exported to any of
these file formats allowing thus to build new, or export cleaned and harmonized,
annotation libraries. As an alternative, and eventually preferable way, it is
possible to store annotation information for small compounds in SQLite databases
through the `r Biocpkg("CompoundDb")` package. It defines a very simple and
flexible SQL-based database layout for small compound annotations and allows to
store any MS-type data into a SQL database. In this chapter we create such a
database from the GNPS2 drug library loaded in the previous section. Other
examples are provided in the package vignette [*Creating CompoundDb annotation
resources*](https://rformassspectrometry.github.io/CompoundDb/articles/create-compounddb.html).

::: {.callout-note appearance="minimal"}
The *CompDb* database layout defines 3 main database tables, one for compound
annotations, one for spectra metadata and one to store the actual mass (or
fragment) peaks. These tables are linked with each other through specific
identifier columns (*primary/foreign keys*): each table has its own *ID* column
with **unique** identifiers for each row. To link the MS spectra tables with the
compound annotation table, the table with the MS spectra metadata contains in
addition a column with the identifiers of the compound the specific fragment
spectrum is associated with. An additional table *metadata* allows to define
metadata information for the full annotation resource, such as a version,
origin, DOI, etc.
:::

In our example We first define a `data.frame` with *compound* annotations for
the GNPS2 drug library. This table should contain all information specific for a
*compound*. In the present MGF file metadata consists mostly of information on
the generation of the spectrum, less on the compound. Only the name of the
spectrum and the *INCHI* column seem to contain compound-relevant
information. As an additional complication, the spectrum name combines the name
of the compound with information on the collision energy used to create the
spectrum and the ion it represents. Unfortunately, because this library contains
data from a variety of different sources, this information (as well as the
information in other columns) are not standardized:

```{r}
library(CompoundDb)

#' extract potential compound relevant information
cmps <- spectraData(drug_ms2, c("ORGANISM", "spectrum_name", "inchi",
                                "smiles", "exactmass")) |>
    as.data.frame()

#' inspect values for the spectrum name
cmps$spectrum_name |> head()
cmps$spectrum_name |> tail()
cmps$spectrum_name[1000:1006]
```

To define the names for the compounds we first parse (and then strip) the adduct
information from the spectrum name. The pattern defined below finds all
sub-strings that start with a white space, followed by no, one or two `"["`, an
`"M"` (or `"2M"` etc) with a `"+"` or a `"-"` followed by any character until
the end of the string. This patter *should* allow to find all adduct
definitions, even if they don't follow the standard nomenclature.

```{r}
sname <- cmps$spectrum_name

#' define the pattern for adduct definitions
paddct <- "\\s(\\[{0,2}\\d?M)(\\]|\\+|-|$).*$"

#' extract the adduct definition from the spectrum names
library(stringr)
addct <- str_extract(sname, paddct) |>
    str_trim()
head(unique(addct))
tail(unique(addct))
```

Ideally, we should now clean and standardize the adduct definitions,
e.g. convert `"M+H"` or `"[[M+H]+]"` into the standard `"[M+H]+` form, but this
is outside the scope of this tutorial. For this example we keep the provided
adduct definitions and assign them as a new spectra variable *adduct* to the
`Spectra` object.

```{r}
#' create a new spectra variable with adduct information
drug_ms2$adduct <- addct
```

We proceed cleaning the compound name by stripping the above adduct information
from the spectrum names. Also, we remove any eventual occurrences of `"
Unknown$"` from the end of the string and remove spurious extra quotes (`"\""`)
from the compound's names.

```{r}
#' remove any adduct definitions from the compound name
cname <- sub(paddct, "", sname) |>
    sub(pattern = "\\sUnknown$", replacement = "") |>
    gsub(pattern = "\"", replacement = "")
```

For some spectra also the collision energy was included in the name. Some
examples are:

```{r}
cname[c(844, 845, 8845, 8846, 69316, 9762, 9763)]
```

We define a pattern to capture these collision energy definitions and strip
it from the compound names.

```{r}
pce1 <- "(_|\\s-\\s|\\s)(\\d*.*)eV$"
pce2 <- " CollisionEnergy:\\d+$"
cname <- sub(pattern = pce1, replacement = "", cname) |>
    sub(pattern = pce2, replacement = "")
```

Depending on the source of origin, for some spectra, also the original database
ID is provided along with the compound name. Some examples are provided below.

```{r}
cname[c(36925, 56836, 57333, 68442)]
```

Ideally, such information could be extracted and stored in separate columns, but
for simplicity we keep the defined names as *compound name* and add them to our
compound `data.frame`. We in addition rename the *ORGANISM* column (contains the
original data source of the spectra) and ensure the exact mass is reported as a numeric.

```{r}
#' add compound names to the data.frame
cmps$name <- cname
#' remove unneded columns
cmps$spectrum_name <- NULL
#' rename "ORGANISM" column name to "data_origin"
colnames(cmps) <- sub("ORGANISM", "data_origin", colnames(cmps))
#' ensure column exactmass is of type numeric
cmps$exactmass <- as.numeric(cmps$exactmass)
```

At last we fix some of the issues in the *smiles* and *inchi* columns by
stripping leading and trailing white spaces and removing non-standard missing
value encoding such as `"N/A"` as well as extra quotes `"`.

```{r}
#' excess "
cmps$inchi <- gsub("\"", "", cmps$inchi)
cmps$smiles <- gsub("\"", "", cmps$smiles)
#' white spaces
cmps$inchi <- str_trim(cmps$inchi)
cmps$smiles <- str_trim(cmps$smiles)
#' NA encodings
cmps$inchi[cmps$inchi == ""] <- NA_character_
cmps$inchi <- sub("^N/A", NA_character_, cmps$inchi)
cmps$smiles[cmps$smiles == ""] <- NA_character_
cmps$smiles <- sub("^N/A", NA_character_, cmps$smiles)
```

Finally, we add remaining required columns `"inchikey"`, `"formula"` and
`"synonyms"`. No related information was provided in the input MGF and we thus
fill these with `NA`.

```{r}
#' add missing columns and initialize with NA
cmps$inchikey <- NA_character_
cmps$formula <- NA_character_
cmps$synonyms <- NA_character_
```

Having defined a `data.frame` with information on the compounds we next proceed
to define reference spectra metadata. The suggested metadata columns for spectra
are `"polarity"` (`0` for negative, `1` for positive, `NA` for unknown),
`"collision_energy"` (as a `numeric`), `"instrument"` (a `character` with
information on the instrument, e.g. the manufacturer or name of the instrument),
`"instrument_type"` (a `character` with the *type* of instrument), and
`"precursor_mz'` (`numeric` with the precursor *m/z*). *CompoundDb* supports
also arbitrary additional columns to be defined and stored in the database. We
therefore extract the relevant spectra variables from the `Spectra` object with
the GNPS2 drug library data and convert the results into a `data.frame`.

```{r}
#' extract the spectra information and data
spctra <- spectraData(drug_ms2,
                      c("spectrum_name",
                        "polarity",
                        "collisionEnergy",
                        "FILENAME",
                        "PI",
                        "DATACOLLECTOR",
                        "PUBMED",
                        "LIBRARYQUALITY",
                        "SPECTRUMID",
                        "SOURCE_INSTRUMENT",
                        "precursorMz",
                        "mz",
                        "intensity")
                      ) |>
    as.data.frame()
```

Also for this data some data cleaning and reformatting is required. We rename
first the GNPS MGF field *SOURCE_INSTRUMENT* to `"instrument_type"` and add a
column `"instrument"`, for which however no information is provided. Also, we
remove non-standard encodings for missing values (e.g. `"N/A"`) from relevant
columns and replace them with `NA`.

```{r}
#' add instrument information
colnames(spctra) <- sub("SOURCE_INSTRUMENT", "instrument_type",
                        colnames(spctra))
spctra$instrument <- NA_character_
#' fix missing values
spctra$PI <- sub("^N/A", NA_character_, spctra$PI)
spctra$DATACOLLECTOR <- sub("^N/A", NA_character_, spctra$DATACOLLECTOR)
spctra$PUBMED <- sub("^N/A", NA_character_, spctra$PUBMED)
```

We next change column names to have a more consistent style and to match spectra
variable naming conventions in *Spectra*/*CompoundDb*.

```{r}
#' reformat column names
colnames(spctra) <- sub("collisionEnergy", "collision_energy",
                        colnames(spctra))
colnames(spctra) <- sub("precursorMz", "precursor_mz", colnames(spctra))
colnames(spctra) <- sub("SPECTRUMID", "original_spectrum_id", colnames(spctra))
colnames(spctra) <- tolower(colnames(spctra))
```

At last we need to define the association between elements (rows) in the
*spectra* data frame `spctra` with elements in the *compounds* data frame
`cmps`. To this end we first add columns with unique identifiers for spectra and
comounds. These are only used internally and can therefore be arbitrarily
defined.

```{r}
#' add compound and spectra IDs to the respective tables
n <- ceiling(log10(nrow(cmps)))
cmps$compound_id <- sprintf(paste0("CMP%0", n, "d"), seq_len(nrow(cmps)))
spctra$spectrum_id <- seq_len(nrow(cmps))
```

We can then define the mapping between spectra and compounds. In an ideal case,
the compounds data frame would only contain unique entries, i.e., each row would
be one unique compound while the spectra data frame could have multiple MS/MS
spectra for each of these. In the present data set, however, the compound
annotation is not normalized and the table contains repetitive and redundant
information. In fact, each row in the compound table is associated with one row
of the spectra data frame and we thus simply add a column `"compound_id"` to
`spectra` with the identifiers of the compounds.

```{r}
#' define the relationship between spectra and compounds
spctra$compound_id <- cmps$compound_id
```

At last we also define metadata information for the current annotation
database. This allows to provides important information on the data origin and
eventually version and enables reproducibility.

```{r metadata, message = FALSE}
#' define metadata for the annotation resource
metad <- make_metadata(source = "GNPS",
                       url = "https://doi.org/10.5281/zenodo.17232042",
                       source_version = "v4",
                       source_date = "2025-09-30",
                       organism = NA_character_)
```

Now, with all tables and relevant information available, we can create the
SQLite-based annotation resource using the `createCompDb()` function

```{r, warning = FALSE}
#' create an annotation database in CompDb format
db_file <- createCompDb(cmps,
                        metadata = metad,
                        msms_spectra = spctra,
                        dbFile = "GNPS-drug-library.v4.sqlite")
```

All information from the provided database tables was stored into the SQLite
database file *`r db_file`*. This database can be used with any SQLite
client. We could for example directly access data from the database using the
*RSQLite* package. Below we connect to the database and list the available
database tables.

```{r}
library(RSQLite)
#' connect to the database
con <- dbConnect(SQLite(), db_file)
#' list the available tables
dbListTables(con)
```

We could also use SQL queries to retrieve data from this database. For example
we extract below the first 10 entries of the database table with the mass peak
data.

```{r}
#' get first 10 rows of the peak data table
dbGetQuery(con, "select * from msms_spectrum_peak limit 10")
#' disconnect from the database
dbDisconnect(con)
```

For a more direct, and easier, use it is also possible to load the database as a
`CompDb` annotation resource:

```{r}
cdb <- CompDb(db_file)
cdb
```

This allows a more simplified access to the information within the database, but
functions provided by the `r Biocpkg("CompoundDb")` package, such as
`compounds()`, `filter()` to extract compounds or filter the data resource or
also `metadata()` to get the database's metadata.

```{r}
#' get the resource's metadata
metadata(cdb)
```

The optimal way to integrate *CompDb* annotation resources in MS2-based
annotation workflows is however to interface and access it through a `Spectra`
object.

```{r}
#' access the annotation resource as a `Spectra` object
sps_cdb <- Spectra(cdb)
sps_cdb
```

This `Spectra` object can then be used for annotation workflows as described in
the previous section or the *MS2-based annotation* section of the main
[*Complete end-to-end LC-MS/MS Metabolomic Data
analysis*](https://rformassspectrometry.github.io/Metabonaut/articles/a-end-to-end-untargeted-metabolomics.html)
workflow.

# Properties of `CompDb`, MGF and MSP-format based annotation resources

The ecosystem of R-packages around the `r Biocpkg("Spectra")` package allows to
load MS data from a large variety of file formats hence supporting to integrate
a variety of different sources of spectral libraries into R-based annotation
workflows.

MGF or MSP are currently the most frequently used file formats for exchange and
sharing of spectral libraries. These formats require all eventual compound
annotations to be provided as metadata for **each** fragment spectrum and
contain therefore highly redundant and repetitive information. Files in MGF or
MSP format can be loaded with the `r Biocpkg("MsBackendMgf")` or `r
Biocpkg("MsBackendMsp")` packages (see previous section). From a technical
perspective, loading any such file requires the import of its full
data. Depending on the number of contained spectra, this can take a considerable
amount of time and requires sufficient free main memory on the executing
computer.

For example, the memory usage for the GNPS drug library imported from the MGF
file is

```{r}
print(object.size(drug_ms2), unit = "MB")
```

While the memory demand for this particular file is very manageable, loading the
full GNPS library can be problematic.

In contrast, the memory size for the `Spectra` object of the *CompDb* annotation
database created from the GNPS2 drug library is only:

```{r}
print(object.size(sps_cdb), unit = "MB")
```

In fact, the `sps_cdb` `Spectra` object keeps only the spectrum identifiers in
memory while any other data (including the *m/z* or intensity values) are
fetched from the database on-demand. This ensures a very low memory footprint.

Another advantage of *CompDb* resources over MGF/MSP-based file formats is the
possibility to assign *metadata* to the resource:

```{r}
metadata(cdb)
```

However, for *CompDb* databases, the annotation data needs to be first stored
the SQLite databases and this can involve, depending on the input source,
cleaning, standardizing and converting data fields and values. Once performed,
however, the resource is self-contained and can be redistributed or shared.

Finally, the *CompDb* format would also support adding new compound annotations
or fragment spectra to an existing database hence allowing to build and extend
e.g. in-house libraries. See the [*Creating CompounDb annotation
resources*](https://rformassspectrometry.github.io/CompoundDb/articles/create-compounddb.html)
*CompoundDb* package vignette.

On the downside, at present, the file format is currently only supported by
R-based workflows, although any SQLite-supporting software could use and extract
data from the *CompDb*-format database.

```{r, echo = FALSE, message = FALSE}
#' clean up
unlink(db_file)
```

# Summary

Importing and using one of the available public reference library is straight
forward and can be done with a few lines of code. The bigger issue is to
harmonize metadata and compound annotations as each individual annotation source
uses their own convention. Interpretation or any further processing of
annotation results would however benefit from a harmonized, cleaned and
standardized information. Efforts such as [@de_jonge_reproducible_2024] exist,
but more and improved standardization and consolidation - not only of the data,
but also naming conventions used in the various software tools are required.

# Outlook

- Support for the newly defined *mzSpecLib* file format will be added to the
  *RforMassSpectrometry* package ecosystem.
- Access to public libraries will be simplified, e.g. by making them available
  through *AnnotationHub*.

# Session information

```{r}
sessionInfo()
```

# References
