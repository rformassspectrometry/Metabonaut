---
title: "Using and Creating Metabolomics Data Annotation Resources"
author: "Philippine Louail, Johannes Rainer"
format: html
minimal: true
bibliography: creating-using-annotation-resources.bib
date: 'Compiled: `r format(Sys.Date(), "%B %d, %Y")`'
vignette: >
  %\VignetteIndexEntry{Using and Creating Metabolomics Data Annotation Resources}
  %\VignetteEngine{quarto::html}
  %\VignetteEncoding{UTF-8}
  %\VignetteDepends{Spectra,stringr,CompoundDb,MetaboAnnotation,AnnotationHub,MsBackendMgf,MsBackendMassbank,zen4R,BiocStyle,SpectriPy}
---

```{r setup, include=FALSE}
library(knitr)
library(quarto)
library(BiocStyle)
knitr::opts_knit$set(root.dir = './')
```

# Introduction

This document shows how to access, use, and build annotation resources for
untargeted metabolomics data. Reference spectral libraries are available from
several sources, including:

- [GNPS](https://gnps.ucsd.edu/ProteoSAFe/static/gnps-splash.jsp): the Global
  Natural Products Social Molecular Networking (GNPS) is an open-access
  knowledge base for community-wide organization and sharing of raw, processed
  or identified MS/MS spectrometry data [@wang_sharing_2016].
- [MassBank](https://massbank.eu/MassBank/): MassBank is an open source mass
  spectral library for the identification of small chemical molecules of
  metabolomics, exposomics and environmental relevance [@neumann_massbank_2025].
- [HMDB](https://www.hmdb.ca/): the Human Metabolome Database (HMDB) is a freely
  available electronic database containing detailed information about small
  molecule metabolites found in the human body [@wishart_hmdb_2021].
- [MoNA](https://mona.fiehnlab.ucdavis.edu/): MassBank of North America (MoNA)
  is a metadata-centric, auto-curating repository for efficient storage and
  querying of mass spectral records.

Across resources, file formats, naming, and available annotations differ, so
imports can be cumbersome. Packages exist for most formats, but harmonization
remains challenging. Here we import public spectral libraries into data
structures suitable for LC-MS/MS annotation, extract metadata, and outline
future work toward harmonized formats such as
[*mzSpecLib*](https://github.com/HUPO-PSI/mzSpecLib).

# Accessing and using spectral libraries

Spectral libraries come in different formats. Packages from the
*RforMassSpectrometry* initiative (`r Biocpkg("MsBackendMgf")`, `r
Biocpkg("MsBackendMsp")`, `r Biocpkg("MsBackendMassbank")`, `r
Biocpkg("CompoundDb")`) parse these formats into `Spectra` objects ready for
R-based workflows. Below we load GNPS and MassBank libraries for LC-MS/MS
annotation.

## Using spectral libraries from GNPS

[GNPS2](https://gnps2.org) provides MS/MS spectral libraries, integrating data
from sources such as [MassBank](https://massbank.eu/MassBank/) and
[MoNA](https://mona.fiehnlab.ucdavis.edu/). Libraries are available as MGF, MSP,
or JSON from the [GNPS2 site](https://external.gnps2.org/gnpslibrary) and on
Zenodo or Figshare with their own DOIs.

Here we download the GNPS2 drug library from
[Zenodo](https://doi.org/10.5281/zenodo.13892288), a centralized collection of
drug spectra with pharmacologic metadata [@zhao_resource_2025]. We fetch all v4
resources (DOI: 10.5281/zenodo.17232042) to a temporary folder.

```{r, message = FALSE}
library(Spectra)
library(zen4R)

doi <- "10.5281/zenodo.17232042" # v4

#' download all data related to the DOI
pth <- tempdir()
download_zenodo(doi, path = pth, quiet = TRUE, timeout = 600)
dir(pth)
```

The spectral libraries are available in MGF file format. Below we read the first
25 lines of the MGF file to inspect the available spectrum metadata fields.

```{r}
mgf_fl <- file.path(pth, "GNPS_Drug_Library_Spectra_Drugs_and_Metabolites.mgf")
readLines(mgf_fl, n = 25)
```

The MGF format allows having additional fields to provide spectra metadata on
top of mandatory fields such as *PEPMASS* (for precursor *m/z*) or *CHARGE* (for
the precursor's charge). MGF files can be imported into a `Spectra` object using
the `r Biocpkg("MsBackendMgf")`, which supports import of all metadata fields,
renaming and mapping them to specific spectra variables. Below we define such a
variable name mapping to map e.g. *MSLEVEL* to the spectra variable `msLevel`
and *NAME* to *spectrum_name*.

```{r}
library(MsBackendMgf)

#' Get the default spectra variable mapping
svm <- spectraVariableMapping(MsBackendMgf())
#' Add additional, custom, mappings
svm <- c(svm,
         msLevel = "MSLEVEL",
         spectrum_name = "NAME",
         inchi = "INCHI",
         smiles = "SMILES",
         exactmass = "EXACTMASS"
         )
```

We next import the MGF file into a `Spectra` object.

```{r}
#' import the MGF file
drug_ms2 <- Spectra(mgf_fl, source = MsBackendMgf(), mapping = svm)
```

We convert `IONMODE` from `"Positive"`/`"Negative"` to the standard `polarity`
encoding (`1`/`0`).

```{r}
drug_ms2$polarity[which(drug_ms2$IONMODE == "Positive")] <- 1L
drug_ms2$polarity[which(drug_ms2$IONMODE == "Negative")] <- 0L
```

Compound annotations are sparse in the imported library. Spectrum names hold the
compound, adduct, and sometimes collision energy, but formatting is
inconsistent:

```{r}
drug_ms2$spectrum_name |>
    head()
```

For these compounds, no charge or polarity information is provided, while for
other compounds the adduct encoding follows more the standardized format.

```{r}
drug_ms2$spectrum_name |>
    tail()
```

First examples how to extract and parse the adduct information are provided in
the next section. For the present examples we simply use the data as
provided. We first plot the first 4 reference spectra from the library.

```{r}
plotSpectra(drug_ms2[1:4])
```

Two things stand out: intensities are *absolute*, and a large number of
low-abundance peaks are present likely reflecting instrument noise. We remove
peaks below 1% of the maximum and scale intensities to sum to 1. This is one
possible cleaning choice, not a standard.

```{r}
drug_ms2 <- drug_ms2 |>
    #' remove peaks with intensity < 1% max intensity
    filterIntensity(intensity = function(x, ...) {
        x > max(x, na.rm = TRUE) / 100
    }) |>
    #' scale intensities to a total sum of 1
    scalePeaks()
```

We plot the first 4 spectra again to evaluate the impact of this processing.

```{r}
plotSpectra(drug_ms2[1:4])
```

The number of fragment peaks per spectrum was thus reduced and intensities are
now relative to the total intensity sum.

This `Spectra` object can now be used to match MS/MS spectra from the *Complete
end-to-end LC-MS/MS metabolomics data analysis* workflow. We load the example
`Spectra` object below.

```{r}
#' load the MS2 spectra for significant features
fl <- system.file("extdata", "spectra_significant_fts.RData",
                  package = "Metabonaut")
load(fl) # ms2_ctr_fts
ms2_ctr_fts
```

This `Spectra` object contains MS/MS spectra for features with significant
abundance differences. We match them against the GNPS2 drug library with
`r Biocpkg("MetaboAnnotation")`.

```{r}
#' match the experimental spectra against the GNPS2 drug library
library(MetaboAnnotation)
res <- matchSpectra(ms2_ctr_fts, drug_ms2,
                    CompareSpectraParam(tolerance = 0.1))
#' restrict data to matching spectra
res <- res[whichQuery(res)]
res <- pruneTarget(res)
```

And, not unexpectedly, most fragment spectra match to reference spectra for
caffeine.

```{r}
res$target_spectrum_name |> unique()
```

To summarize, through packages such as `r Biocpkg("MsBackendMgf")`, `r
Biocpkg("MsBackendMsp")` it is easily possible to integrate public (or in-house)
spectral reference libraries in MGF or MSP file format into R-based annotation
workflows.

### Importing and cleaning GNPS MGF files using Python's *matchms* library

Alternatively, it is possible to import and clean the GNPS MGF file in Python
with *matchms* and access it in R through `MsBackendPy` from the `r
Biocpkg("SpectriPy")` package [@graeve_spectripy_2025].

```{r}
#' load the required SpectriPy package; this will also install
#' eventually required Python libraries and dependencies
library(SpectriPy)
```

We next import the MGF file in Python using the *matchms* library
[@huber_matchms_2020].

```{python}
import matchms
from matchms.importing import load_from_mgf

#' import the fragment spectra from the MGF file
s_py = list(load_from_mgf(r.mgf_fl))
```

Next we clean and harmonize metadata with *matchms* filters. See the
[*matchms.filtering* documentation](https://matchms.readthedocs.io/en/latest/api/matchms.filtering.html)
or [@de_jonge_reproducible_2024] for options.

```{python, warning = FALSE}
from matchms.filtering import default_filters, clean_adduct

#' apply filters to clean the spectra metadata
s_py_clean = []
for s in s_py:
    s = default_filters(s)
    s = clean_adduct(s)
    s_py_clean.append(s)

#' delete the unfiltered data
del s_py
```

To access the cleaned spectra data we create next a `Spectra` object using
*SpectriPy*'s `MsBackendPy` backend.

```{r}
#' reference the MS data in R
s_py <- Spectra("s_py_clean", source = MsBackendPy())
spectraVariables(s_py)
```

The *adduct* information was now harmonized by the filtering workflow in Python:

```{r}
#' get the unique adduct types
table(s_py$adduct)
```

The `s_py` `Spectra` object is ready for R workflows. Data stay in Python and is
translated on demand; switch to `MsBackendMemory` to copy it to R if needed.

```{r, echo = FALSE, message = FALSE}
#' clean up temp dir
unlink(dir(pth, full.names = TRUE), recursive = TRUE)
```

## Using MassBank data

MassBank was one of the first open-source and open access cross-vendor mass
spectral libraries [@neumann_massbank_2025]. All content, which is validated
using automatic pipelines, is under version control and versioned releases are
pushed to an independent data repository. The easiest way to use MassBank
annotations in R is to get the respective database from Bioconductor's
*AnnotationHub*. This is also described in more detail in the *MS1-based
annotation* section in the main [end-to-end
workflow](https://rformassspectrometry.github.io/Metabonaut/articles/a-end-to-end-untargeted-metabolomics.html). Below
we first load the respective library and the list of available annotations from
AnnotationHub.

```{r, message = FALSE}
library(AnnotationHub)
#' load annotation metadata
ah <- AnnotationHub()
```

AnnotationHub can then be queried for MassBank records:

```{r}
mb <- query(ah, "MassBank")
data.frame(id = names(mb), description = mb$title)
```

And a specific MassBank release can then be loaded using the respective
AnnotationHub identifier. Below we load data from MassBank release *2023.11*.

```{r}
mb <- ah[["AH116166"]]
mb
```

The result is returned as a `CompDb` object from the `r Biocpkg("CompoundDb")`
package which can be directly used with the annotation functions from the `r
Biocpkg("MetaboAnnotation")` package. While this approach is convenient and
fast, not all MassBank releases are available through *AnnotationHub*.

Alternatively, download MassBank data from the [MassBank GitHub
page](https://github.com/MassBank/MassBank-data/releases) or Zenodo. DOI
[10.5281/zenodo.3378723](https://doi.org/10.5281/zenodo.3378723) points to the
latest release. Here we fetch release *2025.10* via DOI 10.5281/zenodo.17432277:

```{r, message = FALSE}
library(Spectra)
library(zen4R)

doi <- "10.5281/zenodo.17432277"

pth <- tempdir()
download_zenodo(doi, path = pth, quiet = TRUE, timeout = 600)
dir(pth)
```

The archive contains several thousands of *.txt* files in MassBank format, one
for each spectrum. We next unzip the archive to the same temporary folder and
get the listing of all data files.

```{r}
#' unzip the archive
unzip(file.path(pth, dir(pth)[1L]), exdir = pth)

#' get the file listing
dr <- dir(pth, pattern = "MassBank-MassBank", full.names = TRUE)
fls <- dir(dr, recursive = TRUE, pattern = "txt$", full.names = TRUE)
length(fls)
```

Each file holds one spectrum with compound, instrument, and provider metadata in
MassBank format. We import the full release with `MsBackendMassbank()` into a
`Spectra` object.

```{r, message = FALSE}
library(MsBackendMassbank)
#' import the full MassBank data as a Spectra object
s_mb <- Spectra(fls, source = MsBackendMassbank())
s_mb
```

Metadata and annotations of the compound are available as additional spectra
variables, such as `"name"`, `"smiles"`, `"formula"`, `"inchi"` etc. The full
list of available spectra metadata is:

```{r}
#' available spectra variables/metadata
spectraVariables(s_mb)
```

The `metaBlocks` parameter can be used to enable import of extra
metadata. MassBank metadata are *generally* more standardized and include more
compound information (e.g., formula, exact mass). We now match the end-to-end
vignette spectra against MassBank 2025.10 with `matchSpectra()`.

```{r}
#' match the experimental spectra against the GNPS2 drug library
res <- matchSpectra(ms2_ctr_fts, s_mb,
                    CompareSpectraParam(tolerance = 0.1))
#' restrict data to matching spectra
res <- res[whichQuery(res)]
res <- pruneTarget(res)
```

The experimental spectra match against spectra of compounds with the following
unique InChI:

```{r}
res$target_inchi |>
    unique()
```

The names (including aliases) of the compounds are:

```{r}
res$target_name |>
    unlist() |>
    unique()
```

```{r, echo = FALSE, message = FALSE}
#' clean the temporary directory
unlink(dir(pth, full.names = TRUE), recursive = TRUE)
```

# Creating or expanding annotation resources

Public MGF/MSP libraries can be imported into `Spectra` and exported again.
Alternatively, annotations can be stored in SQL databases *via* the `r
Biocpkg("CompoundDb")` package, which defines a simple database schema for small
compounds and MS data. Here we build a database from the GNPS2 drug library; see
the vignette [*Creating CompoundDb annotation
resources*](https://rformassspectrometry.github.io/CompoundDb/articles/create-compounddb.html)
for more examples.

::: {.callout-note appearance="minimal"}
The *CompDb* database layout defines 3 main database tables, one for compound
annotations, one for spectra metadata and one to store the actual mass (or
fragment) peaks. These tables are linked with each other through specific
identifier columns (*primary/foreign keys*): each table has its own *ID* column
with **unique** identifiers for each row. To link the MS spectra tables with the
compound annotation table, the table with the MS spectra metadata contains in
addition a column with the identifiers of the compound the specific fragment
spectrum is associated with. An additional table *metadata* allows to define
metadata information for the full annotation resource, such as a version,
origin, DOI, etc.
:::

We first define a `data.frame` with compound annotations for the GNPS2 drug
library. The MGF metadata mainly describe spectrum generation, with compound
details mostly in the spectrum name and *INCHI*. Spectrum names often mix in
collision energy and ion information and are not standardized:

```{r}
library(CompoundDb)

#' extract potential compound relevant information
cmps <- spectraData(drug_ms2, c("ORGANISM", "spectrum_name", "inchi",
                                "smiles", "exactmass")) |>
    as.data.frame()

#' inspect values for the spectrum name
cmps$spectrum_name |> head()
cmps$spectrum_name |> tail()
cmps$spectrum_name[1000:1006]
```

To define the names for the compounds we first parse (and then strip) the adduct
information from the spectrum name. The pattern defined below finds all
sub-strings that start with a white space, followed by no, one or two `"["`, an
`"M"` (or `"2M"` etc) with a `"+"` or a `"-"` followed by any character until
the end of the string. This patter *should* allow to find all adduct
definitions, even if they don't follow the standard nomenclature.

```{r}
sname <- cmps$spectrum_name

#' define the pattern for adduct definitions
paddct <- "\\s(\\[{0,2}\\d?M)(\\]|\\+|-|$).*$"

#' extract the adduct definition from the spectrum names
library(stringr)
addct <- str_extract(sname, paddct) |>
    str_trim()
head(unique(addct))
tail(unique(addct))
```

Ideally we would standardize adducts (e.g., convert `"M+H"` or `"[[M+H]+]"` to
`"[M+H]+"`), but here we keep the provided values and store them as a new
`adduct` variable.

```{r}
#' create a new spectra variable with adduct information
drug_ms2$adduct <- addct
```

We strip adducts from the spectrum names, drop trailing `" Unknown"`, and remove
extra quotes.

```{r}
#' remove any adduct definitions from the compound name
cname <- sub(paddct, "", sname) |>
    sub(pattern = "\\sUnknown$", replacement = "") |>
    gsub(pattern = "\"", replacement = "")
```

For some spectra also the collision energy was included in the name. Some
examples are:

```{r}
cname[c(844, 845, 8845, 8846, 69316, 9762, 9763)]
```

We define a pattern to capture these collision energy definitions and strip
it from the compound names.

```{r}
pce1 <- "(_|\\s-\\s|\\s)(\\d*.*)eV$"
pce2 <- " CollisionEnergy:\\d+$"
cname <- sub(pattern = pce1, replacement = "", cname) |>
    sub(pattern = pce2, replacement = "")
```

Some spectrum names also include the original database ID:

```{r}
cname[c(36925, 56836, 57333, 68442)]
```

Ideally we would split these IDs into separate columns; here we keep them in the
compound name, rename *ORGANISM* to *data_origin*, and ensure *exactmass* is
numeric.

```{r}
#' add compound names to the data.frame
cmps$name <- cname
#' remove unneded columns
cmps$spectrum_name <- NULL
#' rename "ORGANISM" column name to "data_origin"
colnames(cmps) <- sub("ORGANISM", "data_origin", colnames(cmps))
#' ensure column exactmass is of type numeric
cmps$exactmass <- as.numeric(cmps$exactmass)
```

We clean *smiles* and *inchi* by trimming whitespace, removing `"N/A"`, and
dropping extra quotes.

```{r}
#' excess "
cmps$inchi <- gsub("\"", "", cmps$inchi)
cmps$smiles <- gsub("\"", "", cmps$smiles)
#' white spaces
cmps$inchi <- str_trim(cmps$inchi)
cmps$smiles <- str_trim(cmps$smiles)
#' NA encodings
cmps$inchi[cmps$inchi == ""] <- NA_character_
cmps$inchi <- sub("^N/A", NA_character_, cmps$inchi)
cmps$smiles[cmps$smiles == ""] <- NA_character_
cmps$smiles <- sub("^N/A", NA_character_, cmps$smiles)
```

Finally, we add remaining required columns `"inchikey"`, `"formula"` and
`"synonyms"`. No related information was provided in the input MGF and we thus
fill these with `NA`.

```{r}
#' add missing columns and initialize with NA
cmps$inchikey <- NA_character_
cmps$formula <- NA_character_
cmps$synonyms <- NA_character_
```

Next we define spectra metadata. Suggested columns include `polarity`
(`0/1/NA`), `collision_energy`, `instrument`, `instrument_type`, and
`precursor_mz` with *CompoundDb* accepting also optional additional columns. We
extract these from the GNPS2 `Spectra` object into a `data.frame`.

```{r}
#' extract the spectra information and data
spctra <- spectraData(drug_ms2,
                      c("spectrum_name",
                        "polarity",
                        "collisionEnergy",
                        "FILENAME",
                        "PI",
                        "DATACOLLECTOR",
                        "PUBMED",
                        "LIBRARYQUALITY",
                        "SPECTRUMID",
                        "SOURCE_INSTRUMENT",
                        "precursorMz",
                        "mz",
                        "intensity")
                      ) |>
    as.data.frame()
```

We rename *SOURCE_INSTRUMENT* to `instrument_type`, add an empty
`instrument` column, and replace `"N/A"` with `NA`.

```{r}
#' add instrument information
colnames(spctra) <- sub("SOURCE_INSTRUMENT", "instrument_type",
                        colnames(spctra))
spctra$instrument <- NA_character_
#' fix missing values
spctra$PI <- sub("^N/A", NA_character_, spctra$PI)
spctra$DATACOLLECTOR <- sub("^N/A", NA_character_, spctra$DATACOLLECTOR)
spctra$PUBMED <- sub("^N/A", NA_character_, spctra$PUBMED)
```

We standardize column names to match *Spectra*/*CompoundDb* conventions.

```{r}
#' reformat column names
colnames(spctra) <- sub("collisionEnergy", "collision_energy",
                        colnames(spctra))
colnames(spctra) <- sub("precursorMz", "precursor_mz", colnames(spctra))
colnames(spctra) <- sub("SPECTRUMID", "original_spectrum_id", colnames(spctra))
colnames(spctra) <- tolower(colnames(spctra))
```

To allow linking spectra to compounds (i.e., rows in the `cmps` with rows in
the `spctra` data frames) we add unique IDs for each table.

```{r}
#' add compound and spectra IDs to the respective tables
n <- ceiling(log10(nrow(cmps)))
cmps$compound_id <- sprintf(paste0("CMP%0", n, "d"), seq_len(nrow(cmps)))
spctra$spectrum_id <- seq_len(nrow(cmps))
```

Ideally compounds would be unique and spectra could map many-to-one. Here each
compound row corresponds to one spectrum, so we add `compound_id` directly to
`spctra`.

```{r}
#' define the relationship between spectra and compounds
spctra$compound_id <- cmps$compound_id
```

Finally we define database metadata (origin, version, DOI) for reproducibility.

```{r metadata, message = FALSE}
#' define metadata for the annotation resource
metad <- make_metadata(source = "GNPS",
                       url = "https://doi.org/10.5281/zenodo.17232042",
                       source_version = "v4",
                       source_date = "2025-09-30",
                       organism = NA_character_)
```

Now, with all tables and relevant information available, we can create the
SQLite-based annotation resource using the `createCompDb()` function

```{r, warning = FALSE}
#' create an annotation database in CompDb format
db_file <- createCompDb(cmps,
                        metadata = metad,
                        msms_spectra = spctra,
                        dbFile = "GNPS-drug-library.v4.sqlite")
```

All tables are stored in the SQLite file *`r db_file`*, usable with any SQLite
client. Below we connect with *RSQLite* and list tables.

```{r}
library(RSQLite)
#' connect to the database
con <- dbConnect(SQLite(), db_file)
#' list the available tables
dbListTables(con)
```

We could also use SQL queries to retrieve data from this database. For example
we extract below the first 10 entries of the database table with the mass peak
data.

```{r}
#' get first 10 rows of the peak data table
dbGetQuery(con, "select * from msms_spectrum_peak limit 10")
#' disconnect from the database
dbDisconnect(con)
```

For direct use, we load the database as a `CompDb` annotation resource:

```{r}
cdb <- CompDb(db_file)
cdb
```

This simplifies access via `r Biocpkg("CompoundDb")` functions such as
`compounds()`, `filter()`, and `metadata()`.

```{r}
#' get the resource's metadata
metadata(cdb)
```

For MS2 workflows, interface with the `CompDb` via a `Spectra` object.

```{r}
#' access the annotation resource as a `Spectra` object
sps_cdb <- Spectra(cdb)
sps_cdb
```

This `Spectra` object can then be used for annotation workflows as described in
the previous section or the *MS2-based annotation* section of the main
[*Complete end-to-end LC-MS/MS Metabolomic Data
analysis*](https://rformassspectrometry.github.io/Metabonaut/articles/a-end-to-end-untargeted-metabolomics.html)
workflow.

# Properties of `CompDb`, MGF and MSP-format based annotation resources

The `r Biocpkg("Spectra")` ecosystem loads MS data from many formats, enabling
integration of diverse libraries into R workflows.

MGF and MSP are common exchange formats but repeat compound annotations for
every spectrum. Loading them requires reading all data, which can be slow and
memory-heavy for large libraries.

For example, the memory usage for the GNPS drug library imported from the MGF
file is

```{r}
print(object.size(drug_ms2), unit = "MB")
```

This file is manageable; the full GNPS library might exceed the available memory
of a standard computer.

In contrast, the memory size for the `Spectra` object of the *CompDb* annotation
database created from the GNPS2 drug library is only:

```{r}
print(object.size(sps_cdb), unit = "MB")
```

The `sps_cdb` `Spectra` object keeps only spectrum IDs in memory and fetches
other data on demand, keeping memory low.

Another advantage of *CompDb* resources over MGF/MSP-based file formats is the
possibility to assign *metadata* to the resource:

```{r}
metadata(cdb)
```

However, creating a *CompDb* requires an upfront cleanup and conversion to store
data in SQLite. Once built, the resource is self-contained and shareable.

The *CompDb* format also supports adding new compounds or spectra, enabling
extension of in-house libraries (see the *CompoundDb* vignette mentioned above).

Currently the format is only supported directly in R, though any SQLite client
can read the database.

```{r, echo = FALSE, message = FALSE}
#' clean up
unlink(db_file)
```

# Summary

Importing public reference libraries is straightforward. The challenge is
harmonizing metadata and annotations across sources. Interpretation benefits
from cleaned, standardized information. Efforts such as
[@de_jonge_reproducible_2024] help, but broader standardization of data and
naming conventions is still needed.

# Outlook

- Support for the newly defined *mzSpecLib* file format will be added to the
  *RforMassSpectrometry* package ecosystem.
- Access to public libraries will be simplified, e.g. by making them available
  through *AnnotationHub*.

# Session information

```{r}
sessionInfo()
```

# References
