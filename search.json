[{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/SpectriPy-tutorial-metabonaut.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"LC-MS/MS Data Annotation using R and Python","text":"SpectriPy R package enables powerful mass spectrometry (MS) data analysis workflows combining strengths Python R MS libraries (Graeve et al. 2025). General concepts examples package available package’s main vignette. example combined R/Python workflow, annotate LC-MS/MS spectra main end--end vignette using Python’s matchms library. MS2 processing methods demonstrated used spectral reference library consists default filtering functionality matchms (Huber et al. 2020) (default_filters(), add_parent_mass() normalize_intensities()). MS2 spectral similarity algorithm demonstrated ModifiedCosine() matchms (Huber et al. 2020). spectral reference library used annotation unknown features tutorial originates small -house reference library (provided MGF format) available SpectriPy package. analysis document performed using R Python code chunks. comment #’ R session: #’ Python session: used easier distinction .","code":""},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/SpectriPy-tutorial-metabonaut.html","id":"load-spectripy","dir":"Articles","previous_headings":"","what":"Load SpectriPy","title":"LC-MS/MS Data Annotation using R and Python","text":"Load required R SpectriPy package. already Python environment opened, please restart Integrated Development Environment run first command, load required package reticulate setup conda environment ‘r-spectripy’ correctly. Please see Detailed information installation configuration document options.","code":"#' R session:  library(SpectriPy)"},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/SpectriPy-tutorial-metabonaut.html","id":"load-query-ms2-data","dir":"Articles","previous_headings":"","what":"Load query MS2 data","title":"LC-MS/MS Data Annotation using R and Python","text":"LC-MS/MS query data used tutorial, derived Metabonaut resource (Louail Rainer 2025). Introduction thorough description preprocessing steps performed described Complete End--End Workflow untargeted LC-MS/MS Metabolomics Data Analysis R. First, load Spectra object MS2 spectra unknown features found significant “Differential abundance analysis”, see section MS2-based annotation. Spectra object shared part Metabonaut package.","code":"#' R session:  #' R MS package library(Spectra)  #' Load the MS2 spectra of significant features load(system.file(\"extdata\", \"spectra_significant_fts.RData\",                  package = \"Metabonaut\")) ms2_ctr_fts MSn data (Spectra) with 315 spectra in a MsBackendMemory backend:       msLevel     rtime scanIndex     <integer> <numeric> <integer> 1           2   147.357      2043 2           2   148.587      2061 3           2   149.817      2079 4           2   152.297      2115 5           2   147.376      2041 ...       ...       ...       ... 311         2   178.082      2481 312         2   179.322      2499 313         2   180.572      2517 314         2   181.822      2535 315         2   183.072      2553  ... 39 more variables/columns. Processing:  Filter: select retention time [10..240] on MS level(s) 1 2 [Tue Mar 18 11:56:42 2025]  Filter: select MS level(s) 2 [Tue Mar 18 11:56:50 2025]  Remove peaks based on their intensities and a user-provided function in spectra of MS level(s) 2. [Tue Mar 18 11:56:50 2025]  ...19 more processings. Use 'processingLog' to list all. #' Print the available metadata, stored in the Spectra object spectraVariables(ms2_ctr_fts) [1] \"msLevel\"                    \"rtime\"  [3] \"acquisitionNum\"             \"scanIndex\"  [5] \"dataStorage\"                \"dataOrigin\"  [7] \"centroided\"                 \"smoothed\"  [9] \"polarity\"                   \"precScanNum\" [11] \"precursorMz\"                \"precursorIntensity\" [13] \"precursorCharge\"            \"collisionEnergy\" [15] \"isolationWindowLowerMz\"     \"isolationWindowTargetMz\" [17] \"isolationWindowUpperMz\"     \"peaksCount\" [19] \"totIonCurrent\"              \"basePeakMZ\" [21] \"basePeakIntensity\"          \"ionisationEnergy\" [23] \"lowMZ\"                      \"highMZ\" [25] \"mergedScan\"                 \"mergedResultScanNum\" [27] \"mergedResultStartScanNum\"   \"mergedResultEndScanNum\" [29] \"injectionTime\"              \"filterString\" [31] \"spectrumId\"                 \"ionMobilityDriftTime\" [33] \"scanWindowLowerLimit\"       \"scanWindowUpperLimit\" [35] \"electronBeamEnergy\"         \"mtbls_id\" [37] \"mtbls_assay_name\"           \"derived_spectral_data_file\" [39] \"collision_energy\"           \"feature_id\" #' Print the feature_id of the first spectrum ms2_ctr_fts$feature_id[1] [1] \"FT0371\""},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/SpectriPy-tutorial-metabonaut.html","id":"filter-query-data","dir":"Articles","previous_headings":"","what":"Filter query data","title":"LC-MS/MS Data Annotation using R and Python","text":"ensure Spectra object contains MS2 data, filter MS2 spectra 2 fragment peaks per spectrum using classical filtering functions Spectra package.","code":"#' R session:  #' Filter MS2 level data ms2_ctr_fts <- filterMsLevel(ms2_ctr_fts, 2L)  #' filter minimum 3 fragment peaks ms2_ctr_fts <- ms2_ctr_fts[lengths(ms2_ctr_fts) >= 3] ms2_ctr_fts MSn data (Spectra) with 291 spectra in a MsBackendMemory backend:       msLevel     rtime scanIndex     <integer> <numeric> <integer> 1           2   147.357      2043 2           2   148.587      2061 3           2   152.297      2115 4           2   147.376      2041 5           2   148.616      2059 ...       ...       ...       ... 287         2   178.082      2481 288         2   179.322      2499 289         2   180.572      2517 290         2   181.822      2535 291         2   183.072      2553  ... 39 more variables/columns. Processing:  Filter: select retention time [10..240] on MS level(s) 1 2 [Tue Mar 18 11:56:42 2025]  Filter: select MS level(s) 2 [Tue Mar 18 11:56:50 2025]  Remove peaks based on their intensities and a user-provided function in spectra of MS level(s) 2. [Tue Mar 18 11:56:50 2025]  ...20 more processings. Use 'processingLog' to list all."},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/SpectriPy-tutorial-metabonaut.html","id":"load-reference-ms2-data","dir":"Articles","previous_headings":"","what":"Load reference MS2 data","title":"LC-MS/MS Data Annotation using R and Python","text":"-house spectral library, import small test data file MGF format. file part SpectriPy package define path local computer. loading file performed using Python matchms library. variable MGF file name can accessed associated Python session using r.mgf_file. loaded object Python list matchms.Spectrum objects. Note can also access first spectrum R session, starting command py$.","code":"#' R session:  #' Define a variable with the path and file name of the MGF file mgf_file <- system.file(\"extdata\", \"mgf\", \"test.mgf\", package = \"SpectriPy\") #' Python session:  from matchms.importing import load_from_mgf  #' Read spectra from an MGF formatted file, as Spectrum object mgf_py = list(load_from_mgf(r.mgf_file))  #' Nr of spectra len(mgf_py) 100 #' Access the first spectrum mgf_py[0] Spectrum(precursor m/z=259.06, 3 fragments between 213.1 and 259.1) #' R session:  #' Access the first spectrum py$mgf_py[[1]] Spectrum(precursor m/z=259.06, 3 fragments between 213.1 and 259.1)"},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/SpectriPy-tutorial-metabonaut.html","id":"translate-query-ms-data-to-python","dir":"Articles","previous_headings":"","what":"Translate query MS data to Python","title":"LC-MS/MS Data Annotation using R and Python","text":"First, check R Spectra object containing query MS2 data can accessed Python using r. prefix. Second, translate Spectra object ms2_ctr_fts respective Python matchms.Spectrum objects using rspec_to_pyspec() function. py_set_attr() function assign variable directly attribute Python session (avoids repeated cross-programming language references). can now access converted Spectra object Python.","code":"#' Python session:  #' check if the r Spectra object can be accessed in python using the 'r.' #' prefix. Print the first spectrum r.ms2_ctr_fts[1] Spectrum(precursor m/z=138.05, 4 fragments between 73.1 and 92.1) #' Show which metadata is available in the first spectrum r.ms2_ctr_fts[0].metadata.keys() dict_keys(['precursor_mz', 'precursor_intensity', 'charge', 'retention_time', 'collision_energy', 'isolation_window_target_mz', 'ms_level']) #' R session:  #' Add mapping for additional spectra variables to the default mapping in R and #' python, respectively map = c(defaultSpectraVariableMapping(),         feature_id = 'feature_id')  #' Convert to py Spectrum py_set_attr(py, \"ms2_ctr_fts_py\", rspec_to_pyspec(ms2_ctr_fts, mapping = map)) #' Python session:  #' Access the first converted spectrum ms2_ctr_fts_py[0] Spectrum(precursor m/z=138.05, 4 fragments between 73.1 and 92.1)"},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/SpectriPy-tutorial-metabonaut.html","id":"filter-the-reference-library","dir":"Articles","previous_headings":"","what":"Filter the reference library","title":"LC-MS/MS Data Annotation using R and Python","text":"run spectral comparisons query data MGF reference library, first apply MS2 processing matchms. Default filtering matchms performed standardize ion mode, correct charge . See matchms filtering documentation. Also, keep reference spectra precursor m/z similarity algorithm use later requires spectra precursor m/z.","code":"#' Python session:  from matchms.filtering import default_filters, normalize_intensities, add_parent_mass  #' Apply filters to clean and enhance each spectrum clean_mgf_py = [] for spectrum in mgf_py:     #' Apply default filter to standardize ion mode, correct charge and more.     #' Default filter is fully explained at     #' https://matchms.readthedocs.io/en/latest/api/matchms.filtering.html     spectrum = default_filters(spectrum)     #' For missing precursor_mz field: check if there is “pepmass”” entry instead     spectrum = add_parent_mass(spectrum)     #' Scale peak intensities to maximum of 1     spectrum = normalize_intensities(spectrum)     #' Only add spectra that have a precursor m/z     if \"precursor_mz\" in spectrum.metadata:         clean_mgf_py.append(spectrum)  #' Nr of spectra len(clean_mgf_py) 78"},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/SpectriPy-tutorial-metabonaut.html","id":"calculating-spectra-similarities-using-the-modified-cosine-algorithm-from-matchms","dir":"Articles","previous_headings":"","what":"Calculating spectra similarities using the Modified Cosine algorithm from matchms","title":"LC-MS/MS Data Annotation using R and Python","text":"calculate pairwise spectral similarity query spectra reference library spectra using Python’s matchms library. , use spectral similarity algorithm ModifiedCosine matchms, source matchms. algorithm can easily exchanged another spectral similarity calculation matchms (see ). next rearrange spectra similarity results make data frame containing best matched compound name (derived reference library) per queried spectrum. First, extract transpose scores python array. row array contain similarity scores one spectrum query spectra ms2_ctr_fts_py cleaned reference library clean_mgf_py. Next, create data frame per queried spectrum unknown variables, compound name higest matching spectra reference library corresponding similarity score. [!] Caution: higest score taken criteria annotation, lot caution needed evaluation trueness match. low score reliable, similarity algorithm calculate score pair spectra. Therefore, match always found. addition, unknown compound absent reference library, match wrongly another compound present database. filter results retaining matches similarity value 0.6. value, potential annotations need validated using e.g. rerunning samples presence commercial standards. visually inspect good query reference spectra match, refer Metabonaut resource generate mirror plots perform precursor m/z filtering (e.g. maximum 1 Da difference).","code":"#' Python session:  from matchms import calculate_scores from matchms.similarity import ModifiedCosine  #' Calculate Cosine similarity scores between all spectra #' For other similarity score methods see #' https://matchms.readthedocs.io/en/latest/api/matchms.similarity.html similarity_score = ModifiedCosine(tolerance = 0.1) scores = calculate_scores(references = clean_mgf_py,                           queries = ms2_ctr_fts_py,                           similarity_function = similarity_score) Calculating similarities:   0%|          | 0/78 [00:00<?, ?it/s] Calculating similarities:   1%|1         | 1/78 [00:01<02:11,  1.70s/it] Calculating similarities:  10%|#         | 8/78 [00:01<00:11,  5.91it/s] Calculating similarities:  19%|#9        | 15/78 [00:01<00:05, 12.10it/s] Calculating similarities:  28%|##8       | 22/78 [00:02<00:02, 19.05it/s] Calculating similarities:  38%|###8      | 30/78 [00:02<00:01, 27.60it/s] Calculating similarities:  47%|####7     | 37/78 [00:02<00:01, 34.20it/s] Calculating similarities:  56%|#####6    | 44/78 [00:02<00:01, 33.45it/s] Calculating similarities:  64%|######4   | 50/78 [00:02<00:00, 37.48it/s] Calculating similarities:  73%|#######3  | 57/78 [00:02<00:00, 43.48it/s] Calculating similarities:  82%|########2 | 64/78 [00:02<00:00, 48.62it/s] Calculating similarities:  91%|#########1| 71/78 [00:02<00:00, 53.64it/s] Calculating similarities: 100%|##########| 78/78 [00:03<00:00, 56.73it/s] Calculating similarities: 100%|##########| 78/78 [00:03<00:00, 25.93it/s] scores <78x291x2 stacked sparse array containing scores for ('ModifiedCosine_score', 'ModifiedCosine_matches') with 12376 stored elements in COOrdinate format> #' Python session:  #' Convert to array and transpose sim_matchms = scores.to_array()[\"ModifiedCosine_score\"] sim_matchms = sim_matchms.T  #' Contains 1 row for each spectrum in query sim_matchms.shape (291, 78) #' Python session:  import numpy as np import pandas as pd  #' Prepare results list results = [] for i in range(sim_matchms.shape[0]):     #' row is the query, keep nr in the results instead of replacing by eg id     name_row = ms2_ctr_fts_py[i].get('feature_id')     row_values = sim_matchms[i].copy()     #' match with higest col nr from the references     max_col = np.argmax(row_values)  #' Find column index of max value     max_value = row_values[max_col]  #' Get max value     #' replace the nr of refererences with the name     name_max_col = clean_mgf_py[max_col].get('compound_name')     results.append({\"query\": i + 1,                     \"query_feature_id\": name_row,                     \"reference\": max_col,                     \"reference_compound_name\": name_max_col,                     \"ModifiedCosine_score\": max_value})   #' Convert to DataFrame df = pd.DataFrame(results)  #' Print the first 5 rows of the unfiltered DataFrame df.head() query query_feature_id  ...  reference_compound_name ModifiedCosine_score 0      1           FT0371  ...         Benzyl succinate             0.554071 1      2           FT0371  ...         Benzyl succinate             0.557885 2      3           FT0371  ...      L-(+)-Ergothioneine             0.103269 3      4           FT0371  ...         Benzyl succinate             0.464949 4      5           FT0371  ...         Benzyl succinate             0.508411  [5 rows x 5 columns] #' Python session:  #' Keep only rows where score >= 0.6 df_filtered = df[df[\"ModifiedCosine_score\"] >= 0.6] #' R session:  library(pander) #' Print the filtered DataFrame pandoc.table(py$df_filtered, style = \"rmarkdown\", split.table = Inf)"},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/SpectriPy-tutorial-metabonaut.html","id":"session-information","dir":"Articles","previous_headings":"","what":"Session information","title":"LC-MS/MS Data Annotation using R and Python","text":"","code":"#' R session:  sessionInfo() R version 4.5.1 (2025-06-13) Platform: x86_64-pc-linux-gnu Running under: Ubuntu 24.04.2 LTS  Matrix products: default BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3 LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.26.so;  LAPACK version 3.12.0  locale:  [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C  [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8  [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8  [7] LC_PAPER=en_US.UTF-8       LC_NAME=C  [9] LC_ADDRESS=C               LC_TELEPHONE=C [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C  time zone: Etc/UTC tzcode source: system (glibc)  attached base packages: [1] stats4    stats     graphics  grDevices utils     datasets  methods [8] base  other attached packages: [1] pander_0.6.6        Spectra_1.18.2      BiocParallel_1.42.1 [4] S4Vectors_0.46.0    BiocGenerics_0.54.0 generics_0.1.4 [7] SpectriPy_0.99.5    reticulate_1.42.0  loaded via a namespace (and not attached):  [1] cli_3.6.5              knitr_1.50             rlang_1.1.6  [4] xfun_0.52              ProtGenerics_1.40.0    png_0.1-8  [7] jsonlite_2.0.0         clue_0.3-66            htmltools_0.5.8.1 [10] rmarkdown_2.29         grid_4.5.1             evaluate_1.0.4 [13] MASS_7.3-65            fastmap_1.2.0          yaml_2.3.10 [16] IRanges_2.42.0         MsCoreUtils_1.20.0     cluster_2.1.8.1 [19] compiler_4.5.1         codetools_0.2-20       fs_1.6.6 [22] Rcpp_1.1.0             MetaboCoreUtils_1.16.1 lattice_0.22-7 [25] digest_0.6.37          parallel_4.5.1         Matrix_1.7-3 [28] tools_4.5.1"},{"path":[]},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/a-end-to-end-untargeted-metabolomics.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Complete end-to-end LC-MS/MS Metabolomic Data analysis","text":"present workflow describes steps analysis LC-MS/MS experiment, includes preprocessing raw data generate abundance matrix features various samples, followed data normalization, differential abundance analysis finally annotation features metabolites. Note also alternative analysis options R packages used different steps examples mentioned throughout workflow.  Figure 1. Steps end--end workflow possible alternatives","code":""},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/a-end-to-end-untargeted-metabolomics.html","id":"data-description","dir":"Articles","previous_headings":"","what":"Data description","title":"Complete end-to-end LC-MS/MS Metabolomic Data analysis","text":"See data description vignette detailed explanation dataset go workflow general tips done first get data.","code":""},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/a-end-to-end-untargeted-metabolomics.html","id":"packages-needed","dir":"Articles","previous_headings":"","what":"Packages needed","title":"Complete end-to-end LC-MS/MS Metabolomic Data analysis","text":"workflow therefore based following dependencies:","code":"## Data Import and handling library(knitr) library(readxl) library(MsExperiment) library(MsIO) library(alabaster.se) library(MsBackendMetaboLights) library(SummarizedExperiment)  ## Preprocessing of LC-MS data library(xcms) library(Spectra) library(MetaboCoreUtils)  ## Statistical analysis library(limma) # Differential abundance library(matrixStats) # Summaries over matrices  ## Visualisation library(pander) library(RColorBrewer) library(pheatmap) library(vioplot) library(ggfortify)   # Plot PCA library(gridExtra)   # To arrange multiple ggplots into single plots  ## Annotation library(AnnotationHub) # Annotation resources library(CompoundDb)    # Access small compound annotation data. library(MetaboAnnotation) # Functionality for metabolite annotation."},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/a-end-to-end-untargeted-metabolomics.html","id":"data-import","dir":"Articles","previous_headings":"","what":"Data import","title":"Complete end-to-end LC-MS/MS Metabolomic Data analysis","text":"Note different equipment generate various file extensions, conversion step might needed beforehand, though apply dataset. Spectra package supports variety ways store retrieve MS data, including mzML, mzXML, CDF files, simple flat files, database systems. necessary, several tools, ProteoWizard’s MSConvert, can used convert files .mzML format (Chambers et al. 2012). show extract dataset MetaboLigths database load MsExperiment object. information load data MetaboLights database, refer vignette. type data loading, check xcms vignette specific vignette created data import soon. next configure parallel processing setup. functions xcms package allow per-sample parallel processing, can improve performance analysis, especially large data sets. xcms packages RforMassSpectrometry package ecosystem use parallel processing setup configured BiocParallel Bioconductor package. code use fork-based parallel processing unix system, socket-based parallel processing Windows operating system.","code":"param <- MetaboLightsParam(mtblsId = \"MTBLS8735\",                            assayName = paste0(\"a_MTBLS8735_LC-MS_positive_\",                                               \"hilic_metabolite_profiling.txt\"),                            filePattern = \".mzML\")  lcms1 <- readMsObject(MsExperiment(),                       param,                       keepOntology = FALSE,                       keepProtocol = FALSE,                       simplify = TRUE) #' Set up parallel processing using 2 cores if (.Platform$OS.type == \"unix\") {     register(MulticoreParam(2)) } else {     register(SnowParam(2)) }"},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/a-end-to-end-untargeted-metabolomics.html","id":"data-organisation","dir":"Articles","previous_headings":"","what":"Data organisation","title":"Complete end-to-end LC-MS/MS Metabolomic Data analysis","text":"experimental data now represented MsExperiment object MsExperiment package. MsExperiment object container metadata spectral data provides manages also linkage samples spectra. provide brief overview data structure content. sampleData() function extracts sample information object. next extract data use pander package render show information Table 1 . Throughout document use R pipe operator (|>) avoid nested function calls hence improve code readability. sampleData() output MetaboLights always ideal direct easy access data. therefore rename transform user-friendly way. user can add, transform remove column want using base R functionalities. Table 1. Samples data set. Table 2. Simplified sample data. 10 samples data set. abbreviations essential proper interpretation metadata information: \"QC\": Quality control sample (pool serum samples external, large cohort). \"CVD\": Sample individual cardiovascular disease. \"CTR\": Sample presumably healthy control. sample_name: arbitrary name/identifier sample. age: (rounded) age individuals. injection_index: index representing order (position) individual sample measured (injected) within LC-MS measurement run experiment. define colors sample groups based sample group using RColorBrewer package: MS data experiment stored Spectra object (Spectra Bioconductor package) within MsExperiment object can accessed using spectra() function. element object spectrum - organised linearly combined Spectra object one (ordered retention time samples). access dataset’s Spectra object summarize available information provide, among things, total number spectra data set.","code":"lcms1 Object of class MsExperiment  Spectra: MS1 (17210)  Experiment data: 10 sample(s)  Sample data links:   - spectra: 10 sample(s) to 17210 element(s). sampleData(lcms1)[, c(\"Derived_Spectral_Data_File\",                       \"Characteristics[Sample type]\",                       \"Factor Value[Phenotype]\",                       \"Sample Name\",                       \"Factor Value[Age]\")] |>     kable(format = \"pipe\") # Let's rename the column for easier access colnames(sampleData(lcms1)) <- c(\"sample_name\", \"derived_spectra_data_file\",                                 \"metabolite_asssignment_file\",                                 \"source_name\",                                 \"organism\",                                 \"blood_sample_type\",                                 \"sample_type\", \"age\", \"unit\", \"phenotype\")  # Add \"QC\" to the phenotype of the QC samples sampleData(lcms1)$phenotype[sampleData(lcms1)$sample_name == \"POOL\"] <- \"QC\" sampleData(lcms1)$sample_name[sampleData(lcms1)$sample_name == \"POOL\" ] <- c(\"POOL1\", \"POOL2\", \"POOL3\", \"POOL4\")  #  Add injection index column sampleData(lcms1)$injection_index <- seq_len(nrow(sampleData(lcms1)))  #let's look at the updated sample data sampleData(lcms1)[, c(\"derived_spectra_data_file\",                      \"phenotype\", \"sample_name\", \"age\",                      \"injection_index\")] |>     kable(format = \"pipe\") #' Define colors for the different phenotypes col_phenotype <- brewer.pal(9, name = \"Set1\")[c(9, 5, 4)] names(col_phenotype) <- c(\"QC\", # grey                           \"CVD\", # orange                           \"CTR\") # purple col_sample <- col_phenotype[sampleData(lcms1)$phenotype] #' Access Spectra Object spectra(lcms1) MSn data (Spectra) with 17210 spectra in a MsBackendMetaboLights backend:         msLevel     rtime scanIndex       <integer> <numeric> <integer> 1             1     0.274         1 2             1     0.553         2 3             1     0.832         3 4             1     1.111         4 5             1     1.390         5 ...         ...       ...       ... 17206         1   479.052      1717 17207         1   479.331      1718 17208         1   479.610      1719 17209         1   479.889      1720 17210         1   480.168      1721  ... 37 more variables/columns.  file(s): MS_QC_POOL_1_POS.mzML MS_A_POS.mzML MS_B_POS.mzML  ... 7 more files"},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/a-end-to-end-untargeted-metabolomics.html","id":"data-visualization-and-general-quality-assessment","dir":"Articles","previous_headings":"","what":"Data visualization and general quality assessment","title":"Complete end-to-end LC-MS/MS Metabolomic Data analysis","text":"Effective visualization paramount inspecting assessing quality MS data. general overview LC-MS data, can: Combine mass peaks (MS1) spectra sample single spectrum mass peak represents maximum signal mass peaks similar m/z. spectrum might called Base Peak Spectrum (BPS), providing information abundant ions sample. Aggregate mass peak intensities spectrum, resulting Base Peak Chromatogram (BPC). BPC shows highest measured intensity distinct retention time (hence spectrum) thus orthogonal BPS. Sum mass peak intensities spectrum create Total Ion Chromatogram (TIC). Compare BPS samples experiment evaluate similarity ion content. Compare BPC samples experiment identify samples similar dissimilar chromatographic signal. addition general data evaluation visualization, also crucial investigate specific signal e.g. internal standards compounds/ions known present samples. providing reliable reference, internal standards help achieve consistent accurate analytical results. LC signal variable unstable nature LC, evaluate . depth inspection discussion spectra chromatrograhic data can found data exploration vignette. chromatogram() function facilitates extraction intensities along retention time. However, access chromatographic information currently efficient seamless spectral information. Work underway develop/improve infrastructure chromatographic data new Chromatograms object aimed flexible user-friendly Spectra object. visualizing LC-MS data, BPC TIC serves valuable tool assess performance liquid chromatography across various samples experiment. case, extract BPC data create plot. BPC captures maximum peak signal spectrum data file plots information retention time spectrum y-axis. BPC can extracted using chromatogram function. setting parameter aggregationFun = \"max\", instruct function report maximum signal per spectrum. Conversely, setting aggregationFun = \"sum\", sums intensities spectrum, thereby creating TIC.  Figure 2. BPC samples colored phenotype. 240 seconds signal seems measured. Thus, filter data removing part well first 10 seconds measured LC run.  Figure 3. BPC filtering retention time. Initially, examined entire BPC subsequently filtered based desired retention times. results smaller file size also facilitates straightforward interpretation BPC. final plot illustrates BPC sample colored phenotype, providing insights signal measured along retention times sample. reveals points compounds eluted LC column. essence, BPC condenses three-dimensional LC-MS data (m/z retention time intensity) two dimensions (retention time intensity). can also compare similarities TICs heatmap. retention times however identical different samples. Thus bin() chromatographic signal per sample along retention time axis bins two seconds resulting data number bins/data points. can calculate pairwise similarities data vectors using cor() function visualize result using pheatmap().  Figure 4. Heatmap TIC similarities. heatmap reinforces exploration spectra data showed, strong separation QC study samples. important bear mind later analyses. Throughout entire process, crucial reference points within dataset, well-known ions. experiments nowadays include internal standards (), case . strongly recommend using visualization throughout entire analysis. experiment, set 15 spiked samples. reviewing respective chromatoraphic peaks, selected two guide analysis process. However, advise plot evaluate ions steps. illustrate , generate Extracted Ion Chromatograms (EIC) selected test ions. restricting MS data intensities within restricted, m/z range selected retention time window, EICs expected contain signal single type ion. expected m/z retention times set determined different experiment. Additionally, cases internal standards available, commonly present ions sample matrix can serve suitable alternatives. Ideally, compounds distributed across entire retention time range experiment. Table 3. Internal standard list respective m/z expected retention time [s]. plot EICs isotope labeled cystine methionine.  Figure 5. EIC cystine methionine. can observe clear concentration difference QCs study samples isotope labeled cystine ion. Meanwhile, labeled methionine internal standard exhibits discernible signal amidst noise noticeable retention time shift samples.","code":"#' Extract and plot BPC for full data bpc <- chromatogram(lcms1, aggregationFun = \"max\")  plot(bpc, col = paste0(col_sample, 80), main = \"BPC\", lwd = 1.5) grid() legend(\"topright\", col = col_phenotype,        legend = names(col_phenotype), lty = 1, lwd = 2, horiz = TRUE,        bty = \"n\") #' Filter the data based on retention time lcms1 <- filterRt(lcms1, c(10, 240)) Filter spectra bpc <- chromatogram(lcms1, aggregationFun = \"max\") #' Plot after filtering plot(bpc, col = paste0(col_sample, 80),      main = \"BPC after filtering retention time\", lwd = 1.5) grid() legend(\"topright\", col = col_phenotype,        legend = names(col_phenotype), lty = 1, lwd = 2, horiz = TRUE, bty = \"n\") #' Total ion chromatogram tic <- chromatogram(lcms1, aggregationFun = \"sum\") |>   bin(binSize = 2)  #' Calculate similarity (Pearson correlation) between BPCs ticmap <- do.call(cbind, lapply(tic, intensity)) |>   cor()  rownames(ticmap) <- colnames(ticmap) <- sampleData(lcms1)$sample_name ann <- data.frame(phenotype = sampleData(lcms1)[, \"phenotype\"]) rownames(ann) <- rownames(ticmap)  #' Plot heatmap pheatmap(ticmap, annotation_col = ann,          annotation_colors = list(phenotype = col_phenotype)) #' Load our list of standard intern_standard <- read.delim(\"intern_standard_list.txt\")  # Extract EICs for the list eic_is <- chromatogram(     lcms1,     rt = as.matrix(intern_standard[, c(\"rtmin\", \"rtmax\")]),     mz = as.matrix(intern_standard[, c(\"mzmin\", \"mzmax\")]))  #' Add internal standard metadata fData(eic_is)$mz <- intern_standard$mz fData(eic_is)$rt <- intern_standard$RT fData(eic_is)$name <- intern_standard$name fData(eic_is)$abbreviation <- intern_standard$abbreviation rownames(fData(eic_is)) <- intern_standard$abbreviation  fdata <- fData(eic_is)  #' Summary of IS information fData(eic_is)[c(\"cystine_13C_15N\", \"methionine_13C_15N\"),                c(\"name\", \"mz\", \"rt\")] |>     kable(format = \"pipe\") #' Extract the two IS from the chromatogram object. eic_cystine <- eic_is[\"cystine_13C_15N\"] eic_met <- eic_is[\"methionine_13C_15N\"]  #' plot both EIC par(mfrow = c(1, 2), mar = c(4, 2, 2, 0.5)) plot(eic_cystine, main = fData(eic_cystine)$name, cex.axis = 0.8,      cex.main = 0.8,      col = paste0(col_sample, 80)) grid() abline(v = fData(eic_cystine)$rt, col = \"red\", lty = 3)  plot(eic_met, main = fData(eic_met)$name, cex.axis = 0.8, cex.main = 0.8,      col = paste0(col_sample, 80)) grid() abline(v = fData(eic_met)$rt, col = \"red\", lty = 3) legend(\"topright\", col = col_phenotype, legend = names(col_phenotype), lty = 1,        bty = \"n\")"},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/a-end-to-end-untargeted-metabolomics.html","id":"chromatographic-data-visualization-bpc-and-tic","dir":"Articles","previous_headings":"","what":"Chromatographic Data Visualization: BPC and TIC","title":"Complete end-to-end LC-MS/MS Metabolomic Data analysis","text":"chromatogram() function facilitates extraction intensities along retention time. However, access chromatographic information currently efficient seamless spectral information. Work underway develop/improve infrastructure chromatographic data new Chromatograms object aimed flexible user-friendly Spectra object. visualizing LC-MS data, BPC TIC serves valuable tool assess performance liquid chromatography across various samples experiment. case, extract BPC data create plot. BPC captures maximum peak signal spectrum data file plots information retention time spectrum y-axis. BPC can extracted using chromatogram function. setting parameter aggregationFun = \"max\", instruct function report maximum signal per spectrum. Conversely, setting aggregationFun = \"sum\", sums intensities spectrum, thereby creating TIC.  Figure 2. BPC samples colored phenotype. 240 seconds signal seems measured. Thus, filter data removing part well first 10 seconds measured LC run.  Figure 3. BPC filtering retention time. Initially, examined entire BPC subsequently filtered based desired retention times. results smaller file size also facilitates straightforward interpretation BPC. final plot illustrates BPC sample colored phenotype, providing insights signal measured along retention times sample. reveals points compounds eluted LC column. essence, BPC condenses three-dimensional LC-MS data (m/z retention time intensity) two dimensions (retention time intensity). can also compare similarities TICs heatmap. retention times however identical different samples. Thus bin() chromatographic signal per sample along retention time axis bins two seconds resulting data number bins/data points. can calculate pairwise similarities data vectors using cor() function visualize result using pheatmap().  Figure 4. Heatmap TIC similarities. heatmap reinforces exploration spectra data showed, strong separation QC study samples. important bear mind later analyses.","code":"#' Extract and plot BPC for full data bpc <- chromatogram(lcms1, aggregationFun = \"max\")  plot(bpc, col = paste0(col_sample, 80), main = \"BPC\", lwd = 1.5) grid() legend(\"topright\", col = col_phenotype,        legend = names(col_phenotype), lty = 1, lwd = 2, horiz = TRUE,        bty = \"n\") #' Filter the data based on retention time lcms1 <- filterRt(lcms1, c(10, 240)) Filter spectra bpc <- chromatogram(lcms1, aggregationFun = \"max\") #' Plot after filtering plot(bpc, col = paste0(col_sample, 80),      main = \"BPC after filtering retention time\", lwd = 1.5) grid() legend(\"topright\", col = col_phenotype,        legend = names(col_phenotype), lty = 1, lwd = 2, horiz = TRUE, bty = \"n\") #' Total ion chromatogram tic <- chromatogram(lcms1, aggregationFun = \"sum\") |>   bin(binSize = 2)  #' Calculate similarity (Pearson correlation) between BPCs ticmap <- do.call(cbind, lapply(tic, intensity)) |>   cor()  rownames(ticmap) <- colnames(ticmap) <- sampleData(lcms1)$sample_name ann <- data.frame(phenotype = sampleData(lcms1)[, \"phenotype\"]) rownames(ann) <- rownames(ticmap)  #' Plot heatmap pheatmap(ticmap, annotation_col = ann,          annotation_colors = list(phenotype = col_phenotype))"},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/a-end-to-end-untargeted-metabolomics.html","id":"chromatographic-data-visualization-eics","dir":"Articles","previous_headings":"","what":"Chromatographic Data Visualization: EICs","title":"Complete end-to-end LC-MS/MS Metabolomic Data analysis","text":"Throughout entire process, crucial reference points within dataset, well-known ions. experiments nowadays include internal standards (), case . strongly recommend using visualization throughout entire analysis. experiment, set 15 spiked samples. reviewing respective chromatoraphic peaks, selected two guide analysis process. However, advise plot evaluate ions steps. illustrate , generate Extracted Ion Chromatograms (EIC) selected test ions. restricting MS data intensities within restricted, m/z range selected retention time window, EICs expected contain signal single type ion. expected m/z retention times set determined different experiment. Additionally, cases internal standards available, commonly present ions sample matrix can serve suitable alternatives. Ideally, compounds distributed across entire retention time range experiment. Table 3. Internal standard list respective m/z expected retention time [s]. plot EICs isotope labeled cystine methionine.  Figure 5. EIC cystine methionine. can observe clear concentration difference QCs study samples isotope labeled cystine ion. Meanwhile, labeled methionine internal standard exhibits discernible signal amidst noise noticeable retention time shift samples.","code":"#' Load our list of standard intern_standard <- read.delim(\"intern_standard_list.txt\")  # Extract EICs for the list eic_is <- chromatogram(     lcms1,     rt = as.matrix(intern_standard[, c(\"rtmin\", \"rtmax\")]),     mz = as.matrix(intern_standard[, c(\"mzmin\", \"mzmax\")]))  #' Add internal standard metadata fData(eic_is)$mz <- intern_standard$mz fData(eic_is)$rt <- intern_standard$RT fData(eic_is)$name <- intern_standard$name fData(eic_is)$abbreviation <- intern_standard$abbreviation rownames(fData(eic_is)) <- intern_standard$abbreviation  fdata <- fData(eic_is)  #' Summary of IS information fData(eic_is)[c(\"cystine_13C_15N\", \"methionine_13C_15N\"),                c(\"name\", \"mz\", \"rt\")] |>     kable(format = \"pipe\") #' Extract the two IS from the chromatogram object. eic_cystine <- eic_is[\"cystine_13C_15N\"] eic_met <- eic_is[\"methionine_13C_15N\"]  #' plot both EIC par(mfrow = c(1, 2), mar = c(4, 2, 2, 0.5)) plot(eic_cystine, main = fData(eic_cystine)$name, cex.axis = 0.8,      cex.main = 0.8,      col = paste0(col_sample, 80)) grid() abline(v = fData(eic_cystine)$rt, col = \"red\", lty = 3)  plot(eic_met, main = fData(eic_met)$name, cex.axis = 0.8, cex.main = 0.8,      col = paste0(col_sample, 80)) grid() abline(v = fData(eic_met)$rt, col = \"red\", lty = 3) legend(\"topright\", col = col_phenotype, legend = names(col_phenotype), lty = 1,        bty = \"n\")"},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/a-end-to-end-untargeted-metabolomics.html","id":"data-preprocessing","dir":"Articles","previous_headings":"","what":"Data preprocessing","title":"Complete end-to-end LC-MS/MS Metabolomic Data analysis","text":"Preprocessing stands inaugural step analysis untargeted LC-MS. characterized 3 main stages: chromatographic peak detection, retention time shift correction (alignment) correspondence results features defined. primary objective preprocessing quantification signals ions measured sample, addressing potential retention time drifts samples, ensuring alignment quantified signals across samples within experiment. final result LC-MS data preprocessing numeric matrix abundances quantified entities samples experiment. initial preprocessing step involves detecting intensity peaks along retention time axis, called chromatographic peaks. achieve , employ findChromPeaks() function within xcms. function supports various algorithms peak detection, can selected configured respective parameter objects. preferred algorithm case, CentWave, utilizes continuous wavelet transformation (CWT)-based peak detection (Tautenhahn, Böttcher, Neumann 2008). method known effectiveness handling non-Gaussian shaped chromatographic peaks peaks varying retention time widths, commonly encountered HILIC separations. apply CentWave algorithm default settings EICs cystine methionine ions evaluate results. CentWave highly performant algorithm, requires customized dataset. implies parameters fine-tuned based user’s data. example serves clear motivation users familiarize various parameters need adapt data set. discuss main parameters can easily adjusted suit user’s dataset: peakwidth: Specifies minimal maximal expected width peaks retention time dimension. Highly dependent chromatographic settings used. ppm: maximal allowed difference mass peaks’ m/z values (parts-per-million) consecutive scans consider representing signal ion. integrate: parameter defines integration method. , primarily use integrate = 2 integrates also signal chromatographic peak’s tail considered accurate developers. determine peakwidth, recommend users refer previous EICs estimate range peak widths observe dataset. Ideally, examining multiple EICs goal. dataset, peak widths appear around 2 10 seconds. advise choosing range wide narrow peakwidth parameter can lead false positives negatives. determine ppm, deeper analysis dataset needed. clarified ppm depends instrument, users necessarily input vendor-advertised ppm. ’s determine accurately possible: following steps involve generating highly restricted MS area single mass peak per spectrum, representing cystine ion. m/z peaks extracted, absolute difference calculated finally expressed ppm. therefore, choose value close maximum within range parameter ppm, .e., 15 ppm. can now perform chromatographic peak detection adapted settings EICs. important note , properly estimate background noise, sufficient data points outside chromatographic peak need present. generally problem peak detection performed full LC-MS data set, peak detection EICs retention time range EIC needs sufficiently wide. function fails find peak EIC, initial troubleshooting step increase range. Additionally, signal--noise threshold snthresh reduced peak detection EICs, within small retention time range, enough signal present properly estimate background noise. Finally, case MS1 data points per peaks, setting CentWave’s advanced parameter extendLengthMSW TRUE can help peak detection. customized parameters, chromatographic peak detected sample. , use plot() function EICs visualize results.  Figure 6. Chromatographic peak detection EICs. can see peak seems detected sample ions. indicates custom settings suitable dataset. now proceed apply entire dataset, extracting EICs ions evaluate confirm chromatographic peak detection worked expected. Note: revert value parameter snthresh default, , mentioned , background noise estimation reliable performed full data set. Parameter chunkSize findChromPeaks() defines number data files loaded memory processed simultaneously. parameter thus allows fine-tune memory demand well performance chromatographic peak detection step. correspond initial set parallel processing . plot EICs two selected internal standards evaluate chromatographic peak detection results.  Figure 7. Chromatographic peak detection EICs processing. Peaks seem detected properly samples ions. indicates peak detection process entire dataset successful. identification chromatographic peaks using CentWave algorithm can sometimes result artifacts, overlapping split peaks. address issue, refineChromPeaks() function utilized, conjunction MergeNeighboringPeaksParam, aims merging split peaks. show examples CentWave peak detection artifacts. examples pre-selected illustrate necessity next step:  Figure 8. Examples CentWave peak detection artifacts. cases signal presumably single type ion split two separate chromatographic peaks (indicated vertical line). MergeNeigboringPeaksParam allows combine split peaks. parameters algorithm defined : expandMz: Suggested kept relatively small (0.0015) prevent merging isotopes. expandRt: Usually set approximately half size average retention time width used chromatographic peak detection (case, 2.5 seconds). minProp: Used determine whether candidates merged. Chromatographic peaks overlapping m/z ranges (expanded side expandMz) tail--head distance retention time dimension less 2 * expandRt, signal higher minProp apex intensity chromatographic peak lower intensity, merged. Values parameter small avoid merging closely co-eluting ions, isomers. test settings EICs split peaks.  Figure 9. Examples CentWave peak detection artifacts merging. can observe artificially split peaks appropriately merged. Therefore, next apply settings entire dataset. peak merging, column \"merged\" result object’s chromPeakData() data frame can used evaluate chromatographic peaks result represent signal merged, originally identified chromatographic peaks. proceeding next preprocessing step generally suggested evaluate results chromatographic peak detection EICs e.g. internal standards compounds/ions known present samples. update EICs objects internal standards results chromatographic peak detection refinement. Additionally, evaluating comparing number identified chromatographic peaks samples data set can help spotting potentially problematic samples. count number chromatographic peaks per sample show numbers table. Table 4. Samples number identified chromatographic peaks. similar number chromatographic peaks identified within various samples data set. Additional options evaluate results chromatographic peak detection can implemented using plotChromPeaks() function summarizing results using base R commands. Despite using chromatographic settings conditions retention time shifts unavoidable. Indeed, performance instrument can change time, example due small variations environmental conditions, temperature pressure. shifts generally small samples measured within batch/measurement run, can considerable data experiment acquired across longer time period. evaluate presence shift extract plot BPC QC samples.  Figure 10. BPC QC samples. QC samples representing sample (pool) measured regular intervals measurement run experiment measured day. Still, small shifts can observed, especially region 100 150 seconds. facilitate proper correspondence signals across samples (hence definition LC-MS features), essential minimize differences retention times. Theoretically, proceed two steps: first select QC samples dataset first alignment , using -called anchor peaks. way can assume linear shift time, since always measuring sample different regular time intervals. Despite external QCs data set, still use subset-based alignment assuming retention time shifts independent different sample matrix (human serum plasma) instead mostly instrument-dependent. Note also possible manually specify anchor peaks, respectively retention times align data set external, reference, data set. information provided vignettes xcms package. calculating much adjust retention time samples, apply shift also study samples. xcms, retention time alignment can performed using adjustRtime() function alignment algorithm. example use PeakGroups method (Smith et al. 2006) performs alignment minimizing differences retention times set anchor peaks different samples. method requires initial correspondence analysis match/group chromatographic peaks across samples algorithm selects anchor peaks alignment. initial correspondence, use PeakDensity approach (Smith et al. 2006) groups chromatographic peaks similar m/z retention time LC-MS features. parameters algorithm, can configured using PeakDensityParam object, sampleGroups, minFraction, binSize, ppm bw. binSize, ppm bw allow specify similar chromatographic peaks’ m/z retention time values need consider grouping feature. binSize ppm define required similarity m/z values. Within m/z bin (defined binSize ppm) areas along retention time axis high chromatographic peak density (considering peaks samples) identified, chromatographic peaks within regions considered grouping feature. High density areas identified using base R density() function, bw parameter: higher values define wider retention time areas, lower values require chromatographic peaks similar retention times. parameter can seen black line plot , corresponding smoothness density curve. Whether candidate peaks get grouped feature depends also parameters sampleGroups minFraction: sampleGroups provide, sample, sample group belongs . minFraction expected value 0 1 defining proportion samples within least one sample groups (defined sampleGroups) chromatographic peaks detected group feature. initial correspondence, parameters don’t need fully optimized. Selection dataset-specific parameter values described detail next section. dataset, use small values binSize ppm , importantly, also parameter bw, since data set ultra high performance (UHP) LC setup used. minFraction use high value (0.9) ensure features defined chromatographic peaks present almost samples one sample group (can used anchor peaks actual alignment). base alignment later QC samples hence define sampleGroups binary variable grouping samples either study, QC group.  Figure 11. Initial correspondence analysis. PeakGroups-based alignment can next performed using adjustRtime() function PeakGroupsParam parameter object. parameters algorithm : subsetAdjust subset: Allows subset alignment. base retention time alignment QC samples, .e., retention time shifts estimated based repeatedly measured samples. resulting adjustment applied entire data. data sets QC samples (e.g. sample pools) measured repeatedly, strongly suggest use method. Note also subset-based alignment samples ordered injection index (.e., order measured measurement run). minFraction: value 0 1 defining proportion samples (full data set, data subset defined subset) chromatographic peak identified use anchor peak. contrast PeakDensityParam parameter used define proportion within sample group. span: PeakGroups method allows, depending data, adjust regions along retention time axis differently. enable local alignments LOESS function used parameter defines degree smoothing function. Generally, values 0.4 0.6 used, however, suggested evaluate alignment results eventually adapt parameters result satisfactory. perform alignment data set based retention times anchor peaks defined subset QC samples. Alignment adjusted retention times spectra data set, well retention times identified chromatographic peaks. alignment performed, user evaluate results using plotAdjustedRtime() function. function visualizes difference adjusted raw retention time sample y-axis along adjusted retention time x-axis. Dot points represent position used anchor peak along retention time axis. optimal alignment areas along retention time axis, anchor peaks scattered retention time dimension.  Figure 12. Retention time alignment results. samples present data set measured within measurement run, resulting small retention time shifts. Therefore, little adjustments needed performed (shifts maximum 1 second can seen plot ). Generally, magnitude adjustment seen plots match expectation analyst. can also compare BPC alignment. get original data, .e. raw retention times, can use dropAdjustedRtime() function:  Figure 13. BPC alignment. largest shift can observed retention time range 120 130s. Apart retention time range, little changes can observed. next evaluate impact alignment EICs selected internal standards. thus first extract ion chromatograms alignment, subsequently plot .  Figure 14. EICs cystine methionine alignment. non-endogenous cystine ion already well aligned difference minimal. methionine ion, however, shows slight improvement alignment. addition visual inspection results, also evaluate impact alignment comparing variance retention times internal standards alignment. end, first need identify chromatographic peaks sample m/z retention time close expected values internal standard. use matchValues() function MetaboAnnotation package (Rainer et al. 2022) using MzRtParam method identify chromatographic peaks similar m/z (+/- 50 ppm) retention time (+/- 10 seconds) internal standard’s values. parameters mzColname rtColname specify column names query () target (chromatographic peaks) contain m/z retention time values match entities. perform matching separately sample. internal standard every sample, use filterMatches() function SingleMatchParam() parameter select chromatographic peak highest intensity. now internal standard ID chromatographic peak sample likely represents signal ion. can now extract retention times chromatographic peaks alignment. can now evaluate impact alignment retention times internal standards across full data set:  Figure 15. Retention time variation internal standards alignment. average, variation retention times internal standards across samples slightly reduced alignment. briefly touched subject correspondence determine anchor peaks alignment. Generally, goal correspondence analysis identify chromatographic peaks originate types ions samples experiment group LC-MS features. point, proper configuration parameter bw crucial. illustrate sensible choices parameter’s value can made. use plotChromPeakDensity() function simulate correspondence analysis default values PeakGroups extracted ion chromatograms two selected isotope labeled ions. plot shows EIC top panel, apex position chromatographic peaks different samples (y-axis), along retention time (x-axis) lower panel.  Figure 16. Initial correspondence analysis, Cystine.  Figure 17. Initial correspondence analysis, Methionine. Grouping peaks depends smoothness previousl mentionned density curve can configured parameter bw. seen , smoothness high properly group features. looking default parameters, can observe indeed, bw parameter set bw = 30, high modern UHPLC-MS setups. reduce value parameter 1.8 evaluate impact.  Figure 18. Correspondence analysis optimized parameters, Cystine.  Figure 19. Correspondence analysis optimized parameters, Methionine. can observe peaks now grouped accurately single feature test ion. important parameters optimized : binsize: data generated high resolution MS instrument, thus select low value paramete. ppm: TOF instruments, suggested use value ppm larger 0 accommodate higher measurement error instrument larger m/z values. minFraction: set minFraction = 0.75, hence defining features chromatographic peak identified least 75% samples one sample groups. sampleGroups: use information available sampleData’s \"phenotype\" column. Note parameter also accept factors, therefore complicated groupings can performed wanted. correspondence analysis suggested evaluate results selected EICs. extract signal m/z similar isotope labeled methionine larger retention time range. Importantly, show actual correspondence results, set simulate = FALSE plotChromPeakDensity() function.  Figure 20. Correspondence analysis results, Methionine. hoped, signal two different ions now grouped separate features. Generally, correspondence results evaluated extracted chromatograms. Another interesting information look distribution features along retention time axis. results correspondence analysis now stored, along results preprocessing steps, within XcmsExperiment result object. correspondence results, .e., definition LC-MS features, can extracted using featureDefinitions() function. data frame provides average m/z retention time (columns \"mzmed\" \"rtmed\") characterize LC-MS feature. Column, \"peakidx\" contains indices chromatographic peaks assigned feature. actual abundances features, represent also final preprocessing results, can extracted featureValues() function: can note features (e.g. F0003 F0006) missing values samples. expected certain degree samples features, respectively ions, need present. address next section. previously observed missing values (NA) attributed various reasons. Although might represent genuinely missing value, indicating ion (feature) truly present particular sample, also result failure preceding chromatographic peak detection step. crucial able recover missing values latter category much possible reduce eventual need data imputation. next examine prevalent missing values present dataset: can observe substantial number missing values values dataset. Let’s therefore delve process gap-filling. first evaluate example features chromatographic peak detected samples:  Figure 21. Examples chromatographic peaks missing values. instances, chromatographic peak identified one two selected samples (red line), hence missing value reported feature particular samples (blue line). However, cases, signal measured samples, thus, reporting missing value correct example. signal feature low, likely reason peak detection failed. rescue signal cases, fillChromPeaks() function can used ChromPeakAreaParam approach. method defines m/z-retention time area feature based detected peaks, signal respective ion expected. integrates intensities within area samples missing values feature. reported feature abundance. apply method using default parameters. fillChromPeaks() thus rescue missing data data set. Note , even sample ion present, worst case noise integrated, expected much lower actual chromatographic peak signal. Let’s look previously missing values :  Figure 22. Examples chromatographic peaks missing values gap-filling. gap-filling, also blue colored sample chromatographic peak present peak area reported feature abundance sample. assess effectiveness gap-filling method rescuing signals, can also plot average signal features least one missing value average filled-signal. advisable perform analysis repeatedly measured samples; case, QC samples used. , extract: Feature values detected chromatographic peaks setting filled = FALSE featuresValues() call. filled-signal first extracting detected gap-filled abundances replace values detected chromatographic peaks NA. , calculate row averages matrices plot .  Figure 23. Detected vs. filled-signal. detected (x-axis) gap-filled (y-axis) values QC samples highly correlated. Especially higher abundances, agreement high, low intensities, can expected, differences higher trending correlation line. , addition, fit linear regression line data summarize results linear regression line slope 1.12 intercept -1.62. indicates filled-signal average 1.12 times higher detected signal. now restrict data set features chromatographic peak detected least 2/3 samples least one study samples groups. ensures statistical tests carried later study samples performed reliable signal. Also, filter remove features mostly detected QC samples, study samples. filter can performed filterFeatures() function xcms package PercentMissingFilter setting. parameters filer: threshold: defines maximal acceptable percentage samples missing value(s) least one sample groups defined parameter f. f: factor defining sample groups. replacing \"QC\" sample group NA parameter f exclude QC samples evaluation consider study samples. threshold = 40 keep features peak detected 2 3 samples one sample groups. consider detected chromatographic peaks per sample, apply filter \"raw\" assay result object, contains abundance values detected chromatographic peaks (prior gap-filling). final results LC-MS data preprocessing stored within XcmsExperiment object. includes identified chromatographic peaks, alignment results, well correspondence results. addition, guarantee reproducibility, result object keeps track performed processing steps, including individual parameter objects used configure . processHistory() function returns list various applied processing steps chronological order. , extract information first step performed preprocessing. processParam() function used extract actual parameter class used configure processing step. final result whole LC-MS data preprocessing two-dimensional matrix abundances -called LC-MS features samples. Note stage analysis features characterized m/z retention time don’t yet information metabolite feature represent. seen , feature matrix can extracted featureValues() function corresponding feature characteristics (.e., m/z retention time values) using featureDefinitions() function. Thus, two arrays extracted xcms result object used/imported analysis packages processing. example also exported tab delimited text files, used external tool, used, also MS2 spectra available, feature-based molecular networking GNPS analysis environment (Nothias et al. 2020). processing R, reference link raw MS data required, suggested extract xcms preprocessing result using quantify() function SummarizedExperiment object, Bioconductor’s default container data biological assays/experiments. simplifies integration Bioconductor analysis packages. quantify() function takes parameters featureValues() function, thus, call extract SummarizedExperiment detected, gap-filled, feature abundances: Sample identifications xcms result’s sampleData() now available colData() (column, sample annotations) featureDefinitions() rowData() (row, feature annotations). feature values added first assay() SummarizedExperiment even processing history available object’s metadata(). SummarizedExperiment supports multiple assays, numeric matrices dimensions. thus add detected gap-filled feature abundances additional assay SummarizedExperiment. Feature abundances can extracted assay() function. extract first 6 lines detected gap-filled feature abundances: advantage, addition container full preprocessing results also possibility easy intuitive creation data subsets ensuring data integrity. example easy subset full data selection features /samples: moving next step analysis, advisable save preprocessing results. multiple format options save , can found MsIO package documentation. save XcmsExperiment object file format handled alabster framework, ensures object can easily read languages like Python Javascript well loaded easily back R.","code":"#' Use default Centwave parameter param <- CentWaveParam()  #' Look at the default parameters param Object of class:  CentWaveParam  Parameters:  - ppm: [1] 25  - peakwidth: [1] 20 50  - snthresh: [1] 10  - prefilter: [1]   3 100  - mzCenterFun: [1] \"wMean\"  - integrate: [1] 1  - mzdiff: [1] -0.001  - fitgauss: [1] FALSE  - noise: [1] 0  - verboseColumns: [1] FALSE  - roiList: list()  - firstBaselineCheck: [1] TRUE  - roiScales: numeric(0)  - extendLengthMSW: [1] FALSE  - verboseBetaColumns: [1] FALSE #' Evaluate for Cystine cystine_test <- findChromPeaks(eic_cystine, param = param) chromPeaks(cystine_test) mz mzmin mzmax rt rtmin rtmax into intb maxo sn row column #' Evaluate for Methionine met_test <- findChromPeaks(eic_met, param = param) chromPeaks(met_test) mz mzmin mzmax rt rtmin rtmax into intb maxo sn row column #' Restrict the data to signal from cystine in the first sample cst <- lcms1[1L] |>   spectra() |>   filterRt(rt = c(208, 218)) |>   filterMzRange(mz = fData(eic_cystine)[\"cystine_13C_15N\", c(\"mzmin\", \"mzmax\")])  #' Show the number of peaks per m/z filtered spectra lengths(cst) [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 1 #' Calculate the difference in m/z values between scans mz_diff <- cst |>     mz() |>     unlist() |>     diff() |>     abs()  #' Express differences in ppm range(mz_diff * 1e6 / mean(unlist(mz(cst)))) [1]  0.08829605 14.82188728 #' Parameters adapted for chromatographic peak detection on EICs. param <- CentWaveParam(peakwidth = c(1, 8), ppm = 15, integrate = 2,                        snthresh = 2)  #' Evaluate on the cystine ion cystine_test <- findChromPeaks(eic_cystine, param = param) chromPeaks(cystine_test) mz    mzmin    mzmax      rt   rtmin   rtmax      into      intb mzmin 249.0453 249.0403 249.0503 209.251 207.577 212.878  4085.675  2911.376 mzmin 249.0453 249.0403 249.0503 209.251 206.182 213.995 24625.728 19074.407 mzmin 249.0453 249.0403 249.0503 209.252 207.020 214.274 19467.836 14594.041 mzmin 249.0453 249.0403 249.0503 209.251 207.577 212.041  4648.229  3202.617 mzmin 249.0453 249.0403 249.0503 208.974 206.184 213.159 23801.825 18126.978 mzmin 249.0453 249.0403 249.0503 209.250 207.018 213.714 25990.327 21036.768 mzmin 249.0453 249.0403 249.0503 209.252 207.857 212.879  4528.767  3259.039 mzmin 249.0453 249.0403 249.0503 209.252 207.299 213.995 23119.449 17274.140 mzmin 249.0453 249.0403 249.0503 208.972 206.740 212.878 28943.188 23436.119 mzmin 249.0453 249.0403 249.0503 209.252 207.578 213.437  4470.552  3065.402            maxo sn row column mzmin  2157.459  4   1      1 mzmin 12907.487  4   1      2 mzmin  9996.466  4   1      3 mzmin  2458.485  3   1      4 mzmin 11300.289  3   1      5 mzmin 13650.329  5   1      6 mzmin  2445.841  4   1      7 mzmin 12153.410  4   1      8 mzmin 14451.023  4   1      9 mzmin  2292.881  4   1     10 #' Evaluate on the methionine ion met_test <- findChromPeaks(eic_met, param = param) chromPeaks(met_test) mz    mzmin    mzmax      rt   rtmin   rtmax     into     intb mzmin 156.0722 156.0672 156.0772 159.867 157.913 162.378 20026.61 14715.42 mzmin 156.0722 156.0672 156.0772 160.425 157.077 163.215 16827.76 11843.39 mzmin 156.0722 156.0672 156.0772 160.425 157.356 163.215 18262.45 12881.67 mzmin 156.0722 156.0672 156.0772 159.588 157.635 161.820 20987.72 15424.25 mzmin 156.0722 156.0672 156.0772 160.985 156.799 163.217 16601.72 11968.46 mzmin 156.0722 156.0672 156.0772 160.982 157.634 163.214 17243.24 12389.94 mzmin 156.0722 156.0672 156.0772 159.867 158.193 162.099 21120.10 16202.05 mzmin 156.0722 156.0672 156.0772 160.426 157.356 162.937 18937.40 13739.73 mzmin 156.0722 156.0672 156.0772 160.704 158.472 163.215 17882.21 12299.43 mzmin 156.0722 156.0672 156.0772 160.146 157.914 162.379 20275.80 14279.50            maxo sn row column mzmin 12555.601  4   1      1 mzmin  8407.699  3   1      2 mzmin  9283.375  3   1      3 mzmin 13327.811  4   1      4 mzmin 10012.396  4   1      5 mzmin  9150.079  4   1      6 mzmin 13531.844  3   1      7 mzmin 10336.000  3   1      8 mzmin  9395.548  3   1      9 mzmin 12669.821  3   1     10 #' Plot test chromatogram par(mfrow = c(1, 2)) plot(cystine_test, main = fData(cystine_test)$name,      col = paste0(col_sample, 80),      peakBg = paste0(col_sample, 40)[chromPeaks(cystine_test)[, \"column\"]],      cex.main = 0.8, cex.axis = 0.8) grid()  plot(met_test, main = fData(met_test)$name,      col = paste0(col_sample, 80),      peakBg = paste0(col_sample, 40)[chromPeaks(met_test)[, \"column\"]],      cex.main = 0.8, cex.axis = 0.8) grid() legend(\"topright\", col = col_phenotype,        legend = names(col_phenotype), lty = 1, bty = \"n\") #' Using the same settings, but with default snthresh param <- CentWaveParam(peakwidth = c(1, 8), ppm = 15, integrate = 2) lcms1 <- findChromPeaks(lcms1, param = param, chunkSize = 2)  #' Update EIC internal standard object eics_is_noprocess <- eic_is eic_is <- chromatogram(lcms1,,                        rt = as.matrix(intern_standard[, c(\"rtmin\", \"rtmax\")]),                        mz = as.matrix(intern_standard[, c(\"mzmin\", \"mzmax\")])) Processing chromatographic peaks fData(eic_is) <- fData(eics_is_noprocess) #' Extract m/z-rt regions for selected peaks mz_rt <- cbind(rtmin = c(155.2120, 181.71800),                rtmax = c(201.0710, 228.13500),                mzmin = c(191.0288,  53.50964),                mzmax = c(191.0527, 53.53183))  #' Extract the EICs eics <- chromatogram(lcms1[3], rt = mz_rt[, c(\"rtmin\", \"rtmax\")],                      mz = mz_rt[, c(\"mzmin\", \"mzmax\")]) #' Plot the EICs plot(eics) #' set up the parameter param <- MergeNeighboringPeaksParam(expandRt = 2.5, expandMz = 0.0015,                                     minProp = 0.75)  #' Perform the peak refinement on the EICs eics <- refineChromPeaks(eics, param = param) plot(eics) #' Apply on whole dataset lcms1 <- refineChromPeaks(lcms1, param = param, chunkSize = 5) Reduced from 106714 to 89182 chromatographic peaks. chromPeakData(lcms1)$merged |>                       table() FALSE  TRUE 79908  9274 eics_is_chrompeaks <- eic_is  eic_is <- chromatogram(lcms1,                        rt = as.matrix(intern_standard[, c(\"rtmin\", \"rtmax\")]),                        mz = as.matrix(intern_standard[, c(\"mzmin\", \"mzmax\")])) fData(eic_is) <- fData(eics_is_chrompeaks)  eic_cystine <- eic_is[\"cystine_13C_15N\", ] eic_met <- eic_is[\"methionine_13C_15N\", ] #' Count the number of peaks per sample and summarize them in a table. data.frame(sample_name = sampleData(lcms1)$sample_name,            peak_count = as.integer(table(chromPeaks(lcms1)[, \"sample\"]))) |>   t() |>   kable(format = \"pipe\") #' Get QC samples QC_samples <- sampleData(lcms1)$phenotype == \"QC\"  #' extract BPC lcms1[QC_samples] |>     chromatogram(aggregationFun = \"max\", chromPeaks = \"none\") |>     plot(col = col_phenotype[\"QC\"], main = \"BPC of QC samples\") |>     grid() # Initial correspondence analysis param <- PeakDensityParam(sampleGroups = sampleData(lcms1)$phenotype == \"QC\",                           minFraction = 0.9,                           binSize = 0.01, ppm = 10,                           bw = 2) lcms1 <- groupChromPeaks(lcms1, param = param)  plotChromPeakDensity(     eic_cystine, param = param,     col = paste0(col_sample, \"80\"),     peakCol = col_sample[chromPeaks(eic_cystine)[, \"sample\"]],     peakBg = paste0(col_sample[chromPeaks(eic_cystine)[, \"sample\"]], 20),     peakPch = 16) #' Define parameters of choice subset <- which(sampleData(lcms1)$phenotype == \"QC\") param <- PeakGroupsParam(minFraction = 0.9, extraPeaks = 50, span = 0.5,                          subsetAdjust = \"average\",                          subset = subset)  #' Perform the alignment lcms1 <- adjustRtime(lcms1, param = param) #' Visualize alignment results plotAdjustedRtime(lcms1, col = paste0(col_sample, 80), peakGroupsPch = 1) grid() legend(\"topright\", col = col_phenotype,        legend = names(col_phenotype), lty = 1, bty = \"n\") #' Get data before alignment lcms1_raw <- dropAdjustedRtime(lcms1)  #' Apply the adjusted retention time to our dataset lcms1 <- applyAdjustedRtime(lcms1) #' Plot the BPC before and after alignment par(mfrow = c(2, 1), mar = c(2, 1, 1, 0.5)) chromatogram(lcms1_raw, aggregationFun = \"max\", chromPeaks = \"none\") |>     plot(main = \"BPC before alignment\", col = paste0(col_sample, 80)) grid() legend(\"topright\", col = col_phenotype,        legend = names(col_phenotype), lty = 1, bty = \"n\", horiz = TRUE)  chromatogram(lcms1, aggregationFun = \"max\", chromPeaks = \"none\") |>     plot(main = \"BPC after alignment\",          col = paste0(col_sample, 80)) grid() legend(\"topright\", col = col_phenotype,        legend = names(col_phenotype), lty = 1, bty = \"n\", horiz = TRUE) #' Extract the EICs for the test ions before alignment old_eic_cystine <- eic_is[\"cystine_13C_15N\"] old_eic_met <- eic_is[\"methionine_13C_15N\"]  #' Update the EICs eic_is <- chromatogram(lcms1,                        rt = as.matrix(intern_standard[, c(\"rtmin\", \"rtmax\")]),                        mz = as.matrix(intern_standard[, c(\"mzmin\", \"mzmax\")])) fData(eic_is) <- fdata  #' Extract the EICs for the test ions eic_cystine <- eic_is[\"cystine_13C_15N\"] eic_met <- eic_is[\"methionine_13C_15N\"] par(mfrow = c(2, 2), mar = c(4, 4.5, 2, 1))  plot(old_eic_cystine, main = \"Cystine before alignment\", peakType = \"none\",      col = paste0(col_sample, 80)) grid() abline(v = intern_standard[\"cystine_13C_15N\", \"RT\"], col = \"red\", lty = 3)  plot(old_eic_met, main = \"Methionine before alignment\",      peakType = \"none\", col = paste0(col_sample, 80)) grid() abline(v = intern_standard[\"methionine_13C_15N\", \"RT\"], col = \"red\", lty = 3)  plot(eic_cystine, main = \"Cystine after alignment\", peakType = \"none\",      col = paste0(col_sample, 80)) grid() abline(v = intern_standard[\"cystine_13C_15N\", \"RT\"], col = \"red\", lty = 3) legend(\"topright\", col = col_phenotype,        legend = names(col_phenotype), lty = 1, bty = \"n\")  plot(eic_met, main = \"Methionine after alignment\",      peakType = \"none\", col = paste0(col_sample, 80)) grid() abline(v = intern_standard[\"methionine_13C_15N\", \"RT\"], col = \"red\", lty = 3) #' Extract the matrix with all chromatographic peaks and add a column #' with the ID of the chromatographic peak chrom_peaks <- chromPeaks(lcms1) |> as.data.frame() chrom_peaks$peak_id <- rownames(chrom_peaks)  #' Define the parameters for the matching and filtering of the matches p_1 <- MzRtParam(ppm = 50, toleranceRt = 10) p_2 <- SingleMatchParam(duplicates = \"top_ranked\", column = \"target_maxo\",                         decreasing = TRUE)  #' Iterate over samples and identify for each the chromatographic peaks #' with similar m/z and retention time than the onse from the internal #' standard, and extract among them the ID of the peaks with the #' highest intensity. intern_standard_peaks <- lapply(seq_along(lcms1), function(i) {     tmp <- chrom_peaks[chrom_peaks[, \"sample\"] == i, , drop = FALSE]     mtch <- matchValues(intern_standard, tmp,                         mzColname = c(\"mz\", \"mz\"),                         rtColname = c(\"RT\", \"rt\"),                         param = p_1)     mtch <- filterMatches(mtch, p_2)     mtch$target_peak_id }) |>     do.call(what = cbind) #' Define the index of the selected chromatographic peaks in the #' full chromPeaks matrix idx <- match(intern_standard_peaks, rownames(chromPeaks(lcms1)))  #' Extract the raw retention times for these rt_raw <- chromPeaks(lcms1_raw)[idx, \"rt\"] |>     matrix(ncol = length(lcms1_raw))  #' Extract the adjusted retention times for these rt_adj <- chromPeaks(lcms1)[idx, \"rt\"] |>     matrix(ncol = length(lcms1_raw)) list(all_raw = rowSds(rt_raw, na.rm = TRUE),      all_adj = rowSds(rt_adj, na.rm = TRUE)      ) |>     vioplot() grid() #' Default parameter for the grouping and apply them to the test ions BPC param <- PeakDensityParam(sampleGroups = sampleData(lcms1)$phenotype, bw = 30)  param Object of class:  PeakDensityParam  Parameters:  - sampleGroups:  [1] \"QC\"  \"CVD\" \"CTR\" \"QC\"  \"CTR\" \"CVD\" \"QC\"  \"CTR\" \"CVD\" \"QC\"  - bw: [1] 30  - minFraction: [1] 0.5  - minSamples: [1] 1  - binSize: [1] 0.25  - maxFeatures: [1] 50  - ppm: [1] 0 plotChromPeakDensity(     eic_cystine, param = param,     col = paste0(col_sample, \"80\"),     peakCol = col_sample[chromPeaks(eic_cystine)[, \"sample\"]],     peakBg = paste0(col_sample[chromPeaks(eic_cystine)[, \"sample\"]], 20),     peakPch = 16) plotChromPeakDensity(eic_met, param = param,     col = paste0(col_sample, \"80\"),     peakCol = col_sample[chromPeaks(eic_met)[, \"sample\"]],     peakBg = paste0(col_sample[chromPeaks(eic_met)[, \"sample\"]], 20),     peakPch = 16) #' Updating parameters param <- PeakDensityParam(sampleGroups = sampleData(lcms1)$phenotype, bw = 1.8)  plotChromPeakDensity(     eic_cystine, param = param,     col = paste0(col_sample, \"80\"),     peakCol = col_sample[chromPeaks(eic_cystine)[, \"sample\"]],     peakBg = paste0(col_sample[chromPeaks(eic_cystine)[, \"sample\"]], 20),     peakPch = 16) plotChromPeakDensity(eic_met, param = param,     col = paste0(col_sample, \"80\"),     peakCol = col_sample[chromPeaks(eic_met)[, \"sample\"]],     peakBg = paste0(col_sample[chromPeaks(eic_met)[, \"sample\"]], 20),     peakPch = 16) #' Define the settings for the param param <- PeakDensityParam(sampleGroups = sampleData(lcms1)$phenotype,                           minFraction = 0.75, binSize = 0.01, ppm = 10,                           bw = 1.8)  #' Apply to whole data lcms1 <- groupChromPeaks(lcms1, param = param) #' Extract chromatogram for an m/z similar to the one of the labeled methionine chr_test <- chromatogram(lcms1,                          mz = as.matrix(intern_standard[\"methionine_13C_15N\",                                                         c(\"mzmin\", \"mzmax\")]),                          rt = c(145, 200),                          aggregationFun = \"max\") plotChromPeakDensity(     chr_test, simulate = FALSE,     col = paste0(col_sample, \"80\"),     peakCol = col_sample[chromPeaks(chr_test)[, \"sample\"]],     peakBg = paste0(col_sample[chromPeaks(chr_test)[, \"sample\"]], 20),     peakPch = 16) # Bin features per RT slices vc <- featureDefinitions(lcms1)$rtmed breaks <- seq(0, max(vc, na.rm = TRUE) + 1, length.out = 15) |>     round(0) cuts <- cut(vc, breaks = breaks, include.lowest = TRUE)  table(cuts) cuts    [0,17]   (17,34]   (34,51]   (51,68]   (68,86]  (86,103] (103,120] (120,137]        15      2608       649        24       132        11        15       105 (137,154] (154,171] (171,188] (188,205] (205,222] (222,240]      1441      2202       410       869       554        33 #' Definition of the features featureDefinitions(lcms1) |>   head() mzmed    mzmin    mzmax    rtmed    rtmin    rtmax npeaks CTR CVD QC FT0001 50.98979 50.98949 50.99038 203.6001 203.1181 204.2331      8   1   3  4 FT0002 51.05904 51.05880 51.05941 191.1675 190.8787 191.5050      9   2   3  4 FT0003 51.98657 51.98631 51.98699 203.1467 202.6406 203.6710      7   0   3  4 FT0004 53.02036 53.02009 53.02043 203.2343 202.5652 204.0901     10   3   3  4 FT0005 53.52080 53.52051 53.52102 203.1936 202.8490 204.0901     10   3   3  4 FT0006 54.01007 54.00988 54.01015 159.2816 158.8499 159.4484      6   1   3  2             peakidx ms_level FT0001 7702, 16....        1 FT0002 7176, 16....        1 FT0003 7680, 17....        1 FT0004 7763, 17....        1 FT0005 8353, 17....        1 FT0006 5800, 15....        1 #' Extract feature abundances featureValues(lcms1, method = \"sum\") |>     head() MS_QC_POOL_1_POS.mzML MS_A_POS.mzML MS_B_POS.mzML MS_QC_POOL_2_POS.mzML FT0001              421.6162      689.2422            NA              481.7436 FT0002              710.8078      875.9192            NA              693.6997 FT0003              445.5711      613.4410            NA              497.8866 FT0004            16994.5260    24605.7340     19766.707            17808.0933 FT0005             3284.2664     4526.0531      3521.822             3379.8909 FT0006            10681.7476    10009.6602            NA            10800.5449        MS_C_POS.mzML MS_D_POS.mzML MS_QC_POOL_3_POS.mzML MS_E_POS.mzML FT0001            NA      635.2732              439.6086      570.5849 FT0002      781.2416      648.4344              700.9716     1054.0207 FT0003            NA      634.9370              449.0933            NA FT0004    22780.6683    22873.1061            16965.7762    23432.1252 FT0005     4396.0762     4317.7734             3270.5290     4533.8667 FT0006            NA     7296.4262                    NA     9236.9799        MS_F_POS.mzML MS_QC_POOL_4_POS.mzML FT0001      579.9360              437.0340 FT0002      534.4577              711.0361 FT0003      461.0465              232.1075 FT0004    22198.4607            16796.4497 FT0005     4161.0132             3142.2268 FT0006     6817.8785                    NA #' Percentage of missing values sum(is.na(featureValues(lcms1))) /     length(featureValues(lcms1)) * 100 [1] 26.41597 ftidx <- which(is.na(rowSums(featureValues(lcms1)))) fts <- rownames(featureDefinitions(lcms1))[ftidx] farea <- featureArea(lcms1, features = fts[1:2])  chromatogram(lcms1[c(2, 3)],              rt = farea[, c(\"rtmin\", \"rtmax\")],              mz = farea[, c(\"mzmin\", \"mzmax\")]) |>     plot(col = c(\"red\", \"blue\"), lwd = 2) #' Fill in the missing values in the whole dataset lcms1 <- fillChromPeaks(lcms1, param = ChromPeakAreaParam(), chunkSize = 5)  #' Percentage of missing values after gap-filling sum(is.na(featureValues(lcms1))) /     length(featureValues(lcms1)) * 100 [1] 5.155492 #' Get only detected signal in QC samples vals_detect <- featureValues(lcms1, filled = FALSE)[, QC_samples]  #' Get detected and filled-in signal vals_filled <- featureValues(lcms1)[, QC_samples]  #' Replace detected signal with NA vals_filled[!is.na(vals_detect)] <- NA  #' Identify features with at least one filled peak has_filled <- is.na(rowSums(vals_detect))  #' Calculate row averages for features with missing values avg_detect <- rowMeans(vals_detect[has_filled, ], na.rm = TRUE) avg_filled <- rowMeans(vals_filled[has_filled, ], na.rm = TRUE)  #' Plot the values against each other (in log2 scale) plot(log2(avg_detect), log2(avg_filled),      xlim = range(log2(c(avg_detect, avg_filled)), na.rm = TRUE),      ylim = range(log2(c(avg_detect, avg_filled)), na.rm = TRUE),      pch = 21, bg = \"#00000020\", col = \"#00000080\") grid() abline(0, 1) #' fit a linear regression line to the data l <- lm(log2(avg_filled) ~ log2(avg_detect)) summary(l) Call: lm(formula = log2(avg_filled) ~ log2(avg_detect))  Residuals:     Min      1Q  Median      3Q     Max -6.8176 -0.3807  0.1725  0.5492  6.7504  Coefficients:                  Estimate Std. Error t value Pr(>|t|) (Intercept)      -1.62359    0.11545  -14.06   <2e-16 *** log2(avg_detect)  1.11763    0.01259   88.75   <2e-16 *** --- Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1  Residual standard error: 0.9366 on 2846 degrees of freedom   (846 observations deleted due to missingness) Multiple R-squared:  0.7346,    Adjusted R-squared:  0.7345 F-statistic:  7877 on 1 and 2846 DF,  p-value: < 2.2e-16 #' Limit features to those with at least two detected peaks in one study group. #' Setting the value for QC samples to NA excludes QC samples from the #' calculation. f <- sampleData(lcms1)$phenotype f[f == \"QC\"] <- NA f <- as.factor(f) lcms1 <- filterFeatures(lcms1, PercentMissingFilter(f = f, threshold = 40)) 344 features were removed #' Check first step of the process history processHistory(lcms1)[[1]] Object of class \"XProcessHistory\"  type: Peak detection  date: Wed Jul 16 07:15:06 2025  info:  fileIndex: 1,2,3,4,5,6,7,8,9,10  Parameter class: CentWaveParam  MS level(s) 1 #' Extract results as a SummarizedExperiment res <- quantify(lcms1, method = \"sum\", filled = FALSE) res class: SummarizedExperiment dim: 8724 10 metadata(7): '' '' ... '' '' assays(1): raw rownames(8724): FT0001 FT0002 ... FT9067 FT9068 rowData names(11): mzmed mzmin ... QC ms_level colnames(10): MS_QC_POOL_1_POS.mzML MS_A_POS.mzML ... MS_F_POS.mzML   MS_QC_POOL_4_POS.mzML colData names(11): sample_name derived_spectra_data_file ... phenotype   injection_index assays(res)$raw_filled <- featureValues(lcms1, method = \"sum\",                                         filled = TRUE )  #' Different assay in the SummarizedExperiment object assayNames(res) [1] \"raw\"        \"raw_filled\" assay(res, \"raw_filled\") |> head() MS_QC_POOL_1_POS.mzML MS_A_POS.mzML MS_B_POS.mzML MS_QC_POOL_2_POS.mzML FT0001              421.6162      689.2422      411.3295              481.7436 FT0002              710.8078      875.9192      457.5920              693.6997 FT0003              445.5711      613.4410      277.5022              497.8866 FT0004            16994.5260    24605.7340    19766.7069            17808.0933 FT0005             3284.2664     4526.0531     3521.8221             3379.8909 FT0006            10681.7476    10009.6602     9599.9701            10800.5449        MS_C_POS.mzML MS_D_POS.mzML MS_QC_POOL_3_POS.mzML MS_E_POS.mzML FT0001      314.7567      635.2732              439.6086      570.5849 FT0002      781.2416      648.4344              700.9716     1054.0207 FT0003      425.3774      634.9370              449.0933      556.2544 FT0004    22780.6683    22873.1061            16965.7762    23432.1252 FT0005     4396.0762     4317.7734             3270.5290     4533.8667 FT0006     4792.2390     7296.4262             2382.1788     9236.9799        MS_F_POS.mzML MS_QC_POOL_4_POS.mzML FT0001      579.9360              437.0340 FT0002      534.4577              711.0361 FT0003      461.0465              232.1075 FT0004    22198.4607            16796.4497 FT0005     4161.0132             3142.2268 FT0006     6817.8785             6911.5439 res[1:14, 3:8] class: SummarizedExperiment dim: 14 6 metadata(7): '' '' ... '' '' assays(2): raw raw_filled rownames(14): FT0001 FT0002 ... FT0013 FT0014 rowData names(11): mzmed mzmin ... QC ms_level colnames(6): MS_B_POS.mzML MS_QC_POOL_2_POS.mzML ...   MS_QC_POOL_3_POS.mzML MS_E_POS.mzML colData names(11): sample_name derived_spectra_data_file ... phenotype   injection_index #' XcmsExperiment object:  saveMsObject(lcms1,              AlabasterParam(path = file.path(\"objects/preprocessed_lcms1\")))  #' Below we remove the processHistory of the res object to allow for export. metadata(res) <- list() saveObject(res, file.path(\"objects/preprocessed_res\"))"},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/a-end-to-end-untargeted-metabolomics.html","id":"chromatographic-peak-detection","dir":"Articles","previous_headings":"","what":"Chromatographic peak detection","title":"Complete end-to-end LC-MS/MS Metabolomic Data analysis","text":"initial preprocessing step involves detecting intensity peaks along retention time axis, called chromatographic peaks. achieve , employ findChromPeaks() function within xcms. function supports various algorithms peak detection, can selected configured respective parameter objects. preferred algorithm case, CentWave, utilizes continuous wavelet transformation (CWT)-based peak detection (Tautenhahn, Böttcher, Neumann 2008). method known effectiveness handling non-Gaussian shaped chromatographic peaks peaks varying retention time widths, commonly encountered HILIC separations. apply CentWave algorithm default settings EICs cystine methionine ions evaluate results. CentWave highly performant algorithm, requires customized dataset. implies parameters fine-tuned based user’s data. example serves clear motivation users familiarize various parameters need adapt data set. discuss main parameters can easily adjusted suit user’s dataset: peakwidth: Specifies minimal maximal expected width peaks retention time dimension. Highly dependent chromatographic settings used. ppm: maximal allowed difference mass peaks’ m/z values (parts-per-million) consecutive scans consider representing signal ion. integrate: parameter defines integration method. , primarily use integrate = 2 integrates also signal chromatographic peak’s tail considered accurate developers. determine peakwidth, recommend users refer previous EICs estimate range peak widths observe dataset. Ideally, examining multiple EICs goal. dataset, peak widths appear around 2 10 seconds. advise choosing range wide narrow peakwidth parameter can lead false positives negatives. determine ppm, deeper analysis dataset needed. clarified ppm depends instrument, users necessarily input vendor-advertised ppm. ’s determine accurately possible: following steps involve generating highly restricted MS area single mass peak per spectrum, representing cystine ion. m/z peaks extracted, absolute difference calculated finally expressed ppm. therefore, choose value close maximum within range parameter ppm, .e., 15 ppm. can now perform chromatographic peak detection adapted settings EICs. important note , properly estimate background noise, sufficient data points outside chromatographic peak need present. generally problem peak detection performed full LC-MS data set, peak detection EICs retention time range EIC needs sufficiently wide. function fails find peak EIC, initial troubleshooting step increase range. Additionally, signal--noise threshold snthresh reduced peak detection EICs, within small retention time range, enough signal present properly estimate background noise. Finally, case MS1 data points per peaks, setting CentWave’s advanced parameter extendLengthMSW TRUE can help peak detection. customized parameters, chromatographic peak detected sample. , use plot() function EICs visualize results.  Figure 6. Chromatographic peak detection EICs. can see peak seems detected sample ions. indicates custom settings suitable dataset. now proceed apply entire dataset, extracting EICs ions evaluate confirm chromatographic peak detection worked expected. Note: revert value parameter snthresh default, , mentioned , background noise estimation reliable performed full data set. Parameter chunkSize findChromPeaks() defines number data files loaded memory processed simultaneously. parameter thus allows fine-tune memory demand well performance chromatographic peak detection step. correspond initial set parallel processing . plot EICs two selected internal standards evaluate chromatographic peak detection results.  Figure 7. Chromatographic peak detection EICs processing. Peaks seem detected properly samples ions. indicates peak detection process entire dataset successful. identification chromatographic peaks using CentWave algorithm can sometimes result artifacts, overlapping split peaks. address issue, refineChromPeaks() function utilized, conjunction MergeNeighboringPeaksParam, aims merging split peaks. show examples CentWave peak detection artifacts. examples pre-selected illustrate necessity next step:  Figure 8. Examples CentWave peak detection artifacts. cases signal presumably single type ion split two separate chromatographic peaks (indicated vertical line). MergeNeigboringPeaksParam allows combine split peaks. parameters algorithm defined : expandMz: Suggested kept relatively small (0.0015) prevent merging isotopes. expandRt: Usually set approximately half size average retention time width used chromatographic peak detection (case, 2.5 seconds). minProp: Used determine whether candidates merged. Chromatographic peaks overlapping m/z ranges (expanded side expandMz) tail--head distance retention time dimension less 2 * expandRt, signal higher minProp apex intensity chromatographic peak lower intensity, merged. Values parameter small avoid merging closely co-eluting ions, isomers. test settings EICs split peaks.  Figure 9. Examples CentWave peak detection artifacts merging. can observe artificially split peaks appropriately merged. Therefore, next apply settings entire dataset. peak merging, column \"merged\" result object’s chromPeakData() data frame can used evaluate chromatographic peaks result represent signal merged, originally identified chromatographic peaks. proceeding next preprocessing step generally suggested evaluate results chromatographic peak detection EICs e.g. internal standards compounds/ions known present samples. update EICs objects internal standards results chromatographic peak detection refinement. Additionally, evaluating comparing number identified chromatographic peaks samples data set can help spotting potentially problematic samples. count number chromatographic peaks per sample show numbers table. Table 4. Samples number identified chromatographic peaks. similar number chromatographic peaks identified within various samples data set. Additional options evaluate results chromatographic peak detection can implemented using plotChromPeaks() function summarizing results using base R commands.","code":"#' Use default Centwave parameter param <- CentWaveParam()  #' Look at the default parameters param Object of class:  CentWaveParam  Parameters:  - ppm: [1] 25  - peakwidth: [1] 20 50  - snthresh: [1] 10  - prefilter: [1]   3 100  - mzCenterFun: [1] \"wMean\"  - integrate: [1] 1  - mzdiff: [1] -0.001  - fitgauss: [1] FALSE  - noise: [1] 0  - verboseColumns: [1] FALSE  - roiList: list()  - firstBaselineCheck: [1] TRUE  - roiScales: numeric(0)  - extendLengthMSW: [1] FALSE  - verboseBetaColumns: [1] FALSE #' Evaluate for Cystine cystine_test <- findChromPeaks(eic_cystine, param = param) chromPeaks(cystine_test) mz mzmin mzmax rt rtmin rtmax into intb maxo sn row column #' Evaluate for Methionine met_test <- findChromPeaks(eic_met, param = param) chromPeaks(met_test) mz mzmin mzmax rt rtmin rtmax into intb maxo sn row column #' Restrict the data to signal from cystine in the first sample cst <- lcms1[1L] |>   spectra() |>   filterRt(rt = c(208, 218)) |>   filterMzRange(mz = fData(eic_cystine)[\"cystine_13C_15N\", c(\"mzmin\", \"mzmax\")])  #' Show the number of peaks per m/z filtered spectra lengths(cst) [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 1 #' Calculate the difference in m/z values between scans mz_diff <- cst |>     mz() |>     unlist() |>     diff() |>     abs()  #' Express differences in ppm range(mz_diff * 1e6 / mean(unlist(mz(cst)))) [1]  0.08829605 14.82188728 #' Parameters adapted for chromatographic peak detection on EICs. param <- CentWaveParam(peakwidth = c(1, 8), ppm = 15, integrate = 2,                        snthresh = 2)  #' Evaluate on the cystine ion cystine_test <- findChromPeaks(eic_cystine, param = param) chromPeaks(cystine_test) mz    mzmin    mzmax      rt   rtmin   rtmax      into      intb mzmin 249.0453 249.0403 249.0503 209.251 207.577 212.878  4085.675  2911.376 mzmin 249.0453 249.0403 249.0503 209.251 206.182 213.995 24625.728 19074.407 mzmin 249.0453 249.0403 249.0503 209.252 207.020 214.274 19467.836 14594.041 mzmin 249.0453 249.0403 249.0503 209.251 207.577 212.041  4648.229  3202.617 mzmin 249.0453 249.0403 249.0503 208.974 206.184 213.159 23801.825 18126.978 mzmin 249.0453 249.0403 249.0503 209.250 207.018 213.714 25990.327 21036.768 mzmin 249.0453 249.0403 249.0503 209.252 207.857 212.879  4528.767  3259.039 mzmin 249.0453 249.0403 249.0503 209.252 207.299 213.995 23119.449 17274.140 mzmin 249.0453 249.0403 249.0503 208.972 206.740 212.878 28943.188 23436.119 mzmin 249.0453 249.0403 249.0503 209.252 207.578 213.437  4470.552  3065.402            maxo sn row column mzmin  2157.459  4   1      1 mzmin 12907.487  4   1      2 mzmin  9996.466  4   1      3 mzmin  2458.485  3   1      4 mzmin 11300.289  3   1      5 mzmin 13650.329  5   1      6 mzmin  2445.841  4   1      7 mzmin 12153.410  4   1      8 mzmin 14451.023  4   1      9 mzmin  2292.881  4   1     10 #' Evaluate on the methionine ion met_test <- findChromPeaks(eic_met, param = param) chromPeaks(met_test) mz    mzmin    mzmax      rt   rtmin   rtmax     into     intb mzmin 156.0722 156.0672 156.0772 159.867 157.913 162.378 20026.61 14715.42 mzmin 156.0722 156.0672 156.0772 160.425 157.077 163.215 16827.76 11843.39 mzmin 156.0722 156.0672 156.0772 160.425 157.356 163.215 18262.45 12881.67 mzmin 156.0722 156.0672 156.0772 159.588 157.635 161.820 20987.72 15424.25 mzmin 156.0722 156.0672 156.0772 160.985 156.799 163.217 16601.72 11968.46 mzmin 156.0722 156.0672 156.0772 160.982 157.634 163.214 17243.24 12389.94 mzmin 156.0722 156.0672 156.0772 159.867 158.193 162.099 21120.10 16202.05 mzmin 156.0722 156.0672 156.0772 160.426 157.356 162.937 18937.40 13739.73 mzmin 156.0722 156.0672 156.0772 160.704 158.472 163.215 17882.21 12299.43 mzmin 156.0722 156.0672 156.0772 160.146 157.914 162.379 20275.80 14279.50            maxo sn row column mzmin 12555.601  4   1      1 mzmin  8407.699  3   1      2 mzmin  9283.375  3   1      3 mzmin 13327.811  4   1      4 mzmin 10012.396  4   1      5 mzmin  9150.079  4   1      6 mzmin 13531.844  3   1      7 mzmin 10336.000  3   1      8 mzmin  9395.548  3   1      9 mzmin 12669.821  3   1     10 #' Plot test chromatogram par(mfrow = c(1, 2)) plot(cystine_test, main = fData(cystine_test)$name,      col = paste0(col_sample, 80),      peakBg = paste0(col_sample, 40)[chromPeaks(cystine_test)[, \"column\"]],      cex.main = 0.8, cex.axis = 0.8) grid()  plot(met_test, main = fData(met_test)$name,      col = paste0(col_sample, 80),      peakBg = paste0(col_sample, 40)[chromPeaks(met_test)[, \"column\"]],      cex.main = 0.8, cex.axis = 0.8) grid() legend(\"topright\", col = col_phenotype,        legend = names(col_phenotype), lty = 1, bty = \"n\") #' Using the same settings, but with default snthresh param <- CentWaveParam(peakwidth = c(1, 8), ppm = 15, integrate = 2) lcms1 <- findChromPeaks(lcms1, param = param, chunkSize = 2)  #' Update EIC internal standard object eics_is_noprocess <- eic_is eic_is <- chromatogram(lcms1,,                        rt = as.matrix(intern_standard[, c(\"rtmin\", \"rtmax\")]),                        mz = as.matrix(intern_standard[, c(\"mzmin\", \"mzmax\")])) Processing chromatographic peaks fData(eic_is) <- fData(eics_is_noprocess) #' Extract m/z-rt regions for selected peaks mz_rt <- cbind(rtmin = c(155.2120, 181.71800),                rtmax = c(201.0710, 228.13500),                mzmin = c(191.0288,  53.50964),                mzmax = c(191.0527, 53.53183))  #' Extract the EICs eics <- chromatogram(lcms1[3], rt = mz_rt[, c(\"rtmin\", \"rtmax\")],                      mz = mz_rt[, c(\"mzmin\", \"mzmax\")]) #' Plot the EICs plot(eics) #' set up the parameter param <- MergeNeighboringPeaksParam(expandRt = 2.5, expandMz = 0.0015,                                     minProp = 0.75)  #' Perform the peak refinement on the EICs eics <- refineChromPeaks(eics, param = param) plot(eics) #' Apply on whole dataset lcms1 <- refineChromPeaks(lcms1, param = param, chunkSize = 5) Reduced from 106714 to 89182 chromatographic peaks. chromPeakData(lcms1)$merged |>                       table() FALSE  TRUE 79908  9274 eics_is_chrompeaks <- eic_is  eic_is <- chromatogram(lcms1,                        rt = as.matrix(intern_standard[, c(\"rtmin\", \"rtmax\")]),                        mz = as.matrix(intern_standard[, c(\"mzmin\", \"mzmax\")])) fData(eic_is) <- fData(eics_is_chrompeaks)  eic_cystine <- eic_is[\"cystine_13C_15N\", ] eic_met <- eic_is[\"methionine_13C_15N\", ] #' Count the number of peaks per sample and summarize them in a table. data.frame(sample_name = sampleData(lcms1)$sample_name,            peak_count = as.integer(table(chromPeaks(lcms1)[, \"sample\"]))) |>   t() |>   kable(format = \"pipe\")"},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/a-end-to-end-untargeted-metabolomics.html","id":"refine-identified-chromatographic-peaks","dir":"Articles","previous_headings":"Data preprocessing","what":"Refine identified chromatographic peaks","title":"Complete end-to-end LC-MS/MS Metabolomic Data analysis","text":"identification chromatographic peaks using CentWave algorithm can sometimes result artifacts, overlapping split peaks. address issue, refineChromPeaks() function utilized, conjunction MergeNeighboringPeaksParam, aims merging split peaks. show examples CentWave peak detection artifacts. examples pre-selected illustrate necessity next step:  Figure 8. Examples CentWave peak detection artifacts. cases signal presumably single type ion split two separate chromatographic peaks (indicated vertical line). MergeNeigboringPeaksParam allows combine split peaks. parameters algorithm defined : expandMz: Suggested kept relatively small (0.0015) prevent merging isotopes. expandRt: Usually set approximately half size average retention time width used chromatographic peak detection (case, 2.5 seconds). minProp: Used determine whether candidates merged. Chromatographic peaks overlapping m/z ranges (expanded side expandMz) tail--head distance retention time dimension less 2 * expandRt, signal higher minProp apex intensity chromatographic peak lower intensity, merged. Values parameter small avoid merging closely co-eluting ions, isomers. test settings EICs split peaks.  Figure 9. Examples CentWave peak detection artifacts merging. can observe artificially split peaks appropriately merged. Therefore, next apply settings entire dataset. peak merging, column \"merged\" result object’s chromPeakData() data frame can used evaluate chromatographic peaks result represent signal merged, originally identified chromatographic peaks. proceeding next preprocessing step generally suggested evaluate results chromatographic peak detection EICs e.g. internal standards compounds/ions known present samples. update EICs objects internal standards results chromatographic peak detection refinement. Additionally, evaluating comparing number identified chromatographic peaks samples data set can help spotting potentially problematic samples. count number chromatographic peaks per sample show numbers table. Table 4. Samples number identified chromatographic peaks. similar number chromatographic peaks identified within various samples data set. Additional options evaluate results chromatographic peak detection can implemented using plotChromPeaks() function summarizing results using base R commands.","code":"#' Extract m/z-rt regions for selected peaks mz_rt <- cbind(rtmin = c(155.2120, 181.71800),                rtmax = c(201.0710, 228.13500),                mzmin = c(191.0288,  53.50964),                mzmax = c(191.0527, 53.53183))  #' Extract the EICs eics <- chromatogram(lcms1[3], rt = mz_rt[, c(\"rtmin\", \"rtmax\")],                      mz = mz_rt[, c(\"mzmin\", \"mzmax\")]) #' Plot the EICs plot(eics) #' set up the parameter param <- MergeNeighboringPeaksParam(expandRt = 2.5, expandMz = 0.0015,                                     minProp = 0.75)  #' Perform the peak refinement on the EICs eics <- refineChromPeaks(eics, param = param) plot(eics) #' Apply on whole dataset lcms1 <- refineChromPeaks(lcms1, param = param, chunkSize = 5) Reduced from 106714 to 89182 chromatographic peaks. chromPeakData(lcms1)$merged |>                       table() FALSE  TRUE 79908  9274 eics_is_chrompeaks <- eic_is  eic_is <- chromatogram(lcms1,                        rt = as.matrix(intern_standard[, c(\"rtmin\", \"rtmax\")]),                        mz = as.matrix(intern_standard[, c(\"mzmin\", \"mzmax\")])) fData(eic_is) <- fData(eics_is_chrompeaks)  eic_cystine <- eic_is[\"cystine_13C_15N\", ] eic_met <- eic_is[\"methionine_13C_15N\", ] #' Count the number of peaks per sample and summarize them in a table. data.frame(sample_name = sampleData(lcms1)$sample_name,            peak_count = as.integer(table(chromPeaks(lcms1)[, \"sample\"]))) |>   t() |>   kable(format = \"pipe\")"},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/a-end-to-end-untargeted-metabolomics.html","id":"retention-time-alignment","dir":"Articles","previous_headings":"","what":"Retention time alignment","title":"Complete end-to-end LC-MS/MS Metabolomic Data analysis","text":"Despite using chromatographic settings conditions retention time shifts unavoidable. Indeed, performance instrument can change time, example due small variations environmental conditions, temperature pressure. shifts generally small samples measured within batch/measurement run, can considerable data experiment acquired across longer time period. evaluate presence shift extract plot BPC QC samples.  Figure 10. BPC QC samples. QC samples representing sample (pool) measured regular intervals measurement run experiment measured day. Still, small shifts can observed, especially region 100 150 seconds. facilitate proper correspondence signals across samples (hence definition LC-MS features), essential minimize differences retention times. Theoretically, proceed two steps: first select QC samples dataset first alignment , using -called anchor peaks. way can assume linear shift time, since always measuring sample different regular time intervals. Despite external QCs data set, still use subset-based alignment assuming retention time shifts independent different sample matrix (human serum plasma) instead mostly instrument-dependent. Note also possible manually specify anchor peaks, respectively retention times align data set external, reference, data set. information provided vignettes xcms package. calculating much adjust retention time samples, apply shift also study samples. xcms, retention time alignment can performed using adjustRtime() function alignment algorithm. example use PeakGroups method (Smith et al. 2006) performs alignment minimizing differences retention times set anchor peaks different samples. method requires initial correspondence analysis match/group chromatographic peaks across samples algorithm selects anchor peaks alignment. initial correspondence, use PeakDensity approach (Smith et al. 2006) groups chromatographic peaks similar m/z retention time LC-MS features. parameters algorithm, can configured using PeakDensityParam object, sampleGroups, minFraction, binSize, ppm bw. binSize, ppm bw allow specify similar chromatographic peaks’ m/z retention time values need consider grouping feature. binSize ppm define required similarity m/z values. Within m/z bin (defined binSize ppm) areas along retention time axis high chromatographic peak density (considering peaks samples) identified, chromatographic peaks within regions considered grouping feature. High density areas identified using base R density() function, bw parameter: higher values define wider retention time areas, lower values require chromatographic peaks similar retention times. parameter can seen black line plot , corresponding smoothness density curve. Whether candidate peaks get grouped feature depends also parameters sampleGroups minFraction: sampleGroups provide, sample, sample group belongs . minFraction expected value 0 1 defining proportion samples within least one sample groups (defined sampleGroups) chromatographic peaks detected group feature. initial correspondence, parameters don’t need fully optimized. Selection dataset-specific parameter values described detail next section. dataset, use small values binSize ppm , importantly, also parameter bw, since data set ultra high performance (UHP) LC setup used. minFraction use high value (0.9) ensure features defined chromatographic peaks present almost samples one sample group (can used anchor peaks actual alignment). base alignment later QC samples hence define sampleGroups binary variable grouping samples either study, QC group.  Figure 11. Initial correspondence analysis. PeakGroups-based alignment can next performed using adjustRtime() function PeakGroupsParam parameter object. parameters algorithm : subsetAdjust subset: Allows subset alignment. base retention time alignment QC samples, .e., retention time shifts estimated based repeatedly measured samples. resulting adjustment applied entire data. data sets QC samples (e.g. sample pools) measured repeatedly, strongly suggest use method. Note also subset-based alignment samples ordered injection index (.e., order measured measurement run). minFraction: value 0 1 defining proportion samples (full data set, data subset defined subset) chromatographic peak identified use anchor peak. contrast PeakDensityParam parameter used define proportion within sample group. span: PeakGroups method allows, depending data, adjust regions along retention time axis differently. enable local alignments LOESS function used parameter defines degree smoothing function. Generally, values 0.4 0.6 used, however, suggested evaluate alignment results eventually adapt parameters result satisfactory. perform alignment data set based retention times anchor peaks defined subset QC samples. Alignment adjusted retention times spectra data set, well retention times identified chromatographic peaks. alignment performed, user evaluate results using plotAdjustedRtime() function. function visualizes difference adjusted raw retention time sample y-axis along adjusted retention time x-axis. Dot points represent position used anchor peak along retention time axis. optimal alignment areas along retention time axis, anchor peaks scattered retention time dimension.  Figure 12. Retention time alignment results. samples present data set measured within measurement run, resulting small retention time shifts. Therefore, little adjustments needed performed (shifts maximum 1 second can seen plot ). Generally, magnitude adjustment seen plots match expectation analyst. can also compare BPC alignment. get original data, .e. raw retention times, can use dropAdjustedRtime() function:  Figure 13. BPC alignment. largest shift can observed retention time range 120 130s. Apart retention time range, little changes can observed. next evaluate impact alignment EICs selected internal standards. thus first extract ion chromatograms alignment, subsequently plot .  Figure 14. EICs cystine methionine alignment. non-endogenous cystine ion already well aligned difference minimal. methionine ion, however, shows slight improvement alignment. addition visual inspection results, also evaluate impact alignment comparing variance retention times internal standards alignment. end, first need identify chromatographic peaks sample m/z retention time close expected values internal standard. use matchValues() function MetaboAnnotation package (Rainer et al. 2022) using MzRtParam method identify chromatographic peaks similar m/z (+/- 50 ppm) retention time (+/- 10 seconds) internal standard’s values. parameters mzColname rtColname specify column names query () target (chromatographic peaks) contain m/z retention time values match entities. perform matching separately sample. internal standard every sample, use filterMatches() function SingleMatchParam() parameter select chromatographic peak highest intensity. now internal standard ID chromatographic peak sample likely represents signal ion. can now extract retention times chromatographic peaks alignment. can now evaluate impact alignment retention times internal standards across full data set:  Figure 15. Retention time variation internal standards alignment. average, variation retention times internal standards across samples slightly reduced alignment.","code":"#' Get QC samples QC_samples <- sampleData(lcms1)$phenotype == \"QC\"  #' extract BPC lcms1[QC_samples] |>     chromatogram(aggregationFun = \"max\", chromPeaks = \"none\") |>     plot(col = col_phenotype[\"QC\"], main = \"BPC of QC samples\") |>     grid() # Initial correspondence analysis param <- PeakDensityParam(sampleGroups = sampleData(lcms1)$phenotype == \"QC\",                           minFraction = 0.9,                           binSize = 0.01, ppm = 10,                           bw = 2) lcms1 <- groupChromPeaks(lcms1, param = param)  plotChromPeakDensity(     eic_cystine, param = param,     col = paste0(col_sample, \"80\"),     peakCol = col_sample[chromPeaks(eic_cystine)[, \"sample\"]],     peakBg = paste0(col_sample[chromPeaks(eic_cystine)[, \"sample\"]], 20),     peakPch = 16) #' Define parameters of choice subset <- which(sampleData(lcms1)$phenotype == \"QC\") param <- PeakGroupsParam(minFraction = 0.9, extraPeaks = 50, span = 0.5,                          subsetAdjust = \"average\",                          subset = subset)  #' Perform the alignment lcms1 <- adjustRtime(lcms1, param = param) #' Visualize alignment results plotAdjustedRtime(lcms1, col = paste0(col_sample, 80), peakGroupsPch = 1) grid() legend(\"topright\", col = col_phenotype,        legend = names(col_phenotype), lty = 1, bty = \"n\") #' Get data before alignment lcms1_raw <- dropAdjustedRtime(lcms1)  #' Apply the adjusted retention time to our dataset lcms1 <- applyAdjustedRtime(lcms1) #' Plot the BPC before and after alignment par(mfrow = c(2, 1), mar = c(2, 1, 1, 0.5)) chromatogram(lcms1_raw, aggregationFun = \"max\", chromPeaks = \"none\") |>     plot(main = \"BPC before alignment\", col = paste0(col_sample, 80)) grid() legend(\"topright\", col = col_phenotype,        legend = names(col_phenotype), lty = 1, bty = \"n\", horiz = TRUE)  chromatogram(lcms1, aggregationFun = \"max\", chromPeaks = \"none\") |>     plot(main = \"BPC after alignment\",          col = paste0(col_sample, 80)) grid() legend(\"topright\", col = col_phenotype,        legend = names(col_phenotype), lty = 1, bty = \"n\", horiz = TRUE) #' Extract the EICs for the test ions before alignment old_eic_cystine <- eic_is[\"cystine_13C_15N\"] old_eic_met <- eic_is[\"methionine_13C_15N\"]  #' Update the EICs eic_is <- chromatogram(lcms1,                        rt = as.matrix(intern_standard[, c(\"rtmin\", \"rtmax\")]),                        mz = as.matrix(intern_standard[, c(\"mzmin\", \"mzmax\")])) fData(eic_is) <- fdata  #' Extract the EICs for the test ions eic_cystine <- eic_is[\"cystine_13C_15N\"] eic_met <- eic_is[\"methionine_13C_15N\"] par(mfrow = c(2, 2), mar = c(4, 4.5, 2, 1))  plot(old_eic_cystine, main = \"Cystine before alignment\", peakType = \"none\",      col = paste0(col_sample, 80)) grid() abline(v = intern_standard[\"cystine_13C_15N\", \"RT\"], col = \"red\", lty = 3)  plot(old_eic_met, main = \"Methionine before alignment\",      peakType = \"none\", col = paste0(col_sample, 80)) grid() abline(v = intern_standard[\"methionine_13C_15N\", \"RT\"], col = \"red\", lty = 3)  plot(eic_cystine, main = \"Cystine after alignment\", peakType = \"none\",      col = paste0(col_sample, 80)) grid() abline(v = intern_standard[\"cystine_13C_15N\", \"RT\"], col = \"red\", lty = 3) legend(\"topright\", col = col_phenotype,        legend = names(col_phenotype), lty = 1, bty = \"n\")  plot(eic_met, main = \"Methionine after alignment\",      peakType = \"none\", col = paste0(col_sample, 80)) grid() abline(v = intern_standard[\"methionine_13C_15N\", \"RT\"], col = \"red\", lty = 3) #' Extract the matrix with all chromatographic peaks and add a column #' with the ID of the chromatographic peak chrom_peaks <- chromPeaks(lcms1) |> as.data.frame() chrom_peaks$peak_id <- rownames(chrom_peaks)  #' Define the parameters for the matching and filtering of the matches p_1 <- MzRtParam(ppm = 50, toleranceRt = 10) p_2 <- SingleMatchParam(duplicates = \"top_ranked\", column = \"target_maxo\",                         decreasing = TRUE)  #' Iterate over samples and identify for each the chromatographic peaks #' with similar m/z and retention time than the onse from the internal #' standard, and extract among them the ID of the peaks with the #' highest intensity. intern_standard_peaks <- lapply(seq_along(lcms1), function(i) {     tmp <- chrom_peaks[chrom_peaks[, \"sample\"] == i, , drop = FALSE]     mtch <- matchValues(intern_standard, tmp,                         mzColname = c(\"mz\", \"mz\"),                         rtColname = c(\"RT\", \"rt\"),                         param = p_1)     mtch <- filterMatches(mtch, p_2)     mtch$target_peak_id }) |>     do.call(what = cbind) #' Define the index of the selected chromatographic peaks in the #' full chromPeaks matrix idx <- match(intern_standard_peaks, rownames(chromPeaks(lcms1)))  #' Extract the raw retention times for these rt_raw <- chromPeaks(lcms1_raw)[idx, \"rt\"] |>     matrix(ncol = length(lcms1_raw))  #' Extract the adjusted retention times for these rt_adj <- chromPeaks(lcms1)[idx, \"rt\"] |>     matrix(ncol = length(lcms1_raw)) list(all_raw = rowSds(rt_raw, na.rm = TRUE),      all_adj = rowSds(rt_adj, na.rm = TRUE)      ) |>     vioplot() grid()"},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/a-end-to-end-untargeted-metabolomics.html","id":"correspondence","dir":"Articles","previous_headings":"","what":"Correspondence","title":"Complete end-to-end LC-MS/MS Metabolomic Data analysis","text":"briefly touched subject correspondence determine anchor peaks alignment. Generally, goal correspondence analysis identify chromatographic peaks originate types ions samples experiment group LC-MS features. point, proper configuration parameter bw crucial. illustrate sensible choices parameter’s value can made. use plotChromPeakDensity() function simulate correspondence analysis default values PeakGroups extracted ion chromatograms two selected isotope labeled ions. plot shows EIC top panel, apex position chromatographic peaks different samples (y-axis), along retention time (x-axis) lower panel.  Figure 16. Initial correspondence analysis, Cystine.  Figure 17. Initial correspondence analysis, Methionine. Grouping peaks depends smoothness previousl mentionned density curve can configured parameter bw. seen , smoothness high properly group features. looking default parameters, can observe indeed, bw parameter set bw = 30, high modern UHPLC-MS setups. reduce value parameter 1.8 evaluate impact.  Figure 18. Correspondence analysis optimized parameters, Cystine.  Figure 19. Correspondence analysis optimized parameters, Methionine. can observe peaks now grouped accurately single feature test ion. important parameters optimized : binsize: data generated high resolution MS instrument, thus select low value paramete. ppm: TOF instruments, suggested use value ppm larger 0 accommodate higher measurement error instrument larger m/z values. minFraction: set minFraction = 0.75, hence defining features chromatographic peak identified least 75% samples one sample groups. sampleGroups: use information available sampleData’s \"phenotype\" column. Note parameter also accept factors, therefore complicated groupings can performed wanted. correspondence analysis suggested evaluate results selected EICs. extract signal m/z similar isotope labeled methionine larger retention time range. Importantly, show actual correspondence results, set simulate = FALSE plotChromPeakDensity() function.  Figure 20. Correspondence analysis results, Methionine. hoped, signal two different ions now grouped separate features. Generally, correspondence results evaluated extracted chromatograms. Another interesting information look distribution features along retention time axis. results correspondence analysis now stored, along results preprocessing steps, within XcmsExperiment result object. correspondence results, .e., definition LC-MS features, can extracted using featureDefinitions() function. data frame provides average m/z retention time (columns \"mzmed\" \"rtmed\") characterize LC-MS feature. Column, \"peakidx\" contains indices chromatographic peaks assigned feature. actual abundances features, represent also final preprocessing results, can extracted featureValues() function: can note features (e.g. F0003 F0006) missing values samples. expected certain degree samples features, respectively ions, need present. address next section.","code":"#' Default parameter for the grouping and apply them to the test ions BPC param <- PeakDensityParam(sampleGroups = sampleData(lcms1)$phenotype, bw = 30)  param Object of class:  PeakDensityParam  Parameters:  - sampleGroups:  [1] \"QC\"  \"CVD\" \"CTR\" \"QC\"  \"CTR\" \"CVD\" \"QC\"  \"CTR\" \"CVD\" \"QC\"  - bw: [1] 30  - minFraction: [1] 0.5  - minSamples: [1] 1  - binSize: [1] 0.25  - maxFeatures: [1] 50  - ppm: [1] 0 plotChromPeakDensity(     eic_cystine, param = param,     col = paste0(col_sample, \"80\"),     peakCol = col_sample[chromPeaks(eic_cystine)[, \"sample\"]],     peakBg = paste0(col_sample[chromPeaks(eic_cystine)[, \"sample\"]], 20),     peakPch = 16) plotChromPeakDensity(eic_met, param = param,     col = paste0(col_sample, \"80\"),     peakCol = col_sample[chromPeaks(eic_met)[, \"sample\"]],     peakBg = paste0(col_sample[chromPeaks(eic_met)[, \"sample\"]], 20),     peakPch = 16) #' Updating parameters param <- PeakDensityParam(sampleGroups = sampleData(lcms1)$phenotype, bw = 1.8)  plotChromPeakDensity(     eic_cystine, param = param,     col = paste0(col_sample, \"80\"),     peakCol = col_sample[chromPeaks(eic_cystine)[, \"sample\"]],     peakBg = paste0(col_sample[chromPeaks(eic_cystine)[, \"sample\"]], 20),     peakPch = 16) plotChromPeakDensity(eic_met, param = param,     col = paste0(col_sample, \"80\"),     peakCol = col_sample[chromPeaks(eic_met)[, \"sample\"]],     peakBg = paste0(col_sample[chromPeaks(eic_met)[, \"sample\"]], 20),     peakPch = 16) #' Define the settings for the param param <- PeakDensityParam(sampleGroups = sampleData(lcms1)$phenotype,                           minFraction = 0.75, binSize = 0.01, ppm = 10,                           bw = 1.8)  #' Apply to whole data lcms1 <- groupChromPeaks(lcms1, param = param) #' Extract chromatogram for an m/z similar to the one of the labeled methionine chr_test <- chromatogram(lcms1,                          mz = as.matrix(intern_standard[\"methionine_13C_15N\",                                                         c(\"mzmin\", \"mzmax\")]),                          rt = c(145, 200),                          aggregationFun = \"max\") plotChromPeakDensity(     chr_test, simulate = FALSE,     col = paste0(col_sample, \"80\"),     peakCol = col_sample[chromPeaks(chr_test)[, \"sample\"]],     peakBg = paste0(col_sample[chromPeaks(chr_test)[, \"sample\"]], 20),     peakPch = 16) # Bin features per RT slices vc <- featureDefinitions(lcms1)$rtmed breaks <- seq(0, max(vc, na.rm = TRUE) + 1, length.out = 15) |>     round(0) cuts <- cut(vc, breaks = breaks, include.lowest = TRUE)  table(cuts) cuts    [0,17]   (17,34]   (34,51]   (51,68]   (68,86]  (86,103] (103,120] (120,137]        15      2608       649        24       132        11        15       105 (137,154] (154,171] (171,188] (188,205] (205,222] (222,240]      1441      2202       410       869       554        33 #' Definition of the features featureDefinitions(lcms1) |>   head() mzmed    mzmin    mzmax    rtmed    rtmin    rtmax npeaks CTR CVD QC FT0001 50.98979 50.98949 50.99038 203.6001 203.1181 204.2331      8   1   3  4 FT0002 51.05904 51.05880 51.05941 191.1675 190.8787 191.5050      9   2   3  4 FT0003 51.98657 51.98631 51.98699 203.1467 202.6406 203.6710      7   0   3  4 FT0004 53.02036 53.02009 53.02043 203.2343 202.5652 204.0901     10   3   3  4 FT0005 53.52080 53.52051 53.52102 203.1936 202.8490 204.0901     10   3   3  4 FT0006 54.01007 54.00988 54.01015 159.2816 158.8499 159.4484      6   1   3  2             peakidx ms_level FT0001 7702, 16....        1 FT0002 7176, 16....        1 FT0003 7680, 17....        1 FT0004 7763, 17....        1 FT0005 8353, 17....        1 FT0006 5800, 15....        1 #' Extract feature abundances featureValues(lcms1, method = \"sum\") |>     head() MS_QC_POOL_1_POS.mzML MS_A_POS.mzML MS_B_POS.mzML MS_QC_POOL_2_POS.mzML FT0001              421.6162      689.2422            NA              481.7436 FT0002              710.8078      875.9192            NA              693.6997 FT0003              445.5711      613.4410            NA              497.8866 FT0004            16994.5260    24605.7340     19766.707            17808.0933 FT0005             3284.2664     4526.0531      3521.822             3379.8909 FT0006            10681.7476    10009.6602            NA            10800.5449        MS_C_POS.mzML MS_D_POS.mzML MS_QC_POOL_3_POS.mzML MS_E_POS.mzML FT0001            NA      635.2732              439.6086      570.5849 FT0002      781.2416      648.4344              700.9716     1054.0207 FT0003            NA      634.9370              449.0933            NA FT0004    22780.6683    22873.1061            16965.7762    23432.1252 FT0005     4396.0762     4317.7734             3270.5290     4533.8667 FT0006            NA     7296.4262                    NA     9236.9799        MS_F_POS.mzML MS_QC_POOL_4_POS.mzML FT0001      579.9360              437.0340 FT0002      534.4577              711.0361 FT0003      461.0465              232.1075 FT0004    22198.4607            16796.4497 FT0005     4161.0132             3142.2268 FT0006     6817.8785                    NA"},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/a-end-to-end-untargeted-metabolomics.html","id":"gap-filling","dir":"Articles","previous_headings":"","what":"Gap filling","title":"Complete end-to-end LC-MS/MS Metabolomic Data analysis","text":"previously observed missing values (NA) attributed various reasons. Although might represent genuinely missing value, indicating ion (feature) truly present particular sample, also result failure preceding chromatographic peak detection step. crucial able recover missing values latter category much possible reduce eventual need data imputation. next examine prevalent missing values present dataset: can observe substantial number missing values values dataset. Let’s therefore delve process gap-filling. first evaluate example features chromatographic peak detected samples:  Figure 21. Examples chromatographic peaks missing values. instances, chromatographic peak identified one two selected samples (red line), hence missing value reported feature particular samples (blue line). However, cases, signal measured samples, thus, reporting missing value correct example. signal feature low, likely reason peak detection failed. rescue signal cases, fillChromPeaks() function can used ChromPeakAreaParam approach. method defines m/z-retention time area feature based detected peaks, signal respective ion expected. integrates intensities within area samples missing values feature. reported feature abundance. apply method using default parameters. fillChromPeaks() thus rescue missing data data set. Note , even sample ion present, worst case noise integrated, expected much lower actual chromatographic peak signal. Let’s look previously missing values :  Figure 22. Examples chromatographic peaks missing values gap-filling. gap-filling, also blue colored sample chromatographic peak present peak area reported feature abundance sample. assess effectiveness gap-filling method rescuing signals, can also plot average signal features least one missing value average filled-signal. advisable perform analysis repeatedly measured samples; case, QC samples used. , extract: Feature values detected chromatographic peaks setting filled = FALSE featuresValues() call. filled-signal first extracting detected gap-filled abundances replace values detected chromatographic peaks NA. , calculate row averages matrices plot .  Figure 23. Detected vs. filled-signal. detected (x-axis) gap-filled (y-axis) values QC samples highly correlated. Especially higher abundances, agreement high, low intensities, can expected, differences higher trending correlation line. , addition, fit linear regression line data summarize results linear regression line slope 1.12 intercept -1.62. indicates filled-signal average 1.12 times higher detected signal.","code":"#' Percentage of missing values sum(is.na(featureValues(lcms1))) /     length(featureValues(lcms1)) * 100 [1] 26.41597 ftidx <- which(is.na(rowSums(featureValues(lcms1)))) fts <- rownames(featureDefinitions(lcms1))[ftidx] farea <- featureArea(lcms1, features = fts[1:2])  chromatogram(lcms1[c(2, 3)],              rt = farea[, c(\"rtmin\", \"rtmax\")],              mz = farea[, c(\"mzmin\", \"mzmax\")]) |>     plot(col = c(\"red\", \"blue\"), lwd = 2) #' Fill in the missing values in the whole dataset lcms1 <- fillChromPeaks(lcms1, param = ChromPeakAreaParam(), chunkSize = 5)  #' Percentage of missing values after gap-filling sum(is.na(featureValues(lcms1))) /     length(featureValues(lcms1)) * 100 [1] 5.155492 #' Get only detected signal in QC samples vals_detect <- featureValues(lcms1, filled = FALSE)[, QC_samples]  #' Get detected and filled-in signal vals_filled <- featureValues(lcms1)[, QC_samples]  #' Replace detected signal with NA vals_filled[!is.na(vals_detect)] <- NA  #' Identify features with at least one filled peak has_filled <- is.na(rowSums(vals_detect))  #' Calculate row averages for features with missing values avg_detect <- rowMeans(vals_detect[has_filled, ], na.rm = TRUE) avg_filled <- rowMeans(vals_filled[has_filled, ], na.rm = TRUE)  #' Plot the values against each other (in log2 scale) plot(log2(avg_detect), log2(avg_filled),      xlim = range(log2(c(avg_detect, avg_filled)), na.rm = TRUE),      ylim = range(log2(c(avg_detect, avg_filled)), na.rm = TRUE),      pch = 21, bg = \"#00000020\", col = \"#00000080\") grid() abline(0, 1) #' fit a linear regression line to the data l <- lm(log2(avg_filled) ~ log2(avg_detect)) summary(l) Call: lm(formula = log2(avg_filled) ~ log2(avg_detect))  Residuals:     Min      1Q  Median      3Q     Max -6.8176 -0.3807  0.1725  0.5492  6.7504  Coefficients:                  Estimate Std. Error t value Pr(>|t|) (Intercept)      -1.62359    0.11545  -14.06   <2e-16 *** log2(avg_detect)  1.11763    0.01259   88.75   <2e-16 *** --- Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1  Residual standard error: 0.9366 on 2846 degrees of freedom   (846 observations deleted due to missingness) Multiple R-squared:  0.7346,    Adjusted R-squared:  0.7345 F-statistic:  7877 on 1 and 2846 DF,  p-value: < 2.2e-16"},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/a-end-to-end-untargeted-metabolomics.html","id":"filtering-features-missing-values","dir":"Articles","previous_headings":"","what":"Filtering Features: Missing values","title":"Complete end-to-end LC-MS/MS Metabolomic Data analysis","text":"now restrict data set features chromatographic peak detected least 2/3 samples least one study samples groups. ensures statistical tests carried later study samples performed reliable signal. Also, filter remove features mostly detected QC samples, study samples. filter can performed filterFeatures() function xcms package PercentMissingFilter setting. parameters filer: threshold: defines maximal acceptable percentage samples missing value(s) least one sample groups defined parameter f. f: factor defining sample groups. replacing \"QC\" sample group NA parameter f exclude QC samples evaluation consider study samples. threshold = 40 keep features peak detected 2 3 samples one sample groups. consider detected chromatographic peaks per sample, apply filter \"raw\" assay result object, contains abundance values detected chromatographic peaks (prior gap-filling).","code":"#' Limit features to those with at least two detected peaks in one study group. #' Setting the value for QC samples to NA excludes QC samples from the #' calculation. f <- sampleData(lcms1)$phenotype f[f == \"QC\"] <- NA f <- as.factor(f) lcms1 <- filterFeatures(lcms1, PercentMissingFilter(f = f, threshold = 40)) 344 features were removed"},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/a-end-to-end-untargeted-metabolomics.html","id":"preprocessing-results","dir":"Articles","previous_headings":"","what":"Preprocessing results","title":"Complete end-to-end LC-MS/MS Metabolomic Data analysis","text":"final results LC-MS data preprocessing stored within XcmsExperiment object. includes identified chromatographic peaks, alignment results, well correspondence results. addition, guarantee reproducibility, result object keeps track performed processing steps, including individual parameter objects used configure . processHistory() function returns list various applied processing steps chronological order. , extract information first step performed preprocessing. processParam() function used extract actual parameter class used configure processing step. final result whole LC-MS data preprocessing two-dimensional matrix abundances -called LC-MS features samples. Note stage analysis features characterized m/z retention time don’t yet information metabolite feature represent. seen , feature matrix can extracted featureValues() function corresponding feature characteristics (.e., m/z retention time values) using featureDefinitions() function. Thus, two arrays extracted xcms result object used/imported analysis packages processing. example also exported tab delimited text files, used external tool, used, also MS2 spectra available, feature-based molecular networking GNPS analysis environment (Nothias et al. 2020). processing R, reference link raw MS data required, suggested extract xcms preprocessing result using quantify() function SummarizedExperiment object, Bioconductor’s default container data biological assays/experiments. simplifies integration Bioconductor analysis packages. quantify() function takes parameters featureValues() function, thus, call extract SummarizedExperiment detected, gap-filled, feature abundances: Sample identifications xcms result’s sampleData() now available colData() (column, sample annotations) featureDefinitions() rowData() (row, feature annotations). feature values added first assay() SummarizedExperiment even processing history available object’s metadata(). SummarizedExperiment supports multiple assays, numeric matrices dimensions. thus add detected gap-filled feature abundances additional assay SummarizedExperiment. Feature abundances can extracted assay() function. extract first 6 lines detected gap-filled feature abundances: advantage, addition container full preprocessing results also possibility easy intuitive creation data subsets ensuring data integrity. example easy subset full data selection features /samples: moving next step analysis, advisable save preprocessing results. multiple format options save , can found MsIO package documentation. save XcmsExperiment object file format handled alabster framework, ensures object can easily read languages like Python Javascript well loaded easily back R.","code":"#' Check first step of the process history processHistory(lcms1)[[1]] Object of class \"XProcessHistory\"  type: Peak detection  date: Wed Jul 16 07:15:06 2025  info:  fileIndex: 1,2,3,4,5,6,7,8,9,10  Parameter class: CentWaveParam  MS level(s) 1 #' Extract results as a SummarizedExperiment res <- quantify(lcms1, method = \"sum\", filled = FALSE) res class: SummarizedExperiment dim: 8724 10 metadata(7): '' '' ... '' '' assays(1): raw rownames(8724): FT0001 FT0002 ... FT9067 FT9068 rowData names(11): mzmed mzmin ... QC ms_level colnames(10): MS_QC_POOL_1_POS.mzML MS_A_POS.mzML ... MS_F_POS.mzML   MS_QC_POOL_4_POS.mzML colData names(11): sample_name derived_spectra_data_file ... phenotype   injection_index assays(res)$raw_filled <- featureValues(lcms1, method = \"sum\",                                         filled = TRUE )  #' Different assay in the SummarizedExperiment object assayNames(res) [1] \"raw\"        \"raw_filled\" assay(res, \"raw_filled\") |> head() MS_QC_POOL_1_POS.mzML MS_A_POS.mzML MS_B_POS.mzML MS_QC_POOL_2_POS.mzML FT0001              421.6162      689.2422      411.3295              481.7436 FT0002              710.8078      875.9192      457.5920              693.6997 FT0003              445.5711      613.4410      277.5022              497.8866 FT0004            16994.5260    24605.7340    19766.7069            17808.0933 FT0005             3284.2664     4526.0531     3521.8221             3379.8909 FT0006            10681.7476    10009.6602     9599.9701            10800.5449        MS_C_POS.mzML MS_D_POS.mzML MS_QC_POOL_3_POS.mzML MS_E_POS.mzML FT0001      314.7567      635.2732              439.6086      570.5849 FT0002      781.2416      648.4344              700.9716     1054.0207 FT0003      425.3774      634.9370              449.0933      556.2544 FT0004    22780.6683    22873.1061            16965.7762    23432.1252 FT0005     4396.0762     4317.7734             3270.5290     4533.8667 FT0006     4792.2390     7296.4262             2382.1788     9236.9799        MS_F_POS.mzML MS_QC_POOL_4_POS.mzML FT0001      579.9360              437.0340 FT0002      534.4577              711.0361 FT0003      461.0465              232.1075 FT0004    22198.4607            16796.4497 FT0005     4161.0132             3142.2268 FT0006     6817.8785             6911.5439 res[1:14, 3:8] class: SummarizedExperiment dim: 14 6 metadata(7): '' '' ... '' '' assays(2): raw raw_filled rownames(14): FT0001 FT0002 ... FT0013 FT0014 rowData names(11): mzmed mzmin ... QC ms_level colnames(6): MS_B_POS.mzML MS_QC_POOL_2_POS.mzML ...   MS_QC_POOL_3_POS.mzML MS_E_POS.mzML colData names(11): sample_name derived_spectra_data_file ... phenotype   injection_index #' XcmsExperiment object:  saveMsObject(lcms1,              AlabasterParam(path = file.path(\"objects/preprocessed_lcms1\")))  #' Below we remove the processHistory of the res object to allow for export. metadata(res) <- list() saveObject(res, file.path(\"objects/preprocessed_res\"))"},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/a-end-to-end-untargeted-metabolomics.html","id":"data-normalization","dir":"Articles","previous_headings":"","what":"Data normalization","title":"Complete end-to-end LC-MS/MS Metabolomic Data analysis","text":"preprocessing, data normalization scaling might need applied remove technical variances data. simple approaches like median scaling can implemented lines R code, advanced normalization algorithms available packages Bioconductor’s preprocessCore. comprehensive workflow “Notame” also propose interesting normalization approach adaptable scalable user dataset (Klåvus et al. 2020). Generally, LC-MS data, bias can categorized three main groups(Broadhurst et al. 2018): Variances introduced sample collection initial processing, can include differences sample amounts. type bias expected sample-specific affect signals sample way. Methods like median scaling, LOESS quantiles normalization can adjust bias. Signal drifts along measurement samples experiment. Reasons drifts can related aging instrumentation used (columns, detector), also changes metabolite abundances characteristics due reactions modifications, oxidation. changes expected affect samples measured later run rather ones measured beginning. reason, bias can play major role large experiments bias can play major role large experiments measured long time range usually considered affect individual metabolites (metabolite groups) differently. adjustment, moving average linear regression-based approaches can used. latter can example performed using adjust_lm() function MetaboCoreUtils package. Batch-related biases. comprise noise specific larger set samples, can set samples measured one LC-MS measurement run (.e. one analysis plate) samples measured using specific batch reagents. noise assumed affect samples one batch way linear modeling-based approaches can used adjust . Unwanted variation can arise various sources highly dependent experiment. Therefore, data normalization chosen carefully based experimental design, statistical aims, balance accuracy precision achieved use auxiliary information. Sample preparation biases can evaluated using internal standards, depending however also added sample mixes sample processing. Repeated measurements QC samples hand allows estimate correct LC-MS specific biases. Also, proper planning experiment, measurement study samples random order, can largely avoid biases introduced mentioned sources variance. workflow present tools assess data quality evaluate need normalization well options normalization. space reasons able provide solutions adjust possible sources variation. principal component analysis (PCA) helpful tool initial, unsupervised, visualization data also provides insights potential quality issues data. order apply PCA measured feature abundances, need however impute (still present) missing values. assume missing values (gap-filling step) represent signal detection limit. cases, missing values can replaced random values sampled uniform distribution, ranging half smallest measured value smallest measured value specific feature. uniform distribution defined two parameters (minimum maximum) values equal probability selected. impute missing values approach add resulting data matrix new assay result object. PCA powerful tool detecting biases data. dimensionality reduction technique, enables visualization data lower-dimensional space. context LC-MS data, PCA can used identify overall biases batch, sample, injection index, etc. However, important note PCA linear method may able detect biases data. plotting PCA, apply log2 transform, center scale data. log2 transformation applied stabilize variance centering remove dependency absolute abundances.  Figure 24. PCA data coloured phenotypes. PCA shows clear separation study samples (plasma) QC samples (serum) first principal component (PC1). separation based phenotype visible third principal component (PC3). cases, can better option remove imputed values evaluate PCA . especially true imputed values replacing large proportion data. Global differences feature abundances samples (e.g. due sample-specific biases) can evaluated plotting distribution log2 transformed feature abundances using boxplots violin plots. show number detected chromatographic peaks per sample distribution log2 transformed feature abundances.  Figure 25. Number detected peaks feature abundances. upper part plot show gap filling steps allowed rescue substantial number NAs allowed us consistent number feature values per sample. consistency aligns asspumption every sample similar amount features detected. Additionally observe , average, signal distribution individual samples similar. alternative way evaluate differences abundances samples relative log abundance (RLA) plots (De Livera et al. 2012). RLA value abundance feature sample relative median abundance feature across multiple samples. can discriminate within group across group RLAs, depending whether abundance compared samples within sample group across samples. Within group RLA plots assess tightness replicates within groups median close zero low variation around . used across groups, allow compare behavior groups. Generally, -sample differences can easily spotted using RLA plots. calculate visualize within group RLA values using rowRla() function MsCoreUtils package defining parameter f sample groups.  Figure 26. RLA plot raw data filled data. RLA plot , can observe medians samples indeed centered around 0. Exception two CVD samples. Thus, distribution signals across samples comparable, differences seem present require sample normalization. previous RLA plot showed data biases need corrected. Therefore, implement -sample normalization using filled-features. process effectively mitigates variations influenced technical issues, differences sample preparation, processing injection methods. instance, employ commonly used technique known median scaling (De Livera et al. 2012). method involves computing median sample, followed determining median individual sample medians. ensures consistent median values sample throughout entire data set. Maintaining uniformity average total metabolite abundance across samples crucial effective implementation. process aims establish shared baseline central tendency metabolite abundance, mitigating impact sample-specific technical variations. approach fosters robust comparable analysis top features across data set. assumption normalizing based median, known lower sensitivity extreme values, enhances comparability top features ensures consistent average abundance across samples. median scaling calculated imputed non-imputed data, set stored separately within SummarizedExperiment object. approach facilitates testing various normalization strategies maintaining record processing steps undertaken, enabling easy regression previous stages necessary. crucial evaluate effectiveness normalization process. can achieved comparing distribution log2 transformed feature abundances normalization. Additionally, RLA plots can used assess tightness replicates within groups compare behavior groups.  Figure 27. PC1 PC2 data normalization. Normalization large impact PC1 PC2, separation study groups PC3 seems better difference QC samples lower normalization (see ).  Figure 28. PC3 PC4 data normalization. PCA plots show normalization process changed overall structure data. separation study QC samples remains . expected results normalization correct biological variance technical. compare RLA plots -sample normalization evaluate impact data.  Figure 29. RLA plot normalization. normalization process effectively centered data around median medians samples now closer zero. next evaluate coefficient variation (CV, also referred relative standard deviation RSD) features across samples either QC study samples. QC samples, CV represent technical noise, study samples include also expected biological differences. Thus, normalization reduce CV QC samples, slightly reducing CV study samples. CV calculated using rowRsd() function MetaboCoreUtils package. setting mad = TRUE use robust calculation using median absolute deviation instead standard deviation. Table 6. Distribution CV values across samples raw normalized data. table shows distribution CV raw normalized data. first column highlights % data given CV value, e.g. 25% data CV equal lower 0.04557 QC_raw data. anticipated, CV values QCs, reflect technical variance, lower compared study samples, include technical biological variance. Overall, minimal disparity exists raw normalized data, positive indication normalization process introduced bias dataset, also reflects little differences average abundances sample raw data. overall conclusion normalization process little variance present beginning, normalization however able center data around median (shown RLA plot). Given simplicity limited size example dataset, conclude normalization process stage. intricate datasets diverse biases, tailored approach devised. include also approaches adjust signal drifts batch effects. One possible option use linear-model based approach can example applied adjust_lm() function MetaboCoreUtils package.","code":"#' Impute missing values using an uniform distribution na_unidis <- function(z) {     na <- is.na(z)     if (any(na)) {         min = min(z, na.rm = TRUE)         z[na] <- runif(sum(na), min = min/2, max = min)     }     z }  #' Row-wise impute missing values and add the data as a new assay tmp <- apply(assay(res, \"raw_filled\"), MARGIN = 1, na_unidis) assays(res)$raw_filled_imputed <- t(tmp) #' Log2 transform and scale data vals <- assay(res, \"raw_filled_imputed\") |>     log2() |>     t() |>     scale(center = TRUE, scale = TRUE)  #' Perform the PCA pca_res <- prcomp(vals, scale = FALSE, center = FALSE)  #' Plot the results vals_st <- cbind(vals, phenotype = res$phenotype) pca_12 <- autoplot(pca_res, data = vals_st , colour = 'phenotype', scale = 0) +     scale_color_manual(values = col_phenotype) pca_34 <- autoplot(pca_res, data = vals_st, colour = 'phenotype',                    x = 3, y = 4, scale = 0) +     scale_color_manual(values = col_phenotype) grid.arrange(pca_12, pca_34, ncol = 1) layout(mat = matrix(1:3, ncol = 1), height = c(0.2, 0.2, 0.8))  par(mar = c(0.2, 4.5, 0.2, 3)) barplot(apply(assay(res, \"raw\"), MARGIN = 2, function(x) sum(!is.na(x))),         col = paste0(col_sample, 80), border = col_sample,         ylab = \"# detected peaks\", xaxt = \"n\", space = 0.012) grid(nx = NA, ny = NULL) barplot(apply(assay(res, \"raw_filled\"), MARGIN = 2, function(x) sum(!is.na(x))),         col = paste0(col_sample, 80), border = col_sample,         ylab = \"# detected + filled peaks\", xaxt = \"n\",         space = 0.012) grid(nx = NA, ny = NULL) vioplot(log2(assay(res, \"raw_filled\")), xaxt = \"n\",         ylab = expression(log[2]~feature~abundance),         col = paste0(col_sample, 80), border = col_sample) points(colMedians(log2(assay(res, \"raw_filled\")), na.rm = TRUE), type = \"b\",        pch = 1) grid(nx = NA, ny = NULL) legend(\"topright\", col = col_phenotype,        legend = names(col_phenotype), lty=1, lwd = 2, xpd = TRUE, ncol = 3,        cex = 0.8,  bty = \"n\") par(mfrow = c(1, 1), mar = c(3.5, 4.5, 2.5, 1)) boxplot(MsCoreUtils::rowRla(assay(res, \"raw_filled\"),                             f = res$phenotype, transform = \"log2\"),         cex = 0.5, pch = 16,         col = paste0(col_sample, 80), ylab = \"RLA\",         border = col_sample, boxwex = 1,         outline = FALSE, xaxt = \"n\", main = \"Relative log abundance\",         cex.main = 1) axis(side = 1, at = seq_len(ncol(res)), labels = colData(res)$sample_name) grid(nx = NA, ny = NULL) abline(h = 0, lty=3, lwd = 1, col = \"black\") legend(\"topright\", col = col_phenotype,        legend = names(col_phenotype), lty=1, lwd = 2, xpd = TRUE, ncol = 3,        cex = 0.8,  bty = \"n\") #' Compute median and generate normalization factor mdns <- apply(assay(res, \"raw_filled\"), MARGIN = 2,               median, na.rm = TRUE ) nf_mdn <- mdns / median(mdns)  #' divide dataset by median of median and create a new assay. assays(res)$norm <- sweep(assay(res, \"raw_filled\"), MARGIN = 2, nf_mdn, '/') assays(res)$norm_imputed <- sweep(assay(res, \"raw_filled_imputed\"), MARGIN = 2,                                   nf_mdn, '/') #' Data before normalization vals_st <- cbind(vals, phenotype = res$phenotype) pca_raw <- autoplot(pca_res, data = vals_st,                     colour = 'phenotype', scale = 0) +     scale_color_manual(values = col_phenotype)  #' Data after normalization vals_norm <- apply(assay(res, \"norm\"), MARGIN = 1, na_unidis) |>     log2() |>     scale(center = TRUE, scale = TRUE)  pca_res_norm <- prcomp(vals_norm, scale = FALSE, center = FALSE) vals_st_norm <- cbind(vals_norm, phenotype = res$phenotype) pca_adj <- autoplot(pca_res_norm, data = vals_st_norm,                     colour = 'phenotype', scale = 0) +     scale_color_manual(values = col_phenotype)  grid.arrange(pca_raw, pca_adj, ncol = 1) pca_raw <- autoplot(pca_res, data = vals_st ,                     colour = 'phenotype', x = 3, y = 4, scale = 0) +     scale_color_manual(values = col_phenotype) pca_adj <- autoplot(pca_res_norm, data = vals_st_norm,                     colour = 'phenotype', x = 3, y = 4, scale = 0) +     scale_color_manual(values = col_phenotype)  grid.arrange(pca_raw, pca_adj, ncol = 1) par(mfrow = c(2, 1), mar = c(3.5, 4.5, 2.5, 1))  boxplot(rowRla(assay(res, \"raw_filled\"), group = res$phenotype),         cex = 0.5, pch = 16, ylab = \"RLA\", border = col_sample,         col = paste0(col_sample, 80), cex.main = 1, outline = FALSE,         xaxt = \"n\", main = \"Raw data\", boxwex = 1) grid(nx = NA, ny = NULL) legend(\"topright\", inset = c(0, -0.2), col = col_phenotype,        legend = names(col_phenotype), lty=1, lwd = 2, xpd = TRUE,        ncol = 3, cex = 0.7, bty = \"n\") abline(h = 0, lty=3, lwd = 1, col = \"black\")  boxplot(rowRla(assay(res, \"norm\"), group = res$phenotype),         cex = 0.5, pch = 16, ylab = \"RLA\", border = col_sample,         col = paste0(col_sample, 80), boxwex = 1, outline = FALSE,         xaxt = \"n\", main = \"Normallized data\", cex.main = 1) axis(side = 1, at = seq_len(ncol(res)), labels = res$sample_name) grid(nx = NA, ny = NULL) abline(h = 0, lty = 3, lwd = 1, col = \"black\") #' Calculate the CV values index_study <- res$phenotype %in% c(\"CTR\", \"CVD\") index_QC <- res$phenotype == \"QC\"  sample_res <- cbind(     QC_raw = rowRsd(assay(res, \"raw_filled\")[, index_QC],                     na.rm = TRUE, mad = TRUE),     QC_norm = rowRsd(assay(res, \"norm\")[, index_QC],                      na.rm = TRUE, mad = TRUE),     Study_raw = rowRsd(assay(res, \"raw_filled\")[, index_study],                        na.rm = TRUE, mad = TRUE),     Study_norm = rowRsd(assay(res, \"norm\")[, index_study],                         na.rm = TRUE, mad = TRUE) )  #' Summarize the values across features res_df <- data.frame(     QC_raw = quantile(sample_res[, \"QC_raw\"], na.rm = TRUE),     QC_norm = quantile(sample_res[, \"QC_norm\"], na.rm = TRUE),     Study_raw = quantile(sample_res[, \"Study_raw\"], na.rm = TRUE),     Study_norm = quantile(sample_res[, \"Study_norm\"], na.rm = TRUE) )  kable(res_df, format = \"pipe\")"},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/a-end-to-end-untargeted-metabolomics.html","id":"initial-quality-assessment","dir":"Articles","previous_headings":"","what":"Initial quality assessment","title":"Complete end-to-end LC-MS/MS Metabolomic Data analysis","text":"principal component analysis (PCA) helpful tool initial, unsupervised, visualization data also provides insights potential quality issues data. order apply PCA measured feature abundances, need however impute (still present) missing values. assume missing values (gap-filling step) represent signal detection limit. cases, missing values can replaced random values sampled uniform distribution, ranging half smallest measured value smallest measured value specific feature. uniform distribution defined two parameters (minimum maximum) values equal probability selected. impute missing values approach add resulting data matrix new assay result object. PCA powerful tool detecting biases data. dimensionality reduction technique, enables visualization data lower-dimensional space. context LC-MS data, PCA can used identify overall biases batch, sample, injection index, etc. However, important note PCA linear method may able detect biases data. plotting PCA, apply log2 transform, center scale data. log2 transformation applied stabilize variance centering remove dependency absolute abundances.  Figure 24. PCA data coloured phenotypes. PCA shows clear separation study samples (plasma) QC samples (serum) first principal component (PC1). separation based phenotype visible third principal component (PC3). cases, can better option remove imputed values evaluate PCA . especially true imputed values replacing large proportion data. Global differences feature abundances samples (e.g. due sample-specific biases) can evaluated plotting distribution log2 transformed feature abundances using boxplots violin plots. show number detected chromatographic peaks per sample distribution log2 transformed feature abundances.  Figure 25. Number detected peaks feature abundances. upper part plot show gap filling steps allowed rescue substantial number NAs allowed us consistent number feature values per sample. consistency aligns asspumption every sample similar amount features detected. Additionally observe , average, signal distribution individual samples similar. alternative way evaluate differences abundances samples relative log abundance (RLA) plots (De Livera et al. 2012). RLA value abundance feature sample relative median abundance feature across multiple samples. can discriminate within group across group RLAs, depending whether abundance compared samples within sample group across samples. Within group RLA plots assess tightness replicates within groups median close zero low variation around . used across groups, allow compare behavior groups. Generally, -sample differences can easily spotted using RLA plots. calculate visualize within group RLA values using rowRla() function MsCoreUtils package defining parameter f sample groups.  Figure 26. RLA plot raw data filled data. RLA plot , can observe medians samples indeed centered around 0. Exception two CVD samples. Thus, distribution signals across samples comparable, differences seem present require sample normalization.","code":"#' Impute missing values using an uniform distribution na_unidis <- function(z) {     na <- is.na(z)     if (any(na)) {         min = min(z, na.rm = TRUE)         z[na] <- runif(sum(na), min = min/2, max = min)     }     z }  #' Row-wise impute missing values and add the data as a new assay tmp <- apply(assay(res, \"raw_filled\"), MARGIN = 1, na_unidis) assays(res)$raw_filled_imputed <- t(tmp) #' Log2 transform and scale data vals <- assay(res, \"raw_filled_imputed\") |>     log2() |>     t() |>     scale(center = TRUE, scale = TRUE)  #' Perform the PCA pca_res <- prcomp(vals, scale = FALSE, center = FALSE)  #' Plot the results vals_st <- cbind(vals, phenotype = res$phenotype) pca_12 <- autoplot(pca_res, data = vals_st , colour = 'phenotype', scale = 0) +     scale_color_manual(values = col_phenotype) pca_34 <- autoplot(pca_res, data = vals_st, colour = 'phenotype',                    x = 3, y = 4, scale = 0) +     scale_color_manual(values = col_phenotype) grid.arrange(pca_12, pca_34, ncol = 1) layout(mat = matrix(1:3, ncol = 1), height = c(0.2, 0.2, 0.8))  par(mar = c(0.2, 4.5, 0.2, 3)) barplot(apply(assay(res, \"raw\"), MARGIN = 2, function(x) sum(!is.na(x))),         col = paste0(col_sample, 80), border = col_sample,         ylab = \"# detected peaks\", xaxt = \"n\", space = 0.012) grid(nx = NA, ny = NULL) barplot(apply(assay(res, \"raw_filled\"), MARGIN = 2, function(x) sum(!is.na(x))),         col = paste0(col_sample, 80), border = col_sample,         ylab = \"# detected + filled peaks\", xaxt = \"n\",         space = 0.012) grid(nx = NA, ny = NULL) vioplot(log2(assay(res, \"raw_filled\")), xaxt = \"n\",         ylab = expression(log[2]~feature~abundance),         col = paste0(col_sample, 80), border = col_sample) points(colMedians(log2(assay(res, \"raw_filled\")), na.rm = TRUE), type = \"b\",        pch = 1) grid(nx = NA, ny = NULL) legend(\"topright\", col = col_phenotype,        legend = names(col_phenotype), lty=1, lwd = 2, xpd = TRUE, ncol = 3,        cex = 0.8,  bty = \"n\") par(mfrow = c(1, 1), mar = c(3.5, 4.5, 2.5, 1)) boxplot(MsCoreUtils::rowRla(assay(res, \"raw_filled\"),                             f = res$phenotype, transform = \"log2\"),         cex = 0.5, pch = 16,         col = paste0(col_sample, 80), ylab = \"RLA\",         border = col_sample, boxwex = 1,         outline = FALSE, xaxt = \"n\", main = \"Relative log abundance\",         cex.main = 1) axis(side = 1, at = seq_len(ncol(res)), labels = colData(res)$sample_name) grid(nx = NA, ny = NULL) abline(h = 0, lty=3, lwd = 1, col = \"black\") legend(\"topright\", col = col_phenotype,        legend = names(col_phenotype), lty=1, lwd = 2, xpd = TRUE, ncol = 3,        cex = 0.8,  bty = \"n\")"},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/a-end-to-end-untargeted-metabolomics.html","id":"principal-component-analysis","dir":"Articles","previous_headings":"Data normalization","what":"Principal Component Analysis","title":"Complete end-to-end LC-MS/MS Metabolomic Data analysis","text":"PCA powerful tool detecting biases data. dimensionality reduction technique, enables visualization data lower-dimensional space. context LC-MS data, PCA can used identify overall biases batch, sample, injection index, etc. However, important note PCA linear method may able detect biases data. plotting PCA, apply log2 transform, center scale data. log2 transformation applied stabilize variance centering remove dependency absolute abundances.  Figure 24. PCA data coloured phenotypes. PCA shows clear separation study samples (plasma) QC samples (serum) first principal component (PC1). separation based phenotype visible third principal component (PC3). cases, can better option remove imputed values evaluate PCA . especially true imputed values replacing large proportion data.","code":"#' Log2 transform and scale data vals <- assay(res, \"raw_filled_imputed\") |>     log2() |>     t() |>     scale(center = TRUE, scale = TRUE)  #' Perform the PCA pca_res <- prcomp(vals, scale = FALSE, center = FALSE)  #' Plot the results vals_st <- cbind(vals, phenotype = res$phenotype) pca_12 <- autoplot(pca_res, data = vals_st , colour = 'phenotype', scale = 0) +     scale_color_manual(values = col_phenotype) pca_34 <- autoplot(pca_res, data = vals_st, colour = 'phenotype',                    x = 3, y = 4, scale = 0) +     scale_color_manual(values = col_phenotype) grid.arrange(pca_12, pca_34, ncol = 1)"},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/a-end-to-end-untargeted-metabolomics.html","id":"intensity-evaluation","dir":"Articles","previous_headings":"Data normalization","what":"Intensity evaluation","title":"Complete end-to-end LC-MS/MS Metabolomic Data analysis","text":"Global differences feature abundances samples (e.g. due sample-specific biases) can evaluated plotting distribution log2 transformed feature abundances using boxplots violin plots. show number detected chromatographic peaks per sample distribution log2 transformed feature abundances.  Figure 25. Number detected peaks feature abundances. upper part plot show gap filling steps allowed rescue substantial number NAs allowed us consistent number feature values per sample. consistency aligns asspumption every sample similar amount features detected. Additionally observe , average, signal distribution individual samples similar. alternative way evaluate differences abundances samples relative log abundance (RLA) plots (De Livera et al. 2012). RLA value abundance feature sample relative median abundance feature across multiple samples. can discriminate within group across group RLAs, depending whether abundance compared samples within sample group across samples. Within group RLA plots assess tightness replicates within groups median close zero low variation around . used across groups, allow compare behavior groups. Generally, -sample differences can easily spotted using RLA plots. calculate visualize within group RLA values using rowRla() function MsCoreUtils package defining parameter f sample groups.  Figure 26. RLA plot raw data filled data. RLA plot , can observe medians samples indeed centered around 0. Exception two CVD samples. Thus, distribution signals across samples comparable, differences seem present require sample normalization.","code":"layout(mat = matrix(1:3, ncol = 1), height = c(0.2, 0.2, 0.8))  par(mar = c(0.2, 4.5, 0.2, 3)) barplot(apply(assay(res, \"raw\"), MARGIN = 2, function(x) sum(!is.na(x))),         col = paste0(col_sample, 80), border = col_sample,         ylab = \"# detected peaks\", xaxt = \"n\", space = 0.012) grid(nx = NA, ny = NULL) barplot(apply(assay(res, \"raw_filled\"), MARGIN = 2, function(x) sum(!is.na(x))),         col = paste0(col_sample, 80), border = col_sample,         ylab = \"# detected + filled peaks\", xaxt = \"n\",         space = 0.012) grid(nx = NA, ny = NULL) vioplot(log2(assay(res, \"raw_filled\")), xaxt = \"n\",         ylab = expression(log[2]~feature~abundance),         col = paste0(col_sample, 80), border = col_sample) points(colMedians(log2(assay(res, \"raw_filled\")), na.rm = TRUE), type = \"b\",        pch = 1) grid(nx = NA, ny = NULL) legend(\"topright\", col = col_phenotype,        legend = names(col_phenotype), lty=1, lwd = 2, xpd = TRUE, ncol = 3,        cex = 0.8,  bty = \"n\") par(mfrow = c(1, 1), mar = c(3.5, 4.5, 2.5, 1)) boxplot(MsCoreUtils::rowRla(assay(res, \"raw_filled\"),                             f = res$phenotype, transform = \"log2\"),         cex = 0.5, pch = 16,         col = paste0(col_sample, 80), ylab = \"RLA\",         border = col_sample, boxwex = 1,         outline = FALSE, xaxt = \"n\", main = \"Relative log abundance\",         cex.main = 1) axis(side = 1, at = seq_len(ncol(res)), labels = colData(res)$sample_name) grid(nx = NA, ny = NULL) abline(h = 0, lty=3, lwd = 1, col = \"black\") legend(\"topright\", col = col_phenotype,        legend = names(col_phenotype), lty=1, lwd = 2, xpd = TRUE, ncol = 3,        cex = 0.8,  bty = \"n\")"},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/a-end-to-end-untargeted-metabolomics.html","id":"between-sample-normalisation","dir":"Articles","previous_headings":"","what":"Between sample normalisation","title":"Complete end-to-end LC-MS/MS Metabolomic Data analysis","text":"previous RLA plot showed data biases need corrected. Therefore, implement -sample normalization using filled-features. process effectively mitigates variations influenced technical issues, differences sample preparation, processing injection methods. instance, employ commonly used technique known median scaling (De Livera et al. 2012). method involves computing median sample, followed determining median individual sample medians. ensures consistent median values sample throughout entire data set. Maintaining uniformity average total metabolite abundance across samples crucial effective implementation. process aims establish shared baseline central tendency metabolite abundance, mitigating impact sample-specific technical variations. approach fosters robust comparable analysis top features across data set. assumption normalizing based median, known lower sensitivity extreme values, enhances comparability top features ensures consistent average abundance across samples. median scaling calculated imputed non-imputed data, set stored separately within SummarizedExperiment object. approach facilitates testing various normalization strategies maintaining record processing steps undertaken, enabling easy regression previous stages necessary.","code":"#' Compute median and generate normalization factor mdns <- apply(assay(res, \"raw_filled\"), MARGIN = 2,               median, na.rm = TRUE ) nf_mdn <- mdns / median(mdns)  #' divide dataset by median of median and create a new assay. assays(res)$norm <- sweep(assay(res, \"raw_filled\"), MARGIN = 2, nf_mdn, '/') assays(res)$norm_imputed <- sweep(assay(res, \"raw_filled_imputed\"), MARGIN = 2,                                   nf_mdn, '/')"},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/a-end-to-end-untargeted-metabolomics.html","id":"median-scaling","dir":"Articles","previous_headings":"Data normalization","what":"Median scaling","title":"Complete end-to-end LC-MS/MS Metabolomic Data analysis","text":"method involves computing median sample, followed determining median individual sample medians. ensures consistent median values sample throughout entire data set. Maintaining uniformity average total metabolite abundance across samples crucial effective implementation. process aims establish shared baseline central tendency metabolite abundance, mitigating impact sample-specific technical variations. approach fosters robust comparable analysis top features across data set. assumption normalizing based median, known lower sensitivity extreme values, enhances comparability top features ensures consistent average abundance across samples. median scaling calculated imputed non-imputed data, set stored separately within SummarizedExperiment object. approach facilitates testing various normalization strategies maintaining record processing steps undertaken, enabling easy regression previous stages necessary.","code":"#' Compute median and generate normalization factor mdns <- apply(assay(res, \"raw_filled\"), MARGIN = 2,               median, na.rm = TRUE ) nf_mdn <- mdns / median(mdns)  #' divide dataset by median of median and create a new assay. assays(res)$norm <- sweep(assay(res, \"raw_filled\"), MARGIN = 2, nf_mdn, '/') assays(res)$norm_imputed <- sweep(assay(res, \"raw_filled_imputed\"), MARGIN = 2,                                   nf_mdn, '/')"},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/a-end-to-end-untargeted-metabolomics.html","id":"assessing-overall-effectiveness-of-the-normalization-approach","dir":"Articles","previous_headings":"","what":"Assessing overall effectiveness of the normalization approach","title":"Complete end-to-end LC-MS/MS Metabolomic Data analysis","text":"crucial evaluate effectiveness normalization process. can achieved comparing distribution log2 transformed feature abundances normalization. Additionally, RLA plots can used assess tightness replicates within groups compare behavior groups.  Figure 27. PC1 PC2 data normalization. Normalization large impact PC1 PC2, separation study groups PC3 seems better difference QC samples lower normalization (see ).  Figure 28. PC3 PC4 data normalization. PCA plots show normalization process changed overall structure data. separation study QC samples remains . expected results normalization correct biological variance technical. compare RLA plots -sample normalization evaluate impact data.  Figure 29. RLA plot normalization. normalization process effectively centered data around median medians samples now closer zero. next evaluate coefficient variation (CV, also referred relative standard deviation RSD) features across samples either QC study samples. QC samples, CV represent technical noise, study samples include also expected biological differences. Thus, normalization reduce CV QC samples, slightly reducing CV study samples. CV calculated using rowRsd() function MetaboCoreUtils package. setting mad = TRUE use robust calculation using median absolute deviation instead standard deviation. Table 6. Distribution CV values across samples raw normalized data. table shows distribution CV raw normalized data. first column highlights % data given CV value, e.g. 25% data CV equal lower 0.04557 QC_raw data. anticipated, CV values QCs, reflect technical variance, lower compared study samples, include technical biological variance. Overall, minimal disparity exists raw normalized data, positive indication normalization process introduced bias dataset, also reflects little differences average abundances sample raw data. overall conclusion normalization process little variance present beginning, normalization however able center data around median (shown RLA plot). Given simplicity limited size example dataset, conclude normalization process stage. intricate datasets diverse biases, tailored approach devised. include also approaches adjust signal drifts batch effects. One possible option use linear-model based approach can example applied adjust_lm() function MetaboCoreUtils package.","code":"#' Data before normalization vals_st <- cbind(vals, phenotype = res$phenotype) pca_raw <- autoplot(pca_res, data = vals_st,                     colour = 'phenotype', scale = 0) +     scale_color_manual(values = col_phenotype)  #' Data after normalization vals_norm <- apply(assay(res, \"norm\"), MARGIN = 1, na_unidis) |>     log2() |>     scale(center = TRUE, scale = TRUE)  pca_res_norm <- prcomp(vals_norm, scale = FALSE, center = FALSE) vals_st_norm <- cbind(vals_norm, phenotype = res$phenotype) pca_adj <- autoplot(pca_res_norm, data = vals_st_norm,                     colour = 'phenotype', scale = 0) +     scale_color_manual(values = col_phenotype)  grid.arrange(pca_raw, pca_adj, ncol = 1) pca_raw <- autoplot(pca_res, data = vals_st ,                     colour = 'phenotype', x = 3, y = 4, scale = 0) +     scale_color_manual(values = col_phenotype) pca_adj <- autoplot(pca_res_norm, data = vals_st_norm,                     colour = 'phenotype', x = 3, y = 4, scale = 0) +     scale_color_manual(values = col_phenotype)  grid.arrange(pca_raw, pca_adj, ncol = 1) par(mfrow = c(2, 1), mar = c(3.5, 4.5, 2.5, 1))  boxplot(rowRla(assay(res, \"raw_filled\"), group = res$phenotype),         cex = 0.5, pch = 16, ylab = \"RLA\", border = col_sample,         col = paste0(col_sample, 80), cex.main = 1, outline = FALSE,         xaxt = \"n\", main = \"Raw data\", boxwex = 1) grid(nx = NA, ny = NULL) legend(\"topright\", inset = c(0, -0.2), col = col_phenotype,        legend = names(col_phenotype), lty=1, lwd = 2, xpd = TRUE,        ncol = 3, cex = 0.7, bty = \"n\") abline(h = 0, lty=3, lwd = 1, col = \"black\")  boxplot(rowRla(assay(res, \"norm\"), group = res$phenotype),         cex = 0.5, pch = 16, ylab = \"RLA\", border = col_sample,         col = paste0(col_sample, 80), boxwex = 1, outline = FALSE,         xaxt = \"n\", main = \"Normallized data\", cex.main = 1) axis(side = 1, at = seq_len(ncol(res)), labels = res$sample_name) grid(nx = NA, ny = NULL) abline(h = 0, lty = 3, lwd = 1, col = \"black\") #' Calculate the CV values index_study <- res$phenotype %in% c(\"CTR\", \"CVD\") index_QC <- res$phenotype == \"QC\"  sample_res <- cbind(     QC_raw = rowRsd(assay(res, \"raw_filled\")[, index_QC],                     na.rm = TRUE, mad = TRUE),     QC_norm = rowRsd(assay(res, \"norm\")[, index_QC],                      na.rm = TRUE, mad = TRUE),     Study_raw = rowRsd(assay(res, \"raw_filled\")[, index_study],                        na.rm = TRUE, mad = TRUE),     Study_norm = rowRsd(assay(res, \"norm\")[, index_study],                         na.rm = TRUE, mad = TRUE) )  #' Summarize the values across features res_df <- data.frame(     QC_raw = quantile(sample_res[, \"QC_raw\"], na.rm = TRUE),     QC_norm = quantile(sample_res[, \"QC_norm\"], na.rm = TRUE),     Study_raw = quantile(sample_res[, \"Study_raw\"], na.rm = TRUE),     Study_norm = quantile(sample_res[, \"Study_norm\"], na.rm = TRUE) )  kable(res_df, format = \"pipe\")"},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/a-end-to-end-untargeted-metabolomics.html","id":"principal-component-analysis-1","dir":"Articles","previous_headings":"Data normalization","what":"Principal Component Analysis","title":"Complete end-to-end LC-MS/MS Metabolomic Data analysis","text":"Figure 27. PC1 PC2 data normalization. Normalization large impact PC1 PC2, separation study groups PC3 seems better difference QC samples lower normalization (see ).  Figure 28. PC3 PC4 data normalization. PCA plots show normalization process changed overall structure data. separation study QC samples remains . expected results normalization correct biological variance technical.","code":"#' Data before normalization vals_st <- cbind(vals, phenotype = res$phenotype) pca_raw <- autoplot(pca_res, data = vals_st,                     colour = 'phenotype', scale = 0) +     scale_color_manual(values = col_phenotype)  #' Data after normalization vals_norm <- apply(assay(res, \"norm\"), MARGIN = 1, na_unidis) |>     log2() |>     scale(center = TRUE, scale = TRUE)  pca_res_norm <- prcomp(vals_norm, scale = FALSE, center = FALSE) vals_st_norm <- cbind(vals_norm, phenotype = res$phenotype) pca_adj <- autoplot(pca_res_norm, data = vals_st_norm,                     colour = 'phenotype', scale = 0) +     scale_color_manual(values = col_phenotype)  grid.arrange(pca_raw, pca_adj, ncol = 1) pca_raw <- autoplot(pca_res, data = vals_st ,                     colour = 'phenotype', x = 3, y = 4, scale = 0) +     scale_color_manual(values = col_phenotype) pca_adj <- autoplot(pca_res_norm, data = vals_st_norm,                     colour = 'phenotype', x = 3, y = 4, scale = 0) +     scale_color_manual(values = col_phenotype)  grid.arrange(pca_raw, pca_adj, ncol = 1)"},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/a-end-to-end-untargeted-metabolomics.html","id":"intensity-evaluation-1","dir":"Articles","previous_headings":"Data normalization","what":"Intensity evaluation","title":"Complete end-to-end LC-MS/MS Metabolomic Data analysis","text":"compare RLA plots -sample normalization evaluate impact data.  Figure 29. RLA plot normalization. normalization process effectively centered data around median medians samples now closer zero.","code":"par(mfrow = c(2, 1), mar = c(3.5, 4.5, 2.5, 1))  boxplot(rowRla(assay(res, \"raw_filled\"), group = res$phenotype),         cex = 0.5, pch = 16, ylab = \"RLA\", border = col_sample,         col = paste0(col_sample, 80), cex.main = 1, outline = FALSE,         xaxt = \"n\", main = \"Raw data\", boxwex = 1) grid(nx = NA, ny = NULL) legend(\"topright\", inset = c(0, -0.2), col = col_phenotype,        legend = names(col_phenotype), lty=1, lwd = 2, xpd = TRUE,        ncol = 3, cex = 0.7, bty = \"n\") abline(h = 0, lty=3, lwd = 1, col = \"black\")  boxplot(rowRla(assay(res, \"norm\"), group = res$phenotype),         cex = 0.5, pch = 16, ylab = \"RLA\", border = col_sample,         col = paste0(col_sample, 80), boxwex = 1, outline = FALSE,         xaxt = \"n\", main = \"Normallized data\", cex.main = 1) axis(side = 1, at = seq_len(ncol(res)), labels = res$sample_name) grid(nx = NA, ny = NULL) abline(h = 0, lty = 3, lwd = 1, col = \"black\")"},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/a-end-to-end-untargeted-metabolomics.html","id":"coefficient-of-variation","dir":"Articles","previous_headings":"Data normalization","what":"Coefficient of variation","title":"Complete end-to-end LC-MS/MS Metabolomic Data analysis","text":"next evaluate coefficient variation (CV, also referred relative standard deviation RSD) features across samples either QC study samples. QC samples, CV represent technical noise, study samples include also expected biological differences. Thus, normalization reduce CV QC samples, slightly reducing CV study samples. CV calculated using rowRsd() function MetaboCoreUtils package. setting mad = TRUE use robust calculation using median absolute deviation instead standard deviation. Table 6. Distribution CV values across samples raw normalized data. table shows distribution CV raw normalized data. first column highlights % data given CV value, e.g. 25% data CV equal lower 0.04557 QC_raw data. anticipated, CV values QCs, reflect technical variance, lower compared study samples, include technical biological variance. Overall, minimal disparity exists raw normalized data, positive indication normalization process introduced bias dataset, also reflects little differences average abundances sample raw data.","code":"#' Calculate the CV values index_study <- res$phenotype %in% c(\"CTR\", \"CVD\") index_QC <- res$phenotype == \"QC\"  sample_res <- cbind(     QC_raw = rowRsd(assay(res, \"raw_filled\")[, index_QC],                     na.rm = TRUE, mad = TRUE),     QC_norm = rowRsd(assay(res, \"norm\")[, index_QC],                      na.rm = TRUE, mad = TRUE),     Study_raw = rowRsd(assay(res, \"raw_filled\")[, index_study],                        na.rm = TRUE, mad = TRUE),     Study_norm = rowRsd(assay(res, \"norm\")[, index_study],                         na.rm = TRUE, mad = TRUE) )  #' Summarize the values across features res_df <- data.frame(     QC_raw = quantile(sample_res[, \"QC_raw\"], na.rm = TRUE),     QC_norm = quantile(sample_res[, \"QC_norm\"], na.rm = TRUE),     Study_raw = quantile(sample_res[, \"Study_raw\"], na.rm = TRUE),     Study_norm = quantile(sample_res[, \"Study_norm\"], na.rm = TRUE) )  kable(res_df, format = \"pipe\")"},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/a-end-to-end-untargeted-metabolomics.html","id":"conclusion-on-normalization","dir":"Articles","previous_headings":"Data normalization","what":"Conclusion on normalization","title":"Complete end-to-end LC-MS/MS Metabolomic Data analysis","text":"overall conclusion normalization process little variance present beginning, normalization however able center data around median (shown RLA plot). Given simplicity limited size example dataset, conclude normalization process stage. intricate datasets diverse biases, tailored approach devised. include also approaches adjust signal drifts batch effects. One possible option use linear-model based approach can example applied adjust_lm() function MetaboCoreUtils package.","code":""},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/a-end-to-end-untargeted-metabolomics.html","id":"quality-control-feature-prefiltering","dir":"Articles","previous_headings":"","what":"Quality control: Feature prefiltering","title":"Complete end-to-end LC-MS/MS Metabolomic Data analysis","text":"normalizing data can now pre-filter clean data performing statistical analysis. general, pre-filtering samples features performed remove outliers. copy original result object also keep unfiltered data later comparisons. eliminate features exhibit high variability dataset. Repeatedly measured QC samples typically serve robust basis cleansing datasets allowing identify features excessively high noise. data set external QC samples used, .e. pooled samples different collection using slightly different sample matrix, utility filtering somewhat limited. comprehensive description guidelines data filtering untargeted metabolomic studies, please refer (Broadhurst et al. 2018). Following guidelines stated decided still use QC samples pre-filtering, basis represent similar bio-fluids study samples, thus, anticipate observing relatively similar metabolites affected similar measurement biases. therefore evaluate dispersion ratio (Dratio) (Broadhurst et al. 2018) features data set. accomplish task using function time DratioFilter parameter. filters exist function invite user explore decide best dataset. Dratio filter powerful tool identify features exhibit high variability data, relating variance observed QC samples study samples. setting threshold 0.4, remove features high degree variability QC study samples. example, feature deviation QC higher 40% (threshold = 0.4)deviation study samples removed. filtering step ensures features retained considerably lower technical biological variance. Note rowDratio() rowRsd() functions MetaboCoreUtils package used calculate actual numeric values estimates used filtering, e.g. evaluate distribution whole data set identify data set-dependent threshold values. Finally, evaluate number features left filtering steps calculate percentage features removed. dataset reduced 8724 4514 features. remove considerable amount features expected want focus reliable features analysis. rest analysis need separate QC samples study samples. store QC samples separate object later use. addition calculate CV QC samples add additional column rowData() result object. used later prioritize identified significant features e.g. low technical noise. Now data set preprocessed, normalized filtered, can start evaluate distribution data estimate variation due biology.","code":"#' Number of features before filtering nrow(res) [1] 8724 #' keep unfiltered object res_unfilt <- res #' Compute and filter based on the Dratio filter_dratio <- DratioFilter(threshold = 0.4,                               qcIndex = res$phenotype == \"QC\",                               studyIndex = res$phenotype != \"QC\",                               mad = TRUE) res <- filterFeatures(res, filter = filter_dratio, assay = \"norm_imputed\") 4210 features were removed #' Number of features after analysis nrow(res) [1] 4514 #' Percentage left: end/beginning nrow(res)/nrow(res_unfilt) * 100 [1] 51.74232 res_qc <- res[, res$phenotype == \"QC\"] res <- res[, res$phenotype != \"QC\"] #' Calculate the QC's CV and add as feature variable to the data set rowData(res)$qc_cv <- assay(res_qc, \"norm\") |>                rowRsd()"},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/a-end-to-end-untargeted-metabolomics.html","id":"overlapping-features","dir":"Articles","previous_headings":"","what":"Overlapping features","title":"Complete end-to-end LC-MS/MS Metabolomic Data analysis","text":"performing complex statistical analysis short quality analysis. possible evaluation features overlapping different groups. case grouping per condition (CTR versus CVD group) interesting plot. However want address case people test 3 condition therefore show overlapping feature per sample (therefore comparing 6 groups).  case large number groups Venn diagram can replace Upset plot can handle larger number groups, still readable.  quality analysis data , evaluating number feature detected per group, overall abundance, noise, … depends goal user research. R lot flexibility, can many things !","code":"df_logical <- !is.na(assay(res, \"raw_filled\"))  # Create a Venn diagram library(ggVennDiagram) l_logical <- apply(df_logical, MARGIN = 2,function(i) which(i)) ggVennDiagram(l_logical, label = \"count\",                             category.names = res$sample_name,               color = 1, lwd = 0.7) +   scale_fill_gradient(low = \"lightblue\", high = \"#4981BF\") +  theme(legend.position = \"none\") #make upsetplot library(UpSetR) binary_data <-apply(df_logical, MARGIN = 2, as.integer) upset(as.data.frame(binary_data), nset = 6, sets = colnames(df_logical), keep.order = TRUE)"},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/a-end-to-end-untargeted-metabolomics.html","id":"differential-abundance-analysis","dir":"Articles","previous_headings":"","what":"Differential abundance analysis","title":"Complete end-to-end LC-MS/MS Metabolomic Data analysis","text":"normalization quality control, next step identify features differential abundant study groups. crucial step allows us identify potential biomarkers metabolites associated study groups. various approaches methods available identification features interest. workflow use multiple linear regression analysis identify features significantly difference abundances CVD CTR study group. performing tests evaluate similarities study samples using PCA (excluding QC samples avoid influencing results).  Figure 30. PCA data normalization quality control. samples clearly separate study group PCA indicating differences metabolite profiles two groups. However, drives separation PC1 clear. evaluate whether explained available variable study, .e., age:  Figure 31. PCA colored age data normalization quality control. According PCA , PC1 seem related age. Even variance data set can’t explain stage, proceed (supervised) statistical tests identify features interest. compute linear models metabolite explaining observed feature abundance available study variables. also use base R function lm(), utilize R Biocpkg(\"limma\") package conduct differential abundance analysis: moderated test statistics (Smyth 2004) provided package specifically well suited experiments limited number replicates. tests use linear model ~ phenotype + age, hence explaining abundances one metabolite accounting study group assignment age individual. analysis might benefit inclusion study covariate associated PC2 explaining variance seen principal component, present analysis participant’s age disease association provided. define design study model.matrix() function fit feature-wise linear models log2-transformed abundances using lmFit() function. P-values significance association calculated using eBayes() function, also performs empirical Bayes-based robust estimation standard errors. See also excellent vignette/user guide limma package examples details linear model procedure. linear models fitted, can now proceed extract results. create data frame containing coefficients, raw adjusted p-values (applying Benjamini-Hochberg correction, .e., method = \"BH\" improved control false discovery rate), average intensity signals CVD CTR samples, indication whether feature deemed significant . consider metabolites adjusted p-value smaller 0.05 significant, also include (absolute) difference abundances cut-criteria. last, add differential abundance results result object’s rowData(). can now proceed visualize distribution raw adjusted p-values.  Figure 32. Distribution raw (left) adjusted p-values (right). histograms show distribution raw adjusted p-values. Except enrichment small p-values, raw p-values (less) uniformly distributed, indicates absence strong systematic biases data. adjusted p-values conservative account multiple testing; important fit linear model feature therefore perform large number tests leads high chance false positive findings. see features low p-values, indicating likely significantly different two study groups. plot adjusted p-values log2 fold change (average) abundances. volcano plot allow us visualize features significantly different two study groups. highlighted blue color plot .  Figure 33. Volcano plot showing analysis results. interesting features top corners volcano plot (.e., features large difference abundance groups small p-value). significant features negative coefficient (log2 fold change value) indicating abundance lower CVD samples compared CTR samples. features listed, along average difference (log2) abundance compared groups, adjusted p-values, average (log2) abundance sample group RSD (CV) QC samples table . Table 7. Features significant differences abundances. visualize EICs significant features evaluate (raw) signal. restrict MS data set study samples. Parameters keepFeatures = TRUE: ensures identified features retained subset object. peakBg: defines (background) color individual chromatographic peak EIC object.  Figure 34. Extracted ion chromatograms significant features. EICs significant features show clear single peak. intensities (already observed ) much larger CTR CVD samples. exception second feature (second EIC top row), intensities significant features however generally low. might make challenging identify using LC-MS/MS setup.","code":"#' Define the colors for the plot col_sample <- col_phenotype[res$phenotype]  #' Log transform and scale the data for PCA analysis vals <- assay(res, \"norm_imputed\") |>     t() |>     log2() |>     scale(center = TRUE, scale = TRUE) pca_res <- prcomp(vals, scale = FALSE, center = FALSE)  vals_st <- cbind(vals, phenotype = res$phenotype) autoplot(pca_res, data = vals_st , colour = 'phenotype', scale = 0) +     scale_color_manual(values = col_phenotype) #' Add age to the PCA plot vals_st <- cbind(vals, age = res$age) autoplot(pca_res, data = vals_st , colour = 'age', scale = 0) #' Define the linear model to be applied to the data p.cut <- 0.05     # cut-off for significance. m.cut <- 0.5      # cut-off for log2 fold change  age <- res$age phenotype <- factor(res$phenotype) design <- model.matrix(~ phenotype + age)  #' Fit the linear model to the data, explaining metabolite #' concentrations by phenotype and age. fit <- lmFit(log2(assay(res, \"norm_imputed\")), design = design) fit <- eBayes(fit) #' Compile a result data frame tmp <- data.frame(     coef.CVD = fit$coefficients[, \"phenotypeCVD\"],     pvalue.CVD = fit$p.value[, \"phenotypeCVD\"],     adjp.CVD = p.adjust(fit$p.value[, \"phenotypeCVD\"], method = \"BH\"),     avg.CVD = rowMeans(         log2(assay(res, \"norm_imputed\")[, res$phenotype == \"CVD\"])),     avg.CTR = rowMeans(         log2(assay(res, \"norm_imputed\")[, res$phenotype == \"CTR\"])) ) tmp$significant.CVD <- tmp$adjp.CVD < 0.05 #' Add the results to the object's rowData rowData(res) <- cbind(rowData(res), tmp) #' Plot the distribution of p-values par(mfrow = c(1, 2)) hist(rowData(res)$pvalue.CVD, breaks = 64, xlab = \"p value\",      main = \"Distribution of raw p-values\",      cex.main = 1, cex.lab = 1, cex.axis = 1) hist(rowData(res)$adjp.CVD, breaks = 64, xlab = expression(p[BH]~value),      main = \"Distribution of adjusted p-values\",      cex.main = 1, cex.lab = 1, cex.axis = 1) #' Plot volcano plot of the statistical results par(mfrow = c(1, 1), mar = c(5, 5, 5, 1)) plot(rowData(res)$coef.CVD, -log10(rowData(res)$adjp.CVD),      xlab = expression(log[2]~difference),      ylab = expression(-log[10]~p[BH]), pch = 16, col = \"#00000060\",      cex.main = 1.5, cex.lab = 1.5, cex.axis = 1.3) grid() abline(h = -log10(0.05), col = \"#0000ffcc\") if (any(rowData(res)$significant.CVD)) {     points(rowData(res)$coef.CVD[rowData(res)$significant.CVD],            -log10(rowData(res)$adjp.CVD[rowData(res)$significant.CVD]),            col = \"#0000ffcc\") } # Table of significant features tab <- rowData(res)[rowData(res)$significant.CVD,                     c(\"mzmed\", \"rtmed\", \"coef.CVD\", \"adjp.CVD\",                       \"avg.CTR\", \"avg.CVD\", \"qc_cv\")] |>     as.data.frame() tab <- tab[order(abs(tab$coef.CVD), decreasing = TRUE), ] kable(tab, format = \"pipe\") #' Restrict the raw data to study samples. lcms1_study <- lcms1[sampleData(lcms1)$phenotype != \"QC\", keepFeatures = TRUE] #' Extract EICs for the significant features eic_sign <- featureChromatograms(     lcms1_study, features = rownames(tab), expandRt = 5, filled = TRUE)  #' Plot the EICs. plot(eic_sign, col = col_sample,      peakBg = paste0(col_sample[chromPeaks(eic_sign)[, \"sample\"]], 40)) legend(\"topright\", col = col_phenotype, legend = names(col_phenotype), lty = 1)"},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/a-end-to-end-untargeted-metabolomics.html","id":"multivariate-analysis","dir":"Articles","previous_headings":"","what":"Multivariate Analysis","title":"Complete end-to-end LC-MS/MS Metabolomic Data analysis","text":"Coming soon…","code":""},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/a-end-to-end-untargeted-metabolomics.html","id":"annotation","dir":"Articles","previous_headings":"","what":"Annotation","title":"Complete end-to-end LC-MS/MS Metabolomic Data analysis","text":"now identified features significant differences abundances two study groups. provide information metabolic pathways differentiate affected healthy individuals might hence also serve biomarkers. However, stage analysis know compounds/metabolites actually represent. thus need now annotate signals. Annotation can performed different level confidence Schymanski et al. (2014). lowest level annotation, highest rate false positive hits, bases features m/z ratios. Higher levels annotations employ fragment spectra (MS2 spectra) ions interest requiring however acquisition additional data. section, demonstrate multiple ways annotate significant features using functionality provided Bioconductor packages. Alternative approaches external software tools, may better suited, also discussed later section. data set acquired using LC-MS setup features thus characterized m/z retention times. retention time LC-setup-specific , without prior data/knowledge provide little information features’ identity. Modern MS instruments high accuracy m/z values therefore reliable estimates compound ion’s mass--charge ratio. first approach, use features’ m/z values match reference values, .e., exact masses chemical compounds provided reference database, case MassBank database. full MassBank data re-distributed Bioconductor’s AnnotationHub resource, simplifies integration reproducible R-based analysis workflows. load resource, list available MassBank data sets/releases load one . MassBank data provided self-contained SQLite database data can queried accessed CompoundDb Bioconductor package. use compounds() function extract small compound annotations database. MassBank (small compound annotation databases) provides (exact) molecular mass compound. Since almost small compounds neutral natural state, need first converted m/z values allow matching feature’s m/z. calculate m/z neutral mass, need assume ion (adduct) might generated measured metabolites employed electro-spray ionization. positive polarity, human serum samples, common ions protonated ([M+H]+), bear addition sodium ([M+Na]+) ammonium ([M+H-NH3]+) ions. match observed m/z values reference values potential ions use matchValues() function Mass2MzParam approach, allows specify types expected ions adducts parameter maximal allowed difference compared values using tolerance ppm parameters. first prepare data.frame significant features, set parameters matching perform comparison query features reference database. resulting Matched object shows 4 6 significant features matched ions compounds MassBank database. extract full result Matched object. Thus, total 43 ions compounds MassBank matched significant features based specified tolerance settings. Many compounds, different structure thus function/chemical property, identical chemical formula thus mass. Matching exclusively m/z features hence result many potentially false positive hits thus considered provide low confidence annotation. additional complication annotation resources, like MassBank, community maintained, contain large amount redundant information. reduce redundancy result table iterate hits feature keep matches unique compounds (identified INCHIKEY). INCHI INCHIKEY combine information compound’s chemical formula structure, different compounds can share chemical formula, different structure thus INCHI. Table 9. MS1 annotation results. table shows results MS1-based annotation process. can see four significant features matched. matches seem pretty accurate low ppm errors. deduplication performed considerably reduced number hits feature, first still matches ions large number compounds (chemical formula). Considering features’ m/z retention times MS1-based annotation increase annotation confidence, requires additional data, recording retention time thepure standard compound LC setup. alternative approach might provide better inside annotations help choose different annotations feature evaluate certain chemical properties possible matches. instance, LogP value, available several databases HMDB, provides insight given compound’s polarity. property highly affects interaction analyte column, usually also directly affects separation. Therefore, comparison analyte’s retention time polarity can help rule possible misidentifications. low confidence, MS1-based annotation can provide first candidate annotations confirmed rejected additional analyses. MS1 annotation fast efficient method annotate features therefore give first insight compounds significantly different two study groups. However, always accurate. MS2 data can provide higher level confidence annotation process provides, observed fragmentation pattern, information structure compound. MS2 data can generated LC-MS/MS measurement MS2 spectra recorded ions either data dependent acquisition (DDA) data independent acquisition (DIA) mode. Generally, advised include LC-MS/MS runs QC samples randomly selected study samples already acquisition MS1 data used quantification signals. alternative, addition, post-hoc LC-MS/MS acquisition can performed generate MS2 data needed annotation. present experiment, separate LC-MS/MS measurement conducted QC samples selected study samples generate data using inclusion list pre-selected ions. represent features found significantly different CVD CTR samples initial analysis full experiment. use subset second LC-MS/MS data set show data can used MS2-based annotation. differential abundance analysis found features significantly higher abundances CTR samples. Consequently, utilize MS2 data obtained CTR samples annotate significant features. load LC-MS/MS data experiment restrict data acquired CTR sample. Table 10. Samples LC-MS/MS data set. total 3 LC-MS/MS data files control samples, different collision energy fragment ions. show number MS1 MS2 spectra files. Compared number MS2 spectra, far less MS1 spectra acquired. configuration MS instrument set ensure ions specified inclusion list selected fragmentation, even intensity might low. setting, however, recorded MS2 spectra represent noise. plot shows location precursor ions m/z - retention time plane three files.  Figure 35. Precursor ions LC-MS/MS data set. can see MS2 spectra recorded m/z interest along full retention time range, even actual ions eluting within certain retention time windows. next extract Spectra object MS data data object assign new spectra variable employed collision energy, extract data object sampleData. next filter MS data first restricting MS2 spectra removing mass peaks spectrum intensity lower 5% highest intensity spectrum, assuming low intensity peaks represent background signal. next remove also mass peaks m/z value greater equal precursor m/z ion. puts, later matching reference spectra, weight fragmentation pattern ions avoids hits based precursor m/z peak (hence similar mass compared compounds). last, restrict data spectra least two fragment peaks scale intensities sum 1 spectrum. similarity calculations affected scaling, makes visual comparison fragment spectra easier read. Finally, also speed later comparison spectra reference database, load full MS data memory (changing backend MsBackendMemory) apply processing steps performed data far. Keeping MS data memory performance benefits, generally suggested large data sets. evaluate impact present data set print addition size data object changing backend. thus moderate increase memory demand loading MS data memory (also filtered cleaned MS2 data). proceed match experimental MS2 spectra reference fragment spectra, workflow aim annotate features found significant differential abundance analysis. goal thus identify MS2 spectra second (LC-MS/MS) run represent fragments ions features data first (LC-MS) run. approach match MS2 spectra significant features determined earlier based precursor m/z retention time (given acceptable tolerance) feature’s m/z retention time. can easily done using featureArea() function effectively considers actual m/z retention time ranges features’ chromatographic peaks therefore increase chance finding correct match. however also assumes retention times first second run don’t differ much. Alternatively, need align retention times second LC-MS/MS data set first. first extract feature area, .e., m/z retention time ranges, significant features. next identify fragment spectra precursor m/z retention times within ranges. use filterRanges() function allows filter Spectra object using multiple ranges simultaneously. apply function separately feature (row matrix) extract MS2 spectra representing fragmentation information presumed feature’s ions. result apply() call list Spectra, element representing result one feature. exception last feature, multiple MS2 spectra identified. next combine list Spectra single Spectra object using concatenateSpectra() function add additional spectra variable containing respective feature identifier. now Spectra object fragment spectra significant features differential expression analysis. object can used annotation using various tools, see vignette presenting process annotate using python tools [](add later). next build reference data need process way query spectra. extract fragment spectra MassBank database, restrict positive polarity data (since experiment acquired positive polarity) perform processing fragment spectra MassBank database. Note switch MsBackendMemory backend hence loading full data reference database memory. positive impact performance subsequent spectra matching, however also increase memory demand present analysis. Now Spectra object second run database spectra prepared, can proceed matching process. use matchSpectra() function MetaboAnnotation package CompareSpectraParam define settings matching. following parameters: requirePrecursor = TRUE: Limits spectra similarity calculations fragment spectra similar precursor m/z. tolerance ppm: Defines acceptable difference compared m/z values. relaxed tolerance settings ensure find matches even reference spectra acquired instruments lower accuracy. THRESHFUN: Defines matches report. , keep matches resulting spectra similarity score (calculated normalized dot product (Stein Scott 1994), default similarity function) larger 0.6. Thus, total 315 query MS2 spectra, 15 matched (least) one reference fragment spectrum. restrict results matching spectra extract metadata query target spectra well similarity score (complete list available metadata information can listed colnames() function). Now, query-target pairs spectra similarity higher 0.7. Similar MS1-based annotation also result table contains redundant information: multiple fragment spectra per feature also MassBank contains several fragment spectra compound, measured using differing collision energies MS instruments, different laboratories. thus iterate feature-compound pairs select one highest score. identifier compound, use fragment spectra’s INCHI-key, since compound names MassBank accepted consensus/controlled vocabularies. Table 9.MS2 annotation results. Thus, 6 significant features, one annotated compound based MS2-based approach. many reasons failure find matches features. Although MS2 spectra selected feature, appear represent noise, features, LC-MS/MS run, low MS1 signal recorded, indicating selected sample original compound might (longer) present. Also, reference databases contain predominantly fragment spectra protonated ([M+H]+) ions compounds, features might represent signal types ions result different fragmentation pattern. Finally, fragment spectra compounds interest might also simply present used reference database. Thus, combining information MS1- MS2 based annotation can annotate one feature considerable confidence. feature m/z 195.0879 retention time 32 seconds seems ion caffeine. result somewhat disappointing also clearly shows importance proper experimental planning need control potential confounding factors. present experiment, disease-specific biomarker identified, life-style property individuals suffering disease: coffee consumption probably contraindicated patients CVD group reduce risk heart arrhythmia. plot EIC feature highlighting retention time highest scoring MS2 spectra recorded create mirror plot comparing MS2 spectra reference fragment spectra caffeine.  Figure 36. Extracted ion chromatograms MS2 spectra annotated feature.  Figure 37. MS2 spectra annotated feature. plot clearly shows higher signal feature CTR compared CVD samples. QC samples exhibit lower highly consistent signal, suggesting absence strong technical noise biases raw data experiment. vertical line indicates retention time fragment spectrum best match reference spectrum. noted , since fragment spectra measured separate LC-MS/MS experiment, considered indication approximate retention time ions fragmented second experiment. fragment spectrum feature, shown upper panel right plot highly similar reference spectrum caffeine MassBank (shown lower panel). addition matching precursor m/z, two fragments (m/z intensity) present spectra. can also extract additional metadata matching reference spectrum, used collision energy, fragmentation mode, instrument type, instrument well ion (adduct) fragmented. present workflow highlights annotation performed within R using packages Bioconductor project, also excellent external softwares used alternative, SIRIUS (Dührkop et al. 2019), mummichog (Li et al. 2013) GNPS (Nothias et al. 2020) among others. use , data need exported format supported . MS2 spectra, data easily exported required MGF file format using MsBackendMgf Bioconductor package. Integration xcms feature-based molecular networking GNPS described GNPS documentation. alternative, addition, evidence potential matching chemical formula feature derived evaluating isotope pattern full MS1 scan. provide information isotope composition. Also , various functions isotopologues() MetaboCoreUtils package functionality envipat R package (Loos et al. 2015) used.","code":"#' load reference data ah <- AnnotationHub() #' List available MassBank data sets query(ah, \"MassBank\") AnnotationHub with 8 records # snapshotDate(): 2025-04-08 # $dataprovider: MassBank # $species: NA # $rdataclass: CompDb # additional mcols(): taxonomyid, genome, description, #   coordinate_1_based, maintainer, rdatadateadded, preparerclass, tags, #   rdatapath, sourceurl, sourcetype # retrieve records with, e.g., 'object[[\"AH107048\"]]'               title   AH107048 | MassBank CompDb for release 2021.03   AH107049 | MassBank CompDb for release 2022.06   AH111334 | MassBank CompDb for release 2022.12.1   AH116164 | MassBank CompDb for release 2023.06   AH116165 | MassBank CompDb for release 2023.09   AH116166 | MassBank CompDb for release 2023.11   AH119518 | MassBank CompDb for release 2024.06   AH119519 | MassBank CompDb for release 2024.11 #' Load one MassBank release mb <- ah[[\"AH116166\"]] #' Extract compound annotations cmps <- compounds(mb, columns = c(\"name\", \"formula\",                                   \"exactmass\", \"inchikey\")) head(cmps) formula exactmass                    inchikey                 name 1    C27H29NO11  543.1741 AOJJSUZBOXZQNB-UHFFFAOYSA-N           Epirubicin 2      C40H54O4  598.4022 KFNGKYUGHHQDEE-AXWOCEAUSA-N Crassostreaxanthin A 3    C10H24N2O2  204.1838 AEUTYOVWOVBAKS-UWVGGRQHSA-N           Ethambutol 4     C16H27NO5  313.1889 LMFKRLGHEKVMNT-UJDVCPFMSA-N           Heliotrine 5 C20H15Cl3N2OS  435.9971 JLGKQTAYUIMGRK-UHFFFAOYSA-N        Sertaconazole 6      C15H14O5  274.0841 BWNCKEBBYADFPQ-UHFFFAOYSA-N    (R)Semivioxanthin #' Prepare query data frame rowData(res)$feature_id <- rownames(rowData(res)) res_sig <- res[rowData(res)$significant.CVD, ]  #' Setup parameters for the matching param <- Mass2MzParam(adducts = c(\"[M+H]+\", \"[M+Na]+\", \"[M+H-NH3]+\"),                       tolerance = 0, ppm = 5)  #' Perform the matching. mtch <- matchValues(res_sig, cmps, param = param, mzColname = \"mzmed\") mtch Object of class Matched Total number of matches: 43 Number of query objects: 6 (4 matched) Number of target objects: 25685 (43 matched) #' Extracting the results mtch_res <- matchedData(mtch, c(\"feature_id\", \"mzmed\", \"rtmed\",                                 \"adduct\", \"ppm_error\",                                 \"target_formula\", \"target_name\",                                 \"target_inchikey\")) mtch_res DataFrame with 45 rows and 8 columns         feature_id     mzmed     rtmed      adduct ppm_error target_formula        <character> <numeric> <numeric> <character> <numeric>    <character> FT0371      FT0371   138.055   148.396      [M+H]+   2.08055        C7H7NO2 FT0371      FT0371   138.055   148.396      [M+H]+   1.93568        C7H7NO2 FT0371      FT0371   138.055   148.396      [M+H]+   2.08055        C7H7NO2 FT0371      FT0371   138.055   148.396      [M+H]+   1.93568        C7H7NO2 FT0371      FT0371   138.055   148.396      [M+H]+   1.93568        C7H7NO2 ...            ...       ...       ...         ...       ...            ... FT0845      FT0845   195.088   32.6567      [M+H]+ 0.1867474      C8H10N4O2 FT0845      FT0845   195.088   32.6567      [M+H]+ 0.0614704      C8H10N4O2 FT0845      FT0845   195.088   32.6567      [M+H]+ 0.1639884      C8H10N4O2 FT1171      FT1171   229.130  181.0883     [M+Na]+ 3.0770838      C12H18N2O FT5606      FT5606   560.360   33.5492          NA        NA             NA          target_name target_inchikey          <character>     <character> FT0371 Benzohydro...   VDEUYMSGMP... FT0371 Trigonelli...   WWNNZCOKKK... FT0371 Salicylami...   SKZKKFZAGN... FT0371 4-Aminoben...   ALYNCZNDIQ... FT0371 Anthranili...   RWZYAGGXGH... ...              ...             ... FT0845      Caffeine   RYYVLZVUVI... FT0845      caffeine   RYYVLZVUVI... FT0845 1,3,7-TRIM...   RYYVLZVUVI... FT1171 Isoproturo...   PUIYMUZLKQ... FT5606            NA              NA rownames(mtch_res) <- NULL  #' Keep only info on features that machted - create a utility function for that mtch_res <- split(mtch_res, mtch_res$feature_id) |>     lapply(function(x) {         lapply(split(x, x$target_inchikey), function(z) {             z[which.min(z$ppm_error), ]         })     }) |>     unlist(recursive = FALSE) |>     do.call(what = rbind)  #' Display the results kable(mtch_res, format = \"pipe\") #' Load form the MetaboLights Database param <- MetaboLightsParam(mtblsId = \"MTBLS8735\",                            assayName = paste0(\"a_MTBLS8735_LC-MSMS_positive_\",                            \"hilic_metabolite_profiling.txt\"),                            filePattern = \".mzML\")  lcms2 <- readMsObject(MsExperiment(),                      param,                      keepOntology = FALSE,                      keepProtocol = FALSE,                      simplify = TRUE) #adjust sampleData colnames(sampleData(lcms2)) <- c(\"sample_name\", \"derived_spectra_data_file\",                                 \"metabolite_asssignment_file\",                                 \"source_name\",                                 \"organism\",                                 \"blood_sample_type\",                                 \"sample_type\", \"age\", \"unit\", \"phenotype\")  # filter samples to keep MSMS data from CTR samples: sampleData(lcms2) <- sampleData(lcms2)[sampleData(lcms2)$phenotype == \"CTR\", ]  sampleData(lcms2) <- sampleData(lcms2)[grepl(\"MSMS\", sampleData(lcms2)$derived_spectra_data_file), ]  # Add fragmentation data information (from filenames) sampleData(lcms2)$fragmentation_mode <- c(\"CE20\", \"CE30\", \"CES\")  #let's look at the updated sample data sampleData(lcms2)[, c(\"derived_spectra_data_file\",                      \"phenotype\", \"sample_name\", \"age\")] |>     kable(format = \"pipe\") #' Filter the data to the same RT range as the LC-MS run lcms2 <- filterRt(lcms2, c(10, 240)) #' check the number of spectra per ms level spectra(lcms2) |>     msLevel() |>     split(spectraSampleIndex(lcms2)) |>     lapply(table) |>     do.call(what = cbind) 1    2    3    4   5    6    7    8   9   10   11   12 1 825  186  186  186 825  186  186  186 825  185  186  185 2 825 3121 3118 3124 825 3123 3118 3120 825 3117 3117 3116 plotPrecursorIons(lcms2) ms2_ctr <- spectra(lcms2) ms2_ctr$collision_energy <-     sampleData(lcms2)$fragmentation_mode[spectraSampleIndex(lcms2)] #' Remove low intensity peaks low_int <- function(x, ...) {     x > max(x, na.rm = TRUE) * 0.05 }  ms2_ctr <- filterMsLevel(ms2_ctr, 2L) |>     filterIntensity(intensity = low_int) #' Remove precursor peaks and restrict to spectra with a minimum #' number of peaks ms2_ctr <- filterPrecursorPeaks(ms2_ctr, ppm = 50, mz = \">=\") ms2_ctr <- ms2_ctr[lengths(ms2_ctr) > 1] |>     scalePeaks() #' Size of the object before loading into memory print(object.size(ms2_ctr), units = \"MB\") 5.2 Mb #' Load the MS data subset into memory ms2_ctr <- setBackend(ms2_ctr, MsBackendMemory()) ms2_ctr <- applyProcessing(ms2_ctr)  #' Size of the object after loading into memory print(object.size(ms2_ctr), units = \"MB\") 18.4 Mb #' Define the m/z and retention time ranges for the significant features target <- featureArea(lcms1)[rownames(res_sig), ] target mzmin    mzmax     rtmin     rtmax FT0371 138.0544 138.0552 146.32270 152.86115 FT0565 161.0391 161.0407 159.00234 164.30799 FT0732 182.0726 182.0756  32.71242  42.28755 FT0845 195.0799 195.0887  30.73235  35.67337 FT1171 229.1282 229.1335 178.01450 183.35303 FT5606 560.3539 560.3656  32.06570  35.33456 #' Identify for each feature MS2 spectra with their precursor m/z and #' retention time within the feature's m/z and retention time range ms2_ctr_fts <- apply(target[, c(\"rtmin\", \"rtmax\", \"mzmin\", \"mzmax\")],                      MARGIN = 1, FUN = filterRanges, object = ms2_ctr,                      spectraVariables = c(\"rtime\", \"precursorMz\")) lengths(ms2_ctr_fts) FT0371 FT0565 FT0732 FT0845 FT1171 FT5606     38     36    135     68     38      0 l <- lengths(ms2_ctr_fts) #' Combine the individual Spectra objects ms2_ctr_fts <- concatenateSpectra(ms2_ctr_fts) #' Assign the feature identifier to each MS2 spectrum ms2_ctr_fts$feature_id <- rep(rownames(res_sig), l)  ## Save for reuse in other vignettes save(ms2_ctr_fts, file = \"objects/spectra_significant_fts.RData\") ms2_ref <- Spectra(mb) |>     filterPolarity(1L) |>     filterIntensity(intensity = low_int) |>     filterPrecursorPeaks(ppm = 50, mz = \">=\") ms2_ref <- ms2_ref[lengths(ms2_ref) > 1] |>     scalePeaks() register(SerialParam()) #' Define the settings for the spectra matching. prm <- CompareSpectraParam(ppm = 40, tolerance = 0.05,                            requirePrecursor = TRUE,                            THRESHFUN = function(x) which(x >= 0.7))  ms2_mtch <- matchSpectra(ms2_ctr_fts, ms2_ref, param = prm) ms2_mtch Object of class MatchedSpectra Total number of matches: 176 Number of query objects: 315 (15 matched) Number of target objects: 69561 (14 matched) #' Keep only query spectra with matching reference spectra ms2_mtch <- ms2_mtch[whichQuery(ms2_mtch)]  #' Extract the results ms2_mtch_res <- matchedData(ms2_mtch) nrow(ms2_mtch_res) [1] 176 #' - split the result per feature #' - select for each feature the best matching result for each compound #' - combine the result again into a data frame ms2_mtch_res <-     ms2_mtch_res |>     split(f = paste(ms2_mtch_res$feature_id, ms2_mtch_res$target_inchikey)) |>     lapply(function(z) {         z[which.max(z$score), ]     }) |>     do.call(what = rbind) |>     as.data.frame()  #' List the best matching feature-compound pair pandoc.table(ms2_mtch_res[, c(\"feature_id\", \"target_name\", \"score\",                               \"target_inchikey\")],              style = \"rmarkdown\",              caption = \"Table 9.MS2 annotation results.\",              split.table = Inf) col_sample <- col_phenotype[sampleData(lcms1)$phenotype] #' Extract and plot EIC for the annotated feature eic <- featureChromatograms(lcms1, features = ms2_mtch_res$feature_id[1]) plot(eic, col = col_sample, peakCol = col_sample[chromPeaks(eic)[, \"sample\"]],      peakBg = paste0(col_sample[chromPeaks(eic)[, \"sample\"]], 20)) legend(\"topright\", col = col_phenotype, legend = names(col_phenotype), lty = 1)  #' Identify the best matching query-target spectra pair idx <- which.max(ms2_mtch_res$score)  #' Indicate the retention time of the MS2 spectrum in the EIC plot abline(v = ms2_mtch_res$rtime[idx]) #' Get the index of the MS2 spectrum in the query object query_idx <- which(query(ms2_mtch)$.original_query_index ==                                   ms2_mtch_res$.original_query_index[idx]) query_ms2 <- query(ms2_mtch)[query_idx] #' Get the index of the MS2 spectrum in the target object target_idx <- which(target(ms2_mtch)$spectrum_id ==                                     ms2_mtch_res$target_spectrum_id[idx]) target_ms2 <- target(ms2_mtch)[target_idx]  #' Create a mirror plot comparing the two best matching spectra plotSpectraMirror(query_ms2, target_ms2) legend(\"topleft\",        legend = paste0(\"precursor m/z: \", format(precursorMz(query_ms2), 3))) spectraData(target_ms2, c(\"collisionEnergy_text\", \"fragmentation_mode\",                           \"instrument_type\", \"instrument\", \"adduct\")) |>     as.data.frame() collisionEnergy_text fragmentation_mode instrument_type 1         55 (nominal)                HCD     LC-ESI-ITFT                          instrument adduct 1 LTQ Orbitrap XL Thermo Scientific [M+H]+"},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/a-end-to-end-untargeted-metabolomics.html","id":"ms1-based-annotation","dir":"Articles","previous_headings":"","what":"MS1-based annotation","title":"Complete end-to-end LC-MS/MS Metabolomic Data analysis","text":"data set acquired using LC-MS setup features thus characterized m/z retention times. retention time LC-setup-specific , without prior data/knowledge provide little information features’ identity. Modern MS instruments high accuracy m/z values therefore reliable estimates compound ion’s mass--charge ratio. first approach, use features’ m/z values match reference values, .e., exact masses chemical compounds provided reference database, case MassBank database. full MassBank data re-distributed Bioconductor’s AnnotationHub resource, simplifies integration reproducible R-based analysis workflows. load resource, list available MassBank data sets/releases load one . MassBank data provided self-contained SQLite database data can queried accessed CompoundDb Bioconductor package. use compounds() function extract small compound annotations database. MassBank (small compound annotation databases) provides (exact) molecular mass compound. Since almost small compounds neutral natural state, need first converted m/z values allow matching feature’s m/z. calculate m/z neutral mass, need assume ion (adduct) might generated measured metabolites employed electro-spray ionization. positive polarity, human serum samples, common ions protonated ([M+H]+), bear addition sodium ([M+Na]+) ammonium ([M+H-NH3]+) ions. match observed m/z values reference values potential ions use matchValues() function Mass2MzParam approach, allows specify types expected ions adducts parameter maximal allowed difference compared values using tolerance ppm parameters. first prepare data.frame significant features, set parameters matching perform comparison query features reference database. resulting Matched object shows 4 6 significant features matched ions compounds MassBank database. extract full result Matched object. Thus, total 43 ions compounds MassBank matched significant features based specified tolerance settings. Many compounds, different structure thus function/chemical property, identical chemical formula thus mass. Matching exclusively m/z features hence result many potentially false positive hits thus considered provide low confidence annotation. additional complication annotation resources, like MassBank, community maintained, contain large amount redundant information. reduce redundancy result table iterate hits feature keep matches unique compounds (identified INCHIKEY). INCHI INCHIKEY combine information compound’s chemical formula structure, different compounds can share chemical formula, different structure thus INCHI. Table 9. MS1 annotation results. table shows results MS1-based annotation process. can see four significant features matched. matches seem pretty accurate low ppm errors. deduplication performed considerably reduced number hits feature, first still matches ions large number compounds (chemical formula). Considering features’ m/z retention times MS1-based annotation increase annotation confidence, requires additional data, recording retention time thepure standard compound LC setup. alternative approach might provide better inside annotations help choose different annotations feature evaluate certain chemical properties possible matches. instance, LogP value, available several databases HMDB, provides insight given compound’s polarity. property highly affects interaction analyte column, usually also directly affects separation. Therefore, comparison analyte’s retention time polarity can help rule possible misidentifications. low confidence, MS1-based annotation can provide first candidate annotations confirmed rejected additional analyses.","code":"#' load reference data ah <- AnnotationHub() #' List available MassBank data sets query(ah, \"MassBank\") AnnotationHub with 8 records # snapshotDate(): 2025-04-08 # $dataprovider: MassBank # $species: NA # $rdataclass: CompDb # additional mcols(): taxonomyid, genome, description, #   coordinate_1_based, maintainer, rdatadateadded, preparerclass, tags, #   rdatapath, sourceurl, sourcetype # retrieve records with, e.g., 'object[[\"AH107048\"]]'               title   AH107048 | MassBank CompDb for release 2021.03   AH107049 | MassBank CompDb for release 2022.06   AH111334 | MassBank CompDb for release 2022.12.1   AH116164 | MassBank CompDb for release 2023.06   AH116165 | MassBank CompDb for release 2023.09   AH116166 | MassBank CompDb for release 2023.11   AH119518 | MassBank CompDb for release 2024.06   AH119519 | MassBank CompDb for release 2024.11 #' Load one MassBank release mb <- ah[[\"AH116166\"]] #' Extract compound annotations cmps <- compounds(mb, columns = c(\"name\", \"formula\",                                   \"exactmass\", \"inchikey\")) head(cmps) formula exactmass                    inchikey                 name 1    C27H29NO11  543.1741 AOJJSUZBOXZQNB-UHFFFAOYSA-N           Epirubicin 2      C40H54O4  598.4022 KFNGKYUGHHQDEE-AXWOCEAUSA-N Crassostreaxanthin A 3    C10H24N2O2  204.1838 AEUTYOVWOVBAKS-UWVGGRQHSA-N           Ethambutol 4     C16H27NO5  313.1889 LMFKRLGHEKVMNT-UJDVCPFMSA-N           Heliotrine 5 C20H15Cl3N2OS  435.9971 JLGKQTAYUIMGRK-UHFFFAOYSA-N        Sertaconazole 6      C15H14O5  274.0841 BWNCKEBBYADFPQ-UHFFFAOYSA-N    (R)Semivioxanthin #' Prepare query data frame rowData(res)$feature_id <- rownames(rowData(res)) res_sig <- res[rowData(res)$significant.CVD, ]  #' Setup parameters for the matching param <- Mass2MzParam(adducts = c(\"[M+H]+\", \"[M+Na]+\", \"[M+H-NH3]+\"),                       tolerance = 0, ppm = 5)  #' Perform the matching. mtch <- matchValues(res_sig, cmps, param = param, mzColname = \"mzmed\") mtch Object of class Matched Total number of matches: 43 Number of query objects: 6 (4 matched) Number of target objects: 25685 (43 matched) #' Extracting the results mtch_res <- matchedData(mtch, c(\"feature_id\", \"mzmed\", \"rtmed\",                                 \"adduct\", \"ppm_error\",                                 \"target_formula\", \"target_name\",                                 \"target_inchikey\")) mtch_res DataFrame with 45 rows and 8 columns         feature_id     mzmed     rtmed      adduct ppm_error target_formula        <character> <numeric> <numeric> <character> <numeric>    <character> FT0371      FT0371   138.055   148.396      [M+H]+   2.08055        C7H7NO2 FT0371      FT0371   138.055   148.396      [M+H]+   1.93568        C7H7NO2 FT0371      FT0371   138.055   148.396      [M+H]+   2.08055        C7H7NO2 FT0371      FT0371   138.055   148.396      [M+H]+   1.93568        C7H7NO2 FT0371      FT0371   138.055   148.396      [M+H]+   1.93568        C7H7NO2 ...            ...       ...       ...         ...       ...            ... FT0845      FT0845   195.088   32.6567      [M+H]+ 0.1867474      C8H10N4O2 FT0845      FT0845   195.088   32.6567      [M+H]+ 0.0614704      C8H10N4O2 FT0845      FT0845   195.088   32.6567      [M+H]+ 0.1639884      C8H10N4O2 FT1171      FT1171   229.130  181.0883     [M+Na]+ 3.0770838      C12H18N2O FT5606      FT5606   560.360   33.5492          NA        NA             NA          target_name target_inchikey          <character>     <character> FT0371 Benzohydro...   VDEUYMSGMP... FT0371 Trigonelli...   WWNNZCOKKK... FT0371 Salicylami...   SKZKKFZAGN... FT0371 4-Aminoben...   ALYNCZNDIQ... FT0371 Anthranili...   RWZYAGGXGH... ...              ...             ... FT0845      Caffeine   RYYVLZVUVI... FT0845      caffeine   RYYVLZVUVI... FT0845 1,3,7-TRIM...   RYYVLZVUVI... FT1171 Isoproturo...   PUIYMUZLKQ... FT5606            NA              NA rownames(mtch_res) <- NULL  #' Keep only info on features that machted - create a utility function for that mtch_res <- split(mtch_res, mtch_res$feature_id) |>     lapply(function(x) {         lapply(split(x, x$target_inchikey), function(z) {             z[which.min(z$ppm_error), ]         })     }) |>     unlist(recursive = FALSE) |>     do.call(what = rbind)  #' Display the results kable(mtch_res, format = \"pipe\")"},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/a-end-to-end-untargeted-metabolomics.html","id":"ms2-based-annotation","dir":"Articles","previous_headings":"","what":"MS2-based annotation","title":"Complete end-to-end LC-MS/MS Metabolomic Data analysis","text":"MS1 annotation fast efficient method annotate features therefore give first insight compounds significantly different two study groups. However, always accurate. MS2 data can provide higher level confidence annotation process provides, observed fragmentation pattern, information structure compound. MS2 data can generated LC-MS/MS measurement MS2 spectra recorded ions either data dependent acquisition (DDA) data independent acquisition (DIA) mode. Generally, advised include LC-MS/MS runs QC samples randomly selected study samples already acquisition MS1 data used quantification signals. alternative, addition, post-hoc LC-MS/MS acquisition can performed generate MS2 data needed annotation. present experiment, separate LC-MS/MS measurement conducted QC samples selected study samples generate data using inclusion list pre-selected ions. represent features found significantly different CVD CTR samples initial analysis full experiment. use subset second LC-MS/MS data set show data can used MS2-based annotation. differential abundance analysis found features significantly higher abundances CTR samples. Consequently, utilize MS2 data obtained CTR samples annotate significant features. load LC-MS/MS data experiment restrict data acquired CTR sample. Table 10. Samples LC-MS/MS data set. total 3 LC-MS/MS data files control samples, different collision energy fragment ions. show number MS1 MS2 spectra files. Compared number MS2 spectra, far less MS1 spectra acquired. configuration MS instrument set ensure ions specified inclusion list selected fragmentation, even intensity might low. setting, however, recorded MS2 spectra represent noise. plot shows location precursor ions m/z - retention time plane three files.  Figure 35. Precursor ions LC-MS/MS data set. can see MS2 spectra recorded m/z interest along full retention time range, even actual ions eluting within certain retention time windows. next extract Spectra object MS data data object assign new spectra variable employed collision energy, extract data object sampleData. next filter MS data first restricting MS2 spectra removing mass peaks spectrum intensity lower 5% highest intensity spectrum, assuming low intensity peaks represent background signal. next remove also mass peaks m/z value greater equal precursor m/z ion. puts, later matching reference spectra, weight fragmentation pattern ions avoids hits based precursor m/z peak (hence similar mass compared compounds). last, restrict data spectra least two fragment peaks scale intensities sum 1 spectrum. similarity calculations affected scaling, makes visual comparison fragment spectra easier read. Finally, also speed later comparison spectra reference database, load full MS data memory (changing backend MsBackendMemory) apply processing steps performed data far. Keeping MS data memory performance benefits, generally suggested large data sets. evaluate impact present data set print addition size data object changing backend. thus moderate increase memory demand loading MS data memory (also filtered cleaned MS2 data). proceed match experimental MS2 spectra reference fragment spectra, workflow aim annotate features found significant differential abundance analysis. goal thus identify MS2 spectra second (LC-MS/MS) run represent fragments ions features data first (LC-MS) run. approach match MS2 spectra significant features determined earlier based precursor m/z retention time (given acceptable tolerance) feature’s m/z retention time. can easily done using featureArea() function effectively considers actual m/z retention time ranges features’ chromatographic peaks therefore increase chance finding correct match. however also assumes retention times first second run don’t differ much. Alternatively, need align retention times second LC-MS/MS data set first. first extract feature area, .e., m/z retention time ranges, significant features. next identify fragment spectra precursor m/z retention times within ranges. use filterRanges() function allows filter Spectra object using multiple ranges simultaneously. apply function separately feature (row matrix) extract MS2 spectra representing fragmentation information presumed feature’s ions. result apply() call list Spectra, element representing result one feature. exception last feature, multiple MS2 spectra identified. next combine list Spectra single Spectra object using concatenateSpectra() function add additional spectra variable containing respective feature identifier. now Spectra object fragment spectra significant features differential expression analysis. object can used annotation using various tools, see vignette presenting process annotate using python tools [](add later). next build reference data need process way query spectra. extract fragment spectra MassBank database, restrict positive polarity data (since experiment acquired positive polarity) perform processing fragment spectra MassBank database. Note switch MsBackendMemory backend hence loading full data reference database memory. positive impact performance subsequent spectra matching, however also increase memory demand present analysis. Now Spectra object second run database spectra prepared, can proceed matching process. use matchSpectra() function MetaboAnnotation package CompareSpectraParam define settings matching. following parameters: requirePrecursor = TRUE: Limits spectra similarity calculations fragment spectra similar precursor m/z. tolerance ppm: Defines acceptable difference compared m/z values. relaxed tolerance settings ensure find matches even reference spectra acquired instruments lower accuracy. THRESHFUN: Defines matches report. , keep matches resulting spectra similarity score (calculated normalized dot product (Stein Scott 1994), default similarity function) larger 0.6. Thus, total 315 query MS2 spectra, 15 matched (least) one reference fragment spectrum. restrict results matching spectra extract metadata query target spectra well similarity score (complete list available metadata information can listed colnames() function). Now, query-target pairs spectra similarity higher 0.7. Similar MS1-based annotation also result table contains redundant information: multiple fragment spectra per feature also MassBank contains several fragment spectra compound, measured using differing collision energies MS instruments, different laboratories. thus iterate feature-compound pairs select one highest score. identifier compound, use fragment spectra’s INCHI-key, since compound names MassBank accepted consensus/controlled vocabularies. Table 9.MS2 annotation results. Thus, 6 significant features, one annotated compound based MS2-based approach. many reasons failure find matches features. Although MS2 spectra selected feature, appear represent noise, features, LC-MS/MS run, low MS1 signal recorded, indicating selected sample original compound might (longer) present. Also, reference databases contain predominantly fragment spectra protonated ([M+H]+) ions compounds, features might represent signal types ions result different fragmentation pattern. Finally, fragment spectra compounds interest might also simply present used reference database. Thus, combining information MS1- MS2 based annotation can annotate one feature considerable confidence. feature m/z 195.0879 retention time 32 seconds seems ion caffeine. result somewhat disappointing also clearly shows importance proper experimental planning need control potential confounding factors. present experiment, disease-specific biomarker identified, life-style property individuals suffering disease: coffee consumption probably contraindicated patients CVD group reduce risk heart arrhythmia. plot EIC feature highlighting retention time highest scoring MS2 spectra recorded create mirror plot comparing MS2 spectra reference fragment spectra caffeine.  Figure 36. Extracted ion chromatograms MS2 spectra annotated feature.  Figure 37. MS2 spectra annotated feature. plot clearly shows higher signal feature CTR compared CVD samples. QC samples exhibit lower highly consistent signal, suggesting absence strong technical noise biases raw data experiment. vertical line indicates retention time fragment spectrum best match reference spectrum. noted , since fragment spectra measured separate LC-MS/MS experiment, considered indication approximate retention time ions fragmented second experiment. fragment spectrum feature, shown upper panel right plot highly similar reference spectrum caffeine MassBank (shown lower panel). addition matching precursor m/z, two fragments (m/z intensity) present spectra. can also extract additional metadata matching reference spectrum, used collision energy, fragmentation mode, instrument type, instrument well ion (adduct) fragmented.","code":"#' Load form the MetaboLights Database param <- MetaboLightsParam(mtblsId = \"MTBLS8735\",                            assayName = paste0(\"a_MTBLS8735_LC-MSMS_positive_\",                            \"hilic_metabolite_profiling.txt\"),                            filePattern = \".mzML\")  lcms2 <- readMsObject(MsExperiment(),                      param,                      keepOntology = FALSE,                      keepProtocol = FALSE,                      simplify = TRUE) #adjust sampleData colnames(sampleData(lcms2)) <- c(\"sample_name\", \"derived_spectra_data_file\",                                 \"metabolite_asssignment_file\",                                 \"source_name\",                                 \"organism\",                                 \"blood_sample_type\",                                 \"sample_type\", \"age\", \"unit\", \"phenotype\")  # filter samples to keep MSMS data from CTR samples: sampleData(lcms2) <- sampleData(lcms2)[sampleData(lcms2)$phenotype == \"CTR\", ]  sampleData(lcms2) <- sampleData(lcms2)[grepl(\"MSMS\", sampleData(lcms2)$derived_spectra_data_file), ]  # Add fragmentation data information (from filenames) sampleData(lcms2)$fragmentation_mode <- c(\"CE20\", \"CE30\", \"CES\")  #let's look at the updated sample data sampleData(lcms2)[, c(\"derived_spectra_data_file\",                      \"phenotype\", \"sample_name\", \"age\")] |>     kable(format = \"pipe\") #' Filter the data to the same RT range as the LC-MS run lcms2 <- filterRt(lcms2, c(10, 240)) #' check the number of spectra per ms level spectra(lcms2) |>     msLevel() |>     split(spectraSampleIndex(lcms2)) |>     lapply(table) |>     do.call(what = cbind) 1    2    3    4   5    6    7    8   9   10   11   12 1 825  186  186  186 825  186  186  186 825  185  186  185 2 825 3121 3118 3124 825 3123 3118 3120 825 3117 3117 3116 plotPrecursorIons(lcms2) ms2_ctr <- spectra(lcms2) ms2_ctr$collision_energy <-     sampleData(lcms2)$fragmentation_mode[spectraSampleIndex(lcms2)] #' Remove low intensity peaks low_int <- function(x, ...) {     x > max(x, na.rm = TRUE) * 0.05 }  ms2_ctr <- filterMsLevel(ms2_ctr, 2L) |>     filterIntensity(intensity = low_int) #' Remove precursor peaks and restrict to spectra with a minimum #' number of peaks ms2_ctr <- filterPrecursorPeaks(ms2_ctr, ppm = 50, mz = \">=\") ms2_ctr <- ms2_ctr[lengths(ms2_ctr) > 1] |>     scalePeaks() #' Size of the object before loading into memory print(object.size(ms2_ctr), units = \"MB\") 5.2 Mb #' Load the MS data subset into memory ms2_ctr <- setBackend(ms2_ctr, MsBackendMemory()) ms2_ctr <- applyProcessing(ms2_ctr)  #' Size of the object after loading into memory print(object.size(ms2_ctr), units = \"MB\") 18.4 Mb #' Define the m/z and retention time ranges for the significant features target <- featureArea(lcms1)[rownames(res_sig), ] target mzmin    mzmax     rtmin     rtmax FT0371 138.0544 138.0552 146.32270 152.86115 FT0565 161.0391 161.0407 159.00234 164.30799 FT0732 182.0726 182.0756  32.71242  42.28755 FT0845 195.0799 195.0887  30.73235  35.67337 FT1171 229.1282 229.1335 178.01450 183.35303 FT5606 560.3539 560.3656  32.06570  35.33456 #' Identify for each feature MS2 spectra with their precursor m/z and #' retention time within the feature's m/z and retention time range ms2_ctr_fts <- apply(target[, c(\"rtmin\", \"rtmax\", \"mzmin\", \"mzmax\")],                      MARGIN = 1, FUN = filterRanges, object = ms2_ctr,                      spectraVariables = c(\"rtime\", \"precursorMz\")) lengths(ms2_ctr_fts) FT0371 FT0565 FT0732 FT0845 FT1171 FT5606     38     36    135     68     38      0 l <- lengths(ms2_ctr_fts) #' Combine the individual Spectra objects ms2_ctr_fts <- concatenateSpectra(ms2_ctr_fts) #' Assign the feature identifier to each MS2 spectrum ms2_ctr_fts$feature_id <- rep(rownames(res_sig), l)  ## Save for reuse in other vignettes save(ms2_ctr_fts, file = \"objects/spectra_significant_fts.RData\") ms2_ref <- Spectra(mb) |>     filterPolarity(1L) |>     filterIntensity(intensity = low_int) |>     filterPrecursorPeaks(ppm = 50, mz = \">=\") ms2_ref <- ms2_ref[lengths(ms2_ref) > 1] |>     scalePeaks() register(SerialParam()) #' Define the settings for the spectra matching. prm <- CompareSpectraParam(ppm = 40, tolerance = 0.05,                            requirePrecursor = TRUE,                            THRESHFUN = function(x) which(x >= 0.7))  ms2_mtch <- matchSpectra(ms2_ctr_fts, ms2_ref, param = prm) ms2_mtch Object of class MatchedSpectra Total number of matches: 176 Number of query objects: 315 (15 matched) Number of target objects: 69561 (14 matched) #' Keep only query spectra with matching reference spectra ms2_mtch <- ms2_mtch[whichQuery(ms2_mtch)]  #' Extract the results ms2_mtch_res <- matchedData(ms2_mtch) nrow(ms2_mtch_res) [1] 176 #' - split the result per feature #' - select for each feature the best matching result for each compound #' - combine the result again into a data frame ms2_mtch_res <-     ms2_mtch_res |>     split(f = paste(ms2_mtch_res$feature_id, ms2_mtch_res$target_inchikey)) |>     lapply(function(z) {         z[which.max(z$score), ]     }) |>     do.call(what = rbind) |>     as.data.frame()  #' List the best matching feature-compound pair pandoc.table(ms2_mtch_res[, c(\"feature_id\", \"target_name\", \"score\",                               \"target_inchikey\")],              style = \"rmarkdown\",              caption = \"Table 9.MS2 annotation results.\",              split.table = Inf) col_sample <- col_phenotype[sampleData(lcms1)$phenotype] #' Extract and plot EIC for the annotated feature eic <- featureChromatograms(lcms1, features = ms2_mtch_res$feature_id[1]) plot(eic, col = col_sample, peakCol = col_sample[chromPeaks(eic)[, \"sample\"]],      peakBg = paste0(col_sample[chromPeaks(eic)[, \"sample\"]], 20)) legend(\"topright\", col = col_phenotype, legend = names(col_phenotype), lty = 1)  #' Identify the best matching query-target spectra pair idx <- which.max(ms2_mtch_res$score)  #' Indicate the retention time of the MS2 spectrum in the EIC plot abline(v = ms2_mtch_res$rtime[idx]) #' Get the index of the MS2 spectrum in the query object query_idx <- which(query(ms2_mtch)$.original_query_index ==                                   ms2_mtch_res$.original_query_index[idx]) query_ms2 <- query(ms2_mtch)[query_idx] #' Get the index of the MS2 spectrum in the target object target_idx <- which(target(ms2_mtch)$spectrum_id ==                                     ms2_mtch_res$target_spectrum_id[idx]) target_ms2 <- target(ms2_mtch)[target_idx]  #' Create a mirror plot comparing the two best matching spectra plotSpectraMirror(query_ms2, target_ms2) legend(\"topleft\",        legend = paste0(\"precursor m/z: \", format(precursorMz(query_ms2), 3))) spectraData(target_ms2, c(\"collisionEnergy_text\", \"fragmentation_mode\",                           \"instrument_type\", \"instrument\", \"adduct\")) |>     as.data.frame() collisionEnergy_text fragmentation_mode instrument_type 1         55 (nominal)                HCD     LC-ESI-ITFT                          instrument adduct 1 LTQ Orbitrap XL Thermo Scientific [M+H]+"},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/a-end-to-end-untargeted-metabolomics.html","id":"external-tools-or-alternative-annotation-approaches","dir":"Articles","previous_headings":"","what":"External tools or alternative annotation approaches","title":"Complete end-to-end LC-MS/MS Metabolomic Data analysis","text":"present workflow highlights annotation performed within R using packages Bioconductor project, also excellent external softwares used alternative, SIRIUS (Dührkop et al. 2019), mummichog (Li et al. 2013) GNPS (Nothias et al. 2020) among others. use , data need exported format supported . MS2 spectra, data easily exported required MGF file format using MsBackendMgf Bioconductor package. Integration xcms feature-based molecular networking GNPS described GNPS documentation. alternative, addition, evidence potential matching chemical formula feature derived evaluating isotope pattern full MS1 scan. provide information isotope composition. Also , various functions isotopologues() MetaboCoreUtils package functionality envipat R package (Loos et al. 2015) used.","code":""},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/a-end-to-end-untargeted-metabolomics.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Complete end-to-end LC-MS/MS Metabolomic Data analysis","text":"tutorial, describe end--end workflow LC-MS-based untargeted metabolomics experiments, conducted entirely within R using packages Bioconductor project base R functionality. excellent software exists perform similar analyses, power R-based workflow lies adaptability individual data sets research questions ability build reproducible workflows documentation. Due space restrictions don’t provide comprehensive listing methodologies individual analysis steps. advanced options approaches available, e.g., normalization data, however also heavily dependent size properties analyzed data set, well annotation features. result, found present analysis set features significant abundance differences compared groups. however reliably annotate single feature, related lifestyle individuals rather pathological properties investigated disease. low proportion annotated signals however uncommon untargeted metabolomics experiments reflects need comprehensive reliable reference annotation libraries.","code":""},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/a-end-to-end-untargeted-metabolomics.html","id":"session-information","dir":"Articles","previous_headings":"","what":"Session information","title":"Complete end-to-end LC-MS/MS Metabolomic Data analysis","text":"","code":"sessionInfo() R version 4.5.1 (2025-06-13) Platform: x86_64-pc-linux-gnu Running under: Ubuntu 24.04.2 LTS  Matrix products: default BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3 LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.26.so;  LAPACK version 3.12.0  locale:  [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C  [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8  [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8  [7] LC_PAPER=en_US.UTF-8       LC_NAME=C  [9] LC_ADDRESS=C               LC_TELEPHONE=C [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C  time zone: Etc/UTC tzcode source: system (glibc)  attached base packages: [1] stats4    stats     graphics  grDevices utils     datasets  methods [8] base  other attached packages:  [1] UpSetR_1.4.0                ggVennDiagram_1.5.4  [3] MetaboAnnotation_1.12.0     CompoundDb_1.12.1  [5] AnnotationFilter_1.32.0     AnnotationHub_3.16.0  [7] BiocFileCache_2.16.0        dbplyr_2.5.0  [9] gridExtra_2.3               ggfortify_0.4.18 [11] ggplot2_3.5.2               vioplot_0.5.1 [13] zoo_1.8-14                  sm_2.2-6.0 [15] pheatmap_1.0.13             RColorBrewer_1.1-3 [17] pander_0.6.6                limma_3.64.1 [19] MetaboCoreUtils_1.16.1      xcms_4.6.3 [21] MsBackendMetaboLights_1.3.1 Spectra_1.18.2 [23] BiocParallel_1.42.1         alabaster.se_1.8.0 [25] alabaster.base_1.8.0        SummarizedExperiment_1.38.1 [27] Biobase_2.68.0              GenomicRanges_1.60.0 [29] GenomeInfoDb_1.44.0         IRanges_2.42.0 [31] S4Vectors_0.46.0            BiocGenerics_0.54.0 [33] generics_0.1.4              MatrixGenerics_1.20.0 [35] matrixStats_1.5.0           MsIO_0.0.9 [37] MsExperiment_1.10.1         ProtGenerics_1.40.0 [39] readxl_1.4.5                BiocStyle_2.36.0 [41] quarto_1.4.4.9025           knitr_1.50  loaded via a namespace (and not attached):   [1] later_1.4.2                 bitops_1.0-9   [3] filelock_1.0.3              tibble_3.3.0   [5] cellranger_1.1.0            preprocessCore_1.70.0   [7] XML_3.99-0.18               lifecycle_1.0.4   [9] doParallel_1.0.17           processx_3.8.6  [11] lattice_0.22-7              MASS_7.3-65  [13] MultiAssayExperiment_1.34.0 magrittr_2.0.3  [15] rmarkdown_2.29              yaml_2.3.10  [17] MsCoreUtils_1.20.0          DBI_1.2.3  [19] abind_1.4-8                 purrr_1.1.0  [21] RCurl_1.98-1.17             rappdirs_0.3.3  [23] GenomeInfoDbData_1.2.14     MSnbase_2.34.1  [25] ncdf4_1.24                  codetools_0.2-20  [27] DelayedArray_0.34.1         DT_0.33  [29] xml2_1.3.8                  tidyselect_1.2.1  [31] UCSC.utils_1.4.0            farver_2.1.2  [33] base64enc_0.1-3             jsonlite_2.0.0  [35] iterators_1.0.14            foreach_1.5.2  [37] tools_4.5.1                 progress_1.2.3  [39] Rcpp_1.1.0                  glue_1.8.0  [41] SparseArray_1.8.0           BiocBaseUtils_1.10.0  [43] xfun_0.52                   dplyr_1.1.4  [45] HDF5Array_1.36.0            withr_3.0.2  [47] BiocManager_1.30.26         fastmap_1.2.0  [49] rhdf5filters_1.20.0         digest_0.6.37  [51] mime_0.13                   R6_2.6.1  [53] rsvg_2.6.2                  RSQLite_2.4.1  [55] h5mread_1.0.1               tidyr_1.3.1  [57] prettyunits_1.2.0           PSMatch_1.12.0  [59] httr_1.4.7                  htmlwidgets_1.6.4  [61] S4Arrays_1.8.1              pkgconfig_2.0.3  [63] gtable_0.3.6                blob_1.2.4  [65] impute_1.82.0               MassSpecWavelet_1.74.0  [67] XVector_0.48.0              htmltools_0.5.8.1  [69] MALDIquant_1.22.3           clue_0.3-66  [71] scales_1.4.0                alabaster.matrix_1.8.0  [73] png_0.1-8                   rstudioapi_0.17.1  [75] reshape2_1.4.4              rjson_0.2.23  [77] curl_6.4.0                  cachem_1.1.0  [79] rhdf5_2.52.1                stringr_1.5.1  [81] BiocVersion_3.21.1          parallel_4.5.1  [83] AnnotationDbi_1.70.0        mzID_1.46.0  [85] vsn_3.76.0                  pillar_1.11.0  [87] grid_4.5.1                  alabaster.schemas_1.8.0  [89] vctrs_0.6.5                 MsFeatures_1.16.0  [91] pcaMethods_2.0.0            cluster_2.1.8.1  [93] evaluate_1.0.4              cli_3.6.5  [95] compiler_4.5.1              rlang_1.1.6  [97] crayon_1.5.3                labeling_0.4.3  [99] QFeatures_1.18.0            ChemmineR_3.60.0 [101] ps_1.9.1                    affy_1.86.0 [103] plyr_1.8.9                  fs_1.6.6 [105] stringi_1.8.7               Biostrings_2.76.0 [107] lazyeval_0.2.2              Matrix_1.7-3 [109] hms_1.1.3                   bit64_4.6.0-1 [111] Rhdf5lib_1.30.0             KEGGREST_1.48.1 [113] statmod_1.5.0               alabaster.ranges_1.8.0 [115] mzR_2.42.0                  igraph_2.1.4 [117] memoise_2.0.1               affyio_1.78.0 [119] bit_4.6.0"},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/a-end-to-end-untargeted-metabolomics.html","id":"aknowledgment","dir":"Articles","previous_headings":"","what":"Aknowledgment","title":"Complete end-to-end LC-MS/MS Metabolomic Data analysis","text":"Thanks Steffen Neumann continuous work develop maintain xcms software. Bioconductor RforMassSpectrometry community continuous support development software used tutorial.","code":""},{"path":[]},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/alignment-to-external-dataset.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Seamless Alignment: Merging New Data with and Existing Preprocessed Dataset","text":"certain experiments, aligning datasets recorded different times necessary. can involve comparing runs samples different laboratories matching MS2 data initial MS1 run. Variation retention time across laboratories LC systems often requires alignment step using adjustRtime() LamaParama parameter. described data description vignette, samples run twice: LC-MS mode LC-MS/MS mode. tutorial show align LC-MS/MS run preprocessed LC-MS dataset. following packages needed: Setting parallel processing improve efficiency process: First, let’s load pre-processed LC-MS object. xcms result object created End--end worflow vignette also available Metabonaut R package. result object (XcmsExperiment object) stored using Bioconductor’s alabaster framework load object using readMsObject() function providing path stored data. import function also takes care eventually retrieving missing MS data files MetaboLights repository. Next, load unprocessed LC-MS/MS data MetaboLights database: adjust sampleData() LC-MS/MS object make easier access: Table 1. Samples LC-MS/MS data set. keep MS runs (MS/MS) remove pooled samples, focusing samples E common runs. alignment, ensure retention time (RT) ranges match datasets: need adjust RT range LC-MS/MS object match LC-MS data: evaluate retention time shifts, ’ll plot base peak chromatogram (BPC): Compare run1 sample run2 sample  Similarly, compare BPC sample E:  Perform peak detection refining alignment, detailed end--end vignette. setting applied. Now, attempt align two samples previous dataset. first step extract landmark features (referred lamas). achieve , identify features present every phenotype group lcms1 dataset. , categorize (using factor()) data phenotype retain QC samples. variable utilized filter features using PercentMissingFilter parameter within filterFeatures() function. , setting threshold = 0 select features present QC samples. lamas input look like alignment. terms method works, alignment algorithm matches chromatographic peaks experimental data lamas, fitting model based match adjust retention times minimize differences two datasets. Now can define parameter object LamaParama prepare alignment. Parameters tolerance, toleranceRt, ppm relate matching chromatographic peaks lamas. parameters related type fitting generated data points. details parameter overall method can found searching ?adjustRtime. example using default parameters. matchLamaChromPeaks() function facilitates assessment well lamas correspond chromatographic peaks file. extract matched results using matchedRtimes() function. used later evaluate alignment. Now can adjust retention time LC-MS/MS dataset using adjustRtime() function. can initially visualizes difference adjusted raw retention tim samples.  can see shift fairly large 100 150s extremely important 170-205 seconds. analysis peaks area help us determine -correcting retention time. now, go like . extract base peak chromatogram (BPC) aligned object: evaluate performance alignment process, generate plots comparing alignment reference dataset (black) LC-MS data (red) (blue) adjustment.   Although overall matching imperfect due initial sample issues, certain regions show significant improvement. alignment signal’s start particularly well done. Specifically, regions right 150 seconds show substantial improvement. visualization distribution chromatographic peaks matched anchor peaks (lamas) Sample . red vertical lines represent positions matched peaks.  quantitatively assess quality alignment, compute distance chromatographic peaks LC-MS data anchor peaks (Lamas) alignment.  Furthermore, detailed examination matching model used fitting file possible. Numerical information can obtained using summarizeLamaMatch() function. , percentage chromatographic peaks utilized alignment can computed relative total number peaks file. Additionally, feasible directly plot() param object file interest, showcasing distribution chromatographic peaks along fitted model line.  tutorial demonstrated align LC-MS LC-MS/MS datasets correct retention time shifts, crucial handling data different runs platforms. preprocessed data, detected chromatographic peaks, used landmark features (lamas) QC samples adjust retention times via adjustRtime() function. Visual comparisons base peak chromatograms alignment, along distance calculations, showed clear improvements RT synchronization. Ultimately, aligning chromatographic data ensures subsequent analyses, feature extraction statistical comparisons, based consistent time points, improving data quality reliability. tutorial outlined end--end workflow can adapted various LC-MS-based metabolomics studies, helping researchers manage retention time variation effectively.","code":"library(MsIO) library(alabaster.se) library(MsBackendMetaboLights) library(xcms) library(MsExperiment) library(Spectra) library(vioplot) #' Set up parallel processing using 2 cores if (.Platform$OS.type == \"unix\") {     register(MulticoreParam(2)) } else {     register(SnowParam(2)) } lcms1 <- readMsObject(     XcmsExperiment(),     AlabasterParam(system.file(\"extdata\", \"preprocessed_lcms1\",                                package = \"Metabonaut\"))) #' Load form the MetaboLights Database mlp <- MetaboLightsParam(mtblsId = \"MTBLS8735\",                          assayName = paste0(\"a_MTBLS8735_LC-MSMS_positive_\",                                             \"hilic_metabolite_profiling.txt\"),                          filePattern = \".mzML\")  lcms2 <- readMsObject(MsExperiment(),                       mlp,                       keepOntology = FALSE,                       keepProtocol = FALSE,                       simplify = TRUE) #adjust sampleData colnames(sampleData(lcms2)) <- c(\"sample_name\", \"derived_spectra_data_file\",                                 \"metabolite_asssignment_file\",                                 \"source_name\",                                 \"organism\",                                 \"blood_sample_type\",                                 \"sample_type\", \"age\", \"unit\", \"phenotype\")  #let's look at the updated sample data sampleData(lcms2)[, c(\"derived_spectra_data_file\",                      \"phenotype\", \"sample_name\", \"age\")] |>     kable(format = \"pipe\") # Only keep MS run lcms2 <- lcms2[!grepl(\"MSMS\", sampleData(lcms2)$derived_spectra_data_file), ] range(rtime(lcms1)) [1]   9.674428 240.115311 range(rtime(lcms2)) [1]   0.275 480.176 #' Filter the data to the same RT range as the LC-MS run lcms2 <- filterRt(lcms2, range(rtime(lcms1))) idx_A <- which(sampleData(lcms1)$sample_name == \"A\") idx_E <- which(sampleData(lcms1)$sample_name == \"E\") bpc1 <-chromatogram(lcms1[c(idx_A,idx_E)], aggregationFun = \"max\",                     msLevel = 1) bpc2 <- chromatogram(lcms2, aggregationFun = \"max\", msLevel = 1) plot(bpc1[1, 1], col = \"#00000080\",      main = \"BPC sample A LC-MS vs A LC-MS/MS\", lwd = 1.5, peakType = \"none\") grid() points(rtime(bpc2[1, 1]), intensity(bpc2[1, 1]), col = \"#0000ff80\", type = \"l\") legend(\"topleft\", col = c(\"#00000080\", \"#0000ff80\"),        legend = c(\"LC-MS\", \"LC-MS/MS\"), lty = 1, lwd = 2, horiz = TRUE, bty = \"n\") plot(bpc1[1, 2], col = \"#00000080\",      main = \"BPC sample E LC-MS vs E LC-MS/MS\", lwd = 1.5, peakType = \"none\") grid() points(rtime(bpc2[1, 2]), intensity(bpc2[1, 2]), col = \"#0000ff80\", type = \"l\") legend(\"topleft\", col = c(\"#00000080\", \"#0000ff80\"),        legend = c(\"LC-MS\", \"LC-MS/MS\"), lty = 1, lwd = 2, horiz = TRUE, bty = \"n\") cwp <- CentWaveParam(peakwidth = c(1, 8), ppm = 15, integrate = 2) lcms2 <- findChromPeaks(lcms2, param = cwp, chunkSize = 2) mnpp <- MergeNeighboringPeaksParam(expandRt = 2.5, expandMz = 0.0015,                                     minProp = 0.75) lcms2 <- refineChromPeaks(lcms2, param = mnpp, chunkSize = 2) f <- sampleData(lcms1)$phenotype f[f != \"QC\"] <- NA lcms1 <- filterFeatures(lcms1, PercentMissingFilter(threshold = 0, f = f),                         filled = FALSE) 3694 features were removed lcms1_mz_rt <- featureDefinitions(lcms1)[, c(\"mzmed\",\"rtmed\")] head(lcms1_mz_rt) mzmed    rtmed FT0001 50.98979 203.6001 FT0002 51.05904 191.1675 FT0003 51.98657 203.1467 FT0004 53.02036 203.2343 FT0005 53.52080 203.1936 FT0007 54.01010 235.9032 nrow(lcms1_mz_rt) [1] 5374 lp <- LamaParama(lamas = lcms1_mz_rt, method = \"loess\", span = 0.5,                  outlierTolerance = 3, zeroWeight = 10, ppm =20,                  tolerance = 0, toleranceRt = 20, bs = \"tp\") lp <- matchLamasChromPeaks(lcms2, param = lp) ref_vs_obs <- matchedRtimes(lp) #' input into `adjustRtime()` lcms2 <- adjustRtime(lcms2, param = lp) plotAdjustedRtime(lcms2, peakGroupsPch = 1) grid() lcms2 <- applyAdjustedRtime(lcms2) bpc2_adj <- chromatogram(lcms2, aggregationFun = \"max\",                          msLevel = 1) #' BPC of sample A par(mfrow = c(2, 1),  mar = c(2.5, 2.5, 2.5, 0.5), mgp = c(1.5, 0.5, 0)) plot(bpc1[1, 1], col = \"#00000080\", main = \"Before Alignment\", lwd = 1.5,      peakType = \"none\", xlab = NA) grid() points(rtime(bpc2[1,1]), intensity(bpc2[1,1]),        type = \"l\",        col = \"#0000ff80\") legend(\"topleft\", col = c(\"#00000080\", \"#0000ff80\"),        legend = c(\"LC-MS\", \"LC-MS/MS\"), lty = 1, lwd = 2, horiz = TRUE, bty = \"n\")  plot(bpc1[1, 1], col = \"#00000080\", main = \"After Alignment\", lwd = 1.5,      peakType = \"none\", xlab = \"rtime (s)\") grid() points(rtime(bpc2_adj[1,1]), intensity(bpc2_adj[1,1]),        type = \"l\",        col = \"#0000ff80\") #' BPC of sample B par(mfrow = c(2, 1),  mar = c(2.5, 2.5, 2.5, 0.5), mgp = c(1.5, 0.5, 0)) plot(bpc1[1, 2], col = \"#00000080\", main = \"Before Alignment\", lwd = 1.5,      peakType = \"none\", xlab = NA) grid() points(rtime(bpc2[1, 2]), intensity(bpc2[1, 2]), type = \"l\",        col = \"#0000ff80\") legend(\"topleft\", col = c(\"#00000080\", \"#0000ff80\"),        legend = c(\"LC-MS\", \"LC-MS/MS\"), lty = 1, lwd = 2, horiz = TRUE, bty = \"n\")  plot(bpc1[1, 2], col = \"#00000080\", main = \"After Alignment\", lwd = 1.5,      peakType = \"none\", xlab = \"rtime (s)\") grid() points(rtime(bpc2_adj[1, 2]), intensity(bpc2_adj[1, 2]), type = \"l\",        col = \"#0000ff80\") #' BPC of the first sample with matches to lamas overlay par(mfrow = c(1, 1)) plot(bpc1[1, 1], col = \"#00000080\", main = \"Distribution CP matched to Lamas\",      lwd = 1.5,      peakType = \"none\") points(rtime(bpc2_adj[1, 1]), intensity(bpc2_adj[1, 1]), type = \"l\",        col = \"#0000ff80\") grid() abline(v = ref_vs_obs[[1]]$obs, col = \"#c4114510\") # Extract data for sample 3 directly ref_obs_sample_1 <- ref_vs_obs[[\"1\"]]  # Calculate distances before and after alignment dist_before <- abs(ref_obs_sample_1$obs - ref_obs_sample_1$ref) dist_after <- abs(chromPeaks(lcms2)[ref_obs_sample_1$chromPeaksId,                                              \"rt\"] - ref_obs_sample_1$ref)  # Create a data frame for plotting distances <- data.frame(   Distance = c(dist_before, dist_after),   Alignment = rep(c(\"Before\", \"After\"), each = length(dist_before)) )  # Set factor levels for Alignment to ensure correct order distances$Alignment <- factor(distances$Alignment, levels = c(\"Before\", \"After\"))  # Plot distances between anchor peaks between the two runs before and after alignment. vioplot(Distance ~ Alignment, data = distances, xlab = \"\",         rectCol = \"#c4114580\",         lineCol = \"white\",         col=\"#17138fe8\",         border = \"white\",         ylab = \"Distance (s)\",         main = \"Distance to Anchor Peaks: Before vs. After Alignment\") #' Access summary of matches and model information summary <- summarizeLamaMatch(lp) summary Total_peaks Matched_peaks Total_lamas Model_summary 1        6832          1825        5374  1666, c(.... 2        6860          1785        5374  1617, c(.... 3        7588          2082        5374  1869, c(.... #' Coverage for each file summary$Matched_peaks / summary$Total_peaks * 100 [1] 26.71253 26.02041 27.43806 #' Access the information on the model of for the first file summary$Model_summary[[1]] Call: loess(formula = ref ~ obs, data = rt_map, weights = weights,     span = span)  Number of Observations: 1666 Equivalent Number of Parameters: 7.38 Residual Standard Error: 2.315 Trace of smoother matrix: 8.13  (exact)  Control settings:   span     :  0.5   degree   :  2   family   :  gaussian   surface  :  interpolate     cell = 0.2   normalize:  TRUE  parametric:  FALSE drop.square:  FALSE #' Plot obs vs. lcms1 with fitting line plot(lp, index = 1L, main = \"ChromPeaks versus Lamas for sample A\",      colPoint = \"red\") abline(0, 1, lty = 3, col = \"grey\") grid()"},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/alignment-to-external-dataset.html","id":"load-preprocessed-lc-ms-object","dir":"Articles","previous_headings":"","what":"Load preprocessed LC-MS object","title":"Seamless Alignment: Merging New Data with and Existing Preprocessed Dataset","text":"First, let’s load pre-processed LC-MS object. xcms result object created End--end worflow vignette also available Metabonaut R package. result object (XcmsExperiment object) stored using Bioconductor’s alabaster framework load object using readMsObject() function providing path stored data. import function also takes care eventually retrieving missing MS data files MetaboLights repository.","code":"lcms1 <- readMsObject(     XcmsExperiment(),     AlabasterParam(system.file(\"extdata\", \"preprocessed_lcms1\",                                package = \"Metabonaut\")))"},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/alignment-to-external-dataset.html","id":"load-unprocessed-lc-msms-data","dir":"Articles","previous_headings":"","what":"Load unprocessed LC-MS/MS data","title":"Seamless Alignment: Merging New Data with and Existing Preprocessed Dataset","text":"Next, load unprocessed LC-MS/MS data MetaboLights database: adjust sampleData() LC-MS/MS object make easier access: Table 1. Samples LC-MS/MS data set. keep MS runs (MS/MS) remove pooled samples, focusing samples E common runs. alignment, ensure retention time (RT) ranges match datasets: need adjust RT range LC-MS/MS object match LC-MS data:","code":"#' Load form the MetaboLights Database mlp <- MetaboLightsParam(mtblsId = \"MTBLS8735\",                          assayName = paste0(\"a_MTBLS8735_LC-MSMS_positive_\",                                             \"hilic_metabolite_profiling.txt\"),                          filePattern = \".mzML\")  lcms2 <- readMsObject(MsExperiment(),                       mlp,                       keepOntology = FALSE,                       keepProtocol = FALSE,                       simplify = TRUE) #adjust sampleData colnames(sampleData(lcms2)) <- c(\"sample_name\", \"derived_spectra_data_file\",                                 \"metabolite_asssignment_file\",                                 \"source_name\",                                 \"organism\",                                 \"blood_sample_type\",                                 \"sample_type\", \"age\", \"unit\", \"phenotype\")  #let's look at the updated sample data sampleData(lcms2)[, c(\"derived_spectra_data_file\",                      \"phenotype\", \"sample_name\", \"age\")] |>     kable(format = \"pipe\") # Only keep MS run lcms2 <- lcms2[!grepl(\"MSMS\", sampleData(lcms2)$derived_spectra_data_file), ] range(rtime(lcms1)) [1]   9.674428 240.115311 range(rtime(lcms2)) [1]   0.275 480.176 #' Filter the data to the same RT range as the LC-MS run lcms2 <- filterRt(lcms2, range(rtime(lcms1)))"},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/alignment-to-external-dataset.html","id":"comparing-chromatograms","dir":"Articles","previous_headings":"","what":"Comparing chromatograms","title":"Seamless Alignment: Merging New Data with and Existing Preprocessed Dataset","text":"evaluate retention time shifts, ’ll plot base peak chromatogram (BPC): Compare run1 sample run2 sample  Similarly, compare BPC sample E:","code":"idx_A <- which(sampleData(lcms1)$sample_name == \"A\") idx_E <- which(sampleData(lcms1)$sample_name == \"E\") bpc1 <-chromatogram(lcms1[c(idx_A,idx_E)], aggregationFun = \"max\",                     msLevel = 1) bpc2 <- chromatogram(lcms2, aggregationFun = \"max\", msLevel = 1) plot(bpc1[1, 1], col = \"#00000080\",      main = \"BPC sample A LC-MS vs A LC-MS/MS\", lwd = 1.5, peakType = \"none\") grid() points(rtime(bpc2[1, 1]), intensity(bpc2[1, 1]), col = \"#0000ff80\", type = \"l\") legend(\"topleft\", col = c(\"#00000080\", \"#0000ff80\"),        legend = c(\"LC-MS\", \"LC-MS/MS\"), lty = 1, lwd = 2, horiz = TRUE, bty = \"n\") plot(bpc1[1, 2], col = \"#00000080\",      main = \"BPC sample E LC-MS vs E LC-MS/MS\", lwd = 1.5, peakType = \"none\") grid() points(rtime(bpc2[1, 2]), intensity(bpc2[1, 2]), col = \"#0000ff80\", type = \"l\") legend(\"topleft\", col = c(\"#00000080\", \"#0000ff80\"),        legend = c(\"LC-MS\", \"LC-MS/MS\"), lty = 1, lwd = 2, horiz = TRUE, bty = \"n\")"},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/alignment-to-external-dataset.html","id":"peak-detection","dir":"Articles","previous_headings":"","what":"Peak detection","title":"Seamless Alignment: Merging New Data with and Existing Preprocessed Dataset","text":"Perform peak detection refining alignment, detailed end--end vignette. setting applied.","code":"cwp <- CentWaveParam(peakwidth = c(1, 8), ppm = 15, integrate = 2) lcms2 <- findChromPeaks(lcms2, param = cwp, chunkSize = 2) mnpp <- MergeNeighboringPeaksParam(expandRt = 2.5, expandMz = 0.0015,                                     minProp = 0.75) lcms2 <- refineChromPeaks(lcms2, param = mnpp, chunkSize = 2)"},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/alignment-to-external-dataset.html","id":"alignment","dir":"Articles","previous_headings":"","what":"Alignment","title":"Seamless Alignment: Merging New Data with and Existing Preprocessed Dataset","text":"Now, attempt align two samples previous dataset. first step extract landmark features (referred lamas). achieve , identify features present every phenotype group lcms1 dataset. , categorize (using factor()) data phenotype retain QC samples. variable utilized filter features using PercentMissingFilter parameter within filterFeatures() function. , setting threshold = 0 select features present QC samples. lamas input look like alignment. terms method works, alignment algorithm matches chromatographic peaks experimental data lamas, fitting model based match adjust retention times minimize differences two datasets. Now can define parameter object LamaParama prepare alignment. Parameters tolerance, toleranceRt, ppm relate matching chromatographic peaks lamas. parameters related type fitting generated data points. details parameter overall method can found searching ?adjustRtime. example using default parameters. matchLamaChromPeaks() function facilitates assessment well lamas correspond chromatographic peaks file. extract matched results using matchedRtimes() function. used later evaluate alignment. Now can adjust retention time LC-MS/MS dataset using adjustRtime() function.","code":"f <- sampleData(lcms1)$phenotype f[f != \"QC\"] <- NA lcms1 <- filterFeatures(lcms1, PercentMissingFilter(threshold = 0, f = f),                         filled = FALSE) 3694 features were removed lcms1_mz_rt <- featureDefinitions(lcms1)[, c(\"mzmed\",\"rtmed\")] head(lcms1_mz_rt) mzmed    rtmed FT0001 50.98979 203.6001 FT0002 51.05904 191.1675 FT0003 51.98657 203.1467 FT0004 53.02036 203.2343 FT0005 53.52080 203.1936 FT0007 54.01010 235.9032 nrow(lcms1_mz_rt) [1] 5374 lp <- LamaParama(lamas = lcms1_mz_rt, method = \"loess\", span = 0.5,                  outlierTolerance = 3, zeroWeight = 10, ppm =20,                  tolerance = 0, toleranceRt = 20, bs = \"tp\") lp <- matchLamasChromPeaks(lcms2, param = lp) ref_vs_obs <- matchedRtimes(lp) #' input into `adjustRtime()` lcms2 <- adjustRtime(lcms2, param = lp)"},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/alignment-to-external-dataset.html","id":"evaluation","dir":"Articles","previous_headings":"","what":"Evaluation","title":"Seamless Alignment: Merging New Data with and Existing Preprocessed Dataset","text":"can initially visualizes difference adjusted raw retention tim samples.  can see shift fairly large 100 150s extremely important 170-205 seconds. analysis peaks area help us determine -correcting retention time. now, go like . extract base peak chromatogram (BPC) aligned object: evaluate performance alignment process, generate plots comparing alignment reference dataset (black) LC-MS data (red) (blue) adjustment.   Although overall matching imperfect due initial sample issues, certain regions show significant improvement. alignment signal’s start particularly well done. Specifically, regions right 150 seconds show substantial improvement. visualization distribution chromatographic peaks matched anchor peaks (lamas) Sample . red vertical lines represent positions matched peaks.  quantitatively assess quality alignment, compute distance chromatographic peaks LC-MS data anchor peaks (Lamas) alignment.  Furthermore, detailed examination matching model used fitting file possible. Numerical information can obtained using summarizeLamaMatch() function. , percentage chromatographic peaks utilized alignment can computed relative total number peaks file. Additionally, feasible directly plot() param object file interest, showcasing distribution chromatographic peaks along fitted model line.","code":"plotAdjustedRtime(lcms2, peakGroupsPch = 1) grid() lcms2 <- applyAdjustedRtime(lcms2) bpc2_adj <- chromatogram(lcms2, aggregationFun = \"max\",                          msLevel = 1) #' BPC of sample A par(mfrow = c(2, 1),  mar = c(2.5, 2.5, 2.5, 0.5), mgp = c(1.5, 0.5, 0)) plot(bpc1[1, 1], col = \"#00000080\", main = \"Before Alignment\", lwd = 1.5,      peakType = \"none\", xlab = NA) grid() points(rtime(bpc2[1,1]), intensity(bpc2[1,1]),        type = \"l\",        col = \"#0000ff80\") legend(\"topleft\", col = c(\"#00000080\", \"#0000ff80\"),        legend = c(\"LC-MS\", \"LC-MS/MS\"), lty = 1, lwd = 2, horiz = TRUE, bty = \"n\")  plot(bpc1[1, 1], col = \"#00000080\", main = \"After Alignment\", lwd = 1.5,      peakType = \"none\", xlab = \"rtime (s)\") grid() points(rtime(bpc2_adj[1,1]), intensity(bpc2_adj[1,1]),        type = \"l\",        col = \"#0000ff80\") #' BPC of sample B par(mfrow = c(2, 1),  mar = c(2.5, 2.5, 2.5, 0.5), mgp = c(1.5, 0.5, 0)) plot(bpc1[1, 2], col = \"#00000080\", main = \"Before Alignment\", lwd = 1.5,      peakType = \"none\", xlab = NA) grid() points(rtime(bpc2[1, 2]), intensity(bpc2[1, 2]), type = \"l\",        col = \"#0000ff80\") legend(\"topleft\", col = c(\"#00000080\", \"#0000ff80\"),        legend = c(\"LC-MS\", \"LC-MS/MS\"), lty = 1, lwd = 2, horiz = TRUE, bty = \"n\")  plot(bpc1[1, 2], col = \"#00000080\", main = \"After Alignment\", lwd = 1.5,      peakType = \"none\", xlab = \"rtime (s)\") grid() points(rtime(bpc2_adj[1, 2]), intensity(bpc2_adj[1, 2]), type = \"l\",        col = \"#0000ff80\") #' BPC of the first sample with matches to lamas overlay par(mfrow = c(1, 1)) plot(bpc1[1, 1], col = \"#00000080\", main = \"Distribution CP matched to Lamas\",      lwd = 1.5,      peakType = \"none\") points(rtime(bpc2_adj[1, 1]), intensity(bpc2_adj[1, 1]), type = \"l\",        col = \"#0000ff80\") grid() abline(v = ref_vs_obs[[1]]$obs, col = \"#c4114510\") # Extract data for sample 3 directly ref_obs_sample_1 <- ref_vs_obs[[\"1\"]]  # Calculate distances before and after alignment dist_before <- abs(ref_obs_sample_1$obs - ref_obs_sample_1$ref) dist_after <- abs(chromPeaks(lcms2)[ref_obs_sample_1$chromPeaksId,                                              \"rt\"] - ref_obs_sample_1$ref)  # Create a data frame for plotting distances <- data.frame(   Distance = c(dist_before, dist_after),   Alignment = rep(c(\"Before\", \"After\"), each = length(dist_before)) )  # Set factor levels for Alignment to ensure correct order distances$Alignment <- factor(distances$Alignment, levels = c(\"Before\", \"After\"))  # Plot distances between anchor peaks between the two runs before and after alignment. vioplot(Distance ~ Alignment, data = distances, xlab = \"\",         rectCol = \"#c4114580\",         lineCol = \"white\",         col=\"#17138fe8\",         border = \"white\",         ylab = \"Distance (s)\",         main = \"Distance to Anchor Peaks: Before vs. After Alignment\") #' Access summary of matches and model information summary <- summarizeLamaMatch(lp) summary Total_peaks Matched_peaks Total_lamas Model_summary 1        6832          1825        5374  1666, c(.... 2        6860          1785        5374  1617, c(.... 3        7588          2082        5374  1869, c(.... #' Coverage for each file summary$Matched_peaks / summary$Total_peaks * 100 [1] 26.71253 26.02041 27.43806 #' Access the information on the model of for the first file summary$Model_summary[[1]] Call: loess(formula = ref ~ obs, data = rt_map, weights = weights,     span = span)  Number of Observations: 1666 Equivalent Number of Parameters: 7.38 Residual Standard Error: 2.315 Trace of smoother matrix: 8.13  (exact)  Control settings:   span     :  0.5   degree   :  2   family   :  gaussian   surface  :  interpolate     cell = 0.2   normalize:  TRUE  parametric:  FALSE drop.square:  FALSE #' Plot obs vs. lcms1 with fitting line plot(lp, index = 1L, main = \"ChromPeaks versus Lamas for sample A\",      colPoint = \"red\") abline(0, 1, lty = 3, col = \"grey\") grid()"},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/alignment-to-external-dataset.html","id":"visualizing-alignment-quality","dir":"Articles","previous_headings":"Introduction","what":"Visualizing Alignment Quality","title":"Seamless Alignment: Merging New Data with and Existing Preprocessed Dataset","text":"evaluate performance alignment process, generate plots comparing alignment reference dataset (black) LC-MS data (red) (blue) adjustment.   Although overall matching imperfect due initial sample issues, certain regions show significant improvement. alignment signal’s start particularly well done. Specifically, regions right 150 seconds show substantial improvement. visualization distribution chromatographic peaks matched anchor peaks (lamas) Sample . red vertical lines represent positions matched peaks.","code":"#' BPC of sample A par(mfrow = c(2, 1),  mar = c(2.5, 2.5, 2.5, 0.5), mgp = c(1.5, 0.5, 0)) plot(bpc1[1, 1], col = \"#00000080\", main = \"Before Alignment\", lwd = 1.5,      peakType = \"none\", xlab = NA) grid() points(rtime(bpc2[1,1]), intensity(bpc2[1,1]),        type = \"l\",        col = \"#0000ff80\") legend(\"topleft\", col = c(\"#00000080\", \"#0000ff80\"),        legend = c(\"LC-MS\", \"LC-MS/MS\"), lty = 1, lwd = 2, horiz = TRUE, bty = \"n\")  plot(bpc1[1, 1], col = \"#00000080\", main = \"After Alignment\", lwd = 1.5,      peakType = \"none\", xlab = \"rtime (s)\") grid() points(rtime(bpc2_adj[1,1]), intensity(bpc2_adj[1,1]),        type = \"l\",        col = \"#0000ff80\") #' BPC of sample B par(mfrow = c(2, 1),  mar = c(2.5, 2.5, 2.5, 0.5), mgp = c(1.5, 0.5, 0)) plot(bpc1[1, 2], col = \"#00000080\", main = \"Before Alignment\", lwd = 1.5,      peakType = \"none\", xlab = NA) grid() points(rtime(bpc2[1, 2]), intensity(bpc2[1, 2]), type = \"l\",        col = \"#0000ff80\") legend(\"topleft\", col = c(\"#00000080\", \"#0000ff80\"),        legend = c(\"LC-MS\", \"LC-MS/MS\"), lty = 1, lwd = 2, horiz = TRUE, bty = \"n\")  plot(bpc1[1, 2], col = \"#00000080\", main = \"After Alignment\", lwd = 1.5,      peakType = \"none\", xlab = \"rtime (s)\") grid() points(rtime(bpc2_adj[1, 2]), intensity(bpc2_adj[1, 2]), type = \"l\",        col = \"#0000ff80\") #' BPC of the first sample with matches to lamas overlay par(mfrow = c(1, 1)) plot(bpc1[1, 1], col = \"#00000080\", main = \"Distribution CP matched to Lamas\",      lwd = 1.5,      peakType = \"none\") points(rtime(bpc2_adj[1, 1]), intensity(bpc2_adj[1, 1]), type = \"l\",        col = \"#0000ff80\") grid() abline(v = ref_vs_obs[[1]]$obs, col = \"#c4114510\")"},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/alignment-to-external-dataset.html","id":"quantitative-evaluation-of-alignment","dir":"Articles","previous_headings":"Introduction","what":"Quantitative Evaluation of Alignment","title":"Seamless Alignment: Merging New Data with and Existing Preprocessed Dataset","text":"quantitatively assess quality alignment, compute distance chromatographic peaks LC-MS data anchor peaks (Lamas) alignment.  Furthermore, detailed examination matching model used fitting file possible. Numerical information can obtained using summarizeLamaMatch() function. , percentage chromatographic peaks utilized alignment can computed relative total number peaks file. Additionally, feasible directly plot() param object file interest, showcasing distribution chromatographic peaks along fitted model line.","code":"# Extract data for sample 3 directly ref_obs_sample_1 <- ref_vs_obs[[\"1\"]]  # Calculate distances before and after alignment dist_before <- abs(ref_obs_sample_1$obs - ref_obs_sample_1$ref) dist_after <- abs(chromPeaks(lcms2)[ref_obs_sample_1$chromPeaksId,                                              \"rt\"] - ref_obs_sample_1$ref)  # Create a data frame for plotting distances <- data.frame(   Distance = c(dist_before, dist_after),   Alignment = rep(c(\"Before\", \"After\"), each = length(dist_before)) )  # Set factor levels for Alignment to ensure correct order distances$Alignment <- factor(distances$Alignment, levels = c(\"Before\", \"After\"))  # Plot distances between anchor peaks between the two runs before and after alignment. vioplot(Distance ~ Alignment, data = distances, xlab = \"\",         rectCol = \"#c4114580\",         lineCol = \"white\",         col=\"#17138fe8\",         border = \"white\",         ylab = \"Distance (s)\",         main = \"Distance to Anchor Peaks: Before vs. After Alignment\") #' Access summary of matches and model information summary <- summarizeLamaMatch(lp) summary Total_peaks Matched_peaks Total_lamas Model_summary 1        6832          1825        5374  1666, c(.... 2        6860          1785        5374  1617, c(.... 3        7588          2082        5374  1869, c(.... #' Coverage for each file summary$Matched_peaks / summary$Total_peaks * 100 [1] 26.71253 26.02041 27.43806 #' Access the information on the model of for the first file summary$Model_summary[[1]] Call: loess(formula = ref ~ obs, data = rt_map, weights = weights,     span = span)  Number of Observations: 1666 Equivalent Number of Parameters: 7.38 Residual Standard Error: 2.315 Trace of smoother matrix: 8.13  (exact)  Control settings:   span     :  0.5   degree   :  2   family   :  gaussian   surface  :  interpolate     cell = 0.2   normalize:  TRUE  parametric:  FALSE drop.square:  FALSE #' Plot obs vs. lcms1 with fitting line plot(lp, index = 1L, main = \"ChromPeaks versus Lamas for sample A\",      colPoint = \"red\") abline(0, 1, lty = 3, col = \"grey\") grid()"},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/alignment-to-external-dataset.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Seamless Alignment: Merging New Data with and Existing Preprocessed Dataset","text":"tutorial demonstrated align LC-MS LC-MS/MS datasets correct retention time shifts, crucial handling data different runs platforms. preprocessed data, detected chromatographic peaks, used landmark features (lamas) QC samples adjust retention times via adjustRtime() function. Visual comparisons base peak chromatograms alignment, along distance calculations, showed clear improvements RT synchronization. Ultimately, aligning chromatographic data ensures subsequent analyses, feature extraction statistical comparisons, based consistent time points, improving data quality reliability. tutorial outlined end--end workflow can adapted various LC-MS-based metabolomics studies, helping researchers manage retention time variation effectively.","code":""},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/dataset-investigation.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Dataset investigation: What to do when you get your data","text":", (amazing lab mate) finally finished data acquisition, now dataset hand. ’s next? Unfortunately, work isn’t yet. diving analysis, ’s crucial understand dataset . first step data analysis workflow, ensuring data good quality well-prepared preprocessing downstream analysis plan perform. vignette, present dataset used throughout different vignettes website. ’s far perfect dataset, actually mirrors reality datasets ’ll encounter research. issues indeed specific described dataset. However, purpose vignette encourage think critically data guide steps can help avoid spending hours analysis, realize later samples features removed flagged earlier .","code":""},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/dataset-investigation.html","id":"dataset-description","dir":"Articles","previous_headings":"","what":"Dataset Description","title":"Dataset investigation: What to do when you get your data","text":"workflow, two datasets used: LC-MS-based (MS1 level ) untargeted metabolomics dataset quantify small polar metabolites human plasma samples. additional LC-MS/MS dataset selected samples former study identification annotation significant features. samples randomly selected larger study aimed identifying metabolites varying abundances individuals suffering cardiovascular disease (CVD) healthy controls (CTR). subset analyzed includes data three CVD patients, three CTR individuals, four quality control (QC) samples. QC samples, representing pooled serum sample large cohort, measured repeatedly throughout experiment monitor signal stability. data metadata workflow available MetaboLights database ID: MTBLS8735. detailed materials methods used sample analysis also available MetaboLights entry. particularly important understanding analysis parameters used. noted samples analyzed using ultra-high-performance liquid chromatography (UHPLC) coupled Q-TOF mass spectrometer (TripleTOF 5600+), chromatographic separation achieved using hydrophilic interaction liquid chromatography (HILIC). Provide -depth visualizations explore understand dataset quality. Compare pool lc-ms pool lc-ms/ms show better separation second run.","code":""},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/dataset-investigation.html","id":"package","dir":"Articles","previous_headings":"","what":"Package","title":"Dataset investigation: What to do when you get your data","text":"","code":"## Data Import and handling library(MsExperiment) library(MsIO) library(MsBackendMetaboLights) library(SummarizedExperiment)  ## Preprocessing of LC-MS data library(xcms) library(Spectra) library(MetaboCoreUtils) library(Biobase)  ## Visualisation library(pander) library(RColorBrewer) library(pheatmap)"},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/dataset-investigation.html","id":"ms1-level-data","dir":"Articles","previous_headings":"","what":"MS1 level data","title":"Dataset investigation: What to do when you get your data","text":"first load raw data MetaboLights: set parallel processing facilitate futher computations. update metadata make column names easier access: Table 2. Simplified sample data. Quick reminder access spectra data : One first check done evaluatating number spectra per sample. summarize number spectra respective MS level (extracted msLevel() function). fromFile() function returns spectrum index sample (data file) can thus used split information (MS level case) sample summarize using base R table() function combine result matrix. present data set thus contains MS1 data, ideal quantification signal. second (LC-MS/MS) data set also fragment (MS2) spectra samples used later workflow. also see large difference number spectra samples, good sign data good quality. one sample significantly lower number spectra, sign potential issue sample. Data obtained LC-MS experiments typically analyzed along retention time axis, MS data organized spectrum, orthogonal retention time axis. another example, determine retention time range entire data set.","code":"param <- MetaboLightsParam(mtblsId = \"MTBLS8735\",                            assayName = paste0(\"a_MTBLS8735_LC-MS_positive_\",                                               \"hilic_metabolite_profiling.txt\"),                            filePattern = \".mzML\")  lcms1 <- readMsObject(MsExperiment(),                       param,                       keepOntology = FALSE,                       keepProtocol = FALSE,                       simplify = TRUE) #' Set up parallel processing using 2 cores if (.Platform$OS.type == \"unix\") {     register(MulticoreParam(2)) } else {     register(SnowParam(2)) } # Let's rename the column for easier access colnames(sampleData(lcms1)) <- c(\"sample_name\", \"derived_spectra_data_file\",                                 \"metabolite_asssignment_file\",                                 \"source_name\",                                 \"organism\",                                 \"blood_sample_type\",                                 \"sample_type\", \"age\", \"unit\", \"phenotype\")  # Add \"QC\" to the phenotype of the QC samples sampleData(lcms1)$phenotype[sampleData(lcms1)$sample_name == \"POOL\"] <- \"QC\" sampleData(lcms1)$sample_name[sampleData(lcms1)$sample_name == \"POOL\" ] <- c(\"POOL1\", \"POOL2\", \"POOL3\", \"POOL4\")  #  Add injection index column sampleData(lcms1)$injection_index <- seq_len(nrow(sampleData(lcms1)))  #let's look at the updated sample data sampleData(lcms1)[, c(\"derived_spectra_data_file\",                      \"phenotype\", \"sample_name\", \"age\",                      \"injection_index\")] |>     kable(format = \"pipe\") #' Define colors for the different phenotypes col_phenotype <- brewer.pal(9, name = \"Set1\")[c(9, 5, 4)] names(col_phenotype) <- c(\"QC\", # grey                           \"CVD\", # orange                           \"CTR\") # purple col_sample <- col_phenotype[sampleData(lcms1)$phenotype] #' Access Spectra Object spectra(lcms1) MSn data (Spectra) with 17210 spectra in a MsBackendMetaboLights backend:         msLevel     rtime scanIndex       <integer> <numeric> <integer> 1             1     0.274         1 2             1     0.553         2 3             1     0.832         3 4             1     1.111         4 5             1     1.390         5 ...         ...       ...       ... 17206         1   479.052      1717 17207         1   479.331      1718 17208         1   479.610      1719 17209         1   479.889      1720 17210         1   480.168      1721  ... 37 more variables/columns.  file(s): MS_QC_POOL_1_POS.mzML MS_A_POS.mzML MS_B_POS.mzML  ... 7 more files #' Count the number of spectra with a specific MS level per file. spectra(lcms1) |>     msLevel() |>     split(fromFile(lcms1)) |>     lapply(table) |>     do.call(what = cbind) 1    2    3    4    5    6    7    8    9   10 1 1721 1721 1721 1721 1721 1721 1721 1721 1721 1721 #' Retention time range for entire dataset spectra(lcms1) |>     rtime() |>     range() [1]   0.273 480.169"},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/dataset-investigation.html","id":"spectra-exploration","dir":"Articles","previous_headings":"","what":"Spectra exploration","title":"Dataset investigation: What to do when you get your data","text":"Quick reminder access spectra data : One first check done evaluatating number spectra per sample. summarize number spectra respective MS level (extracted msLevel() function). fromFile() function returns spectrum index sample (data file) can thus used split information (MS level case) sample summarize using base R table() function combine result matrix. present data set thus contains MS1 data, ideal quantification signal. second (LC-MS/MS) data set also fragment (MS2) spectra samples used later workflow. also see large difference number spectra samples, good sign data good quality. one sample significantly lower number spectra, sign potential issue sample. Data obtained LC-MS experiments typically analyzed along retention time axis, MS data organized spectrum, orthogonal retention time axis. another example, determine retention time range entire data set.","code":"#' Access Spectra Object spectra(lcms1) MSn data (Spectra) with 17210 spectra in a MsBackendMetaboLights backend:         msLevel     rtime scanIndex       <integer> <numeric> <integer> 1             1     0.274         1 2             1     0.553         2 3             1     0.832         3 4             1     1.111         4 5             1     1.390         5 ...         ...       ...       ... 17206         1   479.052      1717 17207         1   479.331      1718 17208         1   479.610      1719 17209         1   479.889      1720 17210         1   480.168      1721  ... 37 more variables/columns.  file(s): MS_QC_POOL_1_POS.mzML MS_A_POS.mzML MS_B_POS.mzML  ... 7 more files #' Count the number of spectra with a specific MS level per file. spectra(lcms1) |>     msLevel() |>     split(fromFile(lcms1)) |>     lapply(table) |>     do.call(what = cbind) 1    2    3    4    5    6    7    8    9   10 1 1721 1721 1721 1721 1721 1721 1721 1721 1721 1721 #' Retention time range for entire dataset spectra(lcms1) |>     rtime() |>     range() [1]   0.273 480.169"},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/dataset-investigation.html","id":"data-visualization-and-general-quality-assessment","dir":"Articles","previous_headings":"","what":"Data visualization and general quality assessment","title":"Dataset investigation: What to do when you get your data","text":"Effective visualization paramount inspecting assessing quality MS data. general overview LC-MS data, can: Combine mass peaks (MS1) spectra sample single spectrum mass peak represents maximum signal mass peaks similar m/z. spectrum might called Base Peak Spectrum (BPS), providing information abundant ions sample. Aggregate mass peak intensities spectrum, resulting Base Peak Chromatogram (BPC). BPC shows highest measured intensity distinct retention time (hence spectrum) thus orthogonal BPS. Sum mass peak intensities spectrum create Total Ion Chromatogram (TIC). Compare BPS samples experiment evaluate similarity ion content. Compare BPC samples experiment identify samples similar dissimilar chromatographic signal. addition general data evaluation visualization, also crucial investigate specific signal e.g. internal standards compounds/ions known present samples. providing reliable reference, internal standards help achieve consistent accurate analytical results. BPS collapses data retention time dimension reveals prevalent ions present samples, creation BPS however straightforward. Mass peaks, even representing signals ion, never identical m/z values consecutive spectra due measurement error/resolution instrument. use combineSpectra function combine spectra one file (defined using parameter f = fromFile(data)) single spectrum. mass peaks difference m/z value smaller 3 parts-per-million (ppm) combined one mass peak, intensity representing maximum grouped mass peaks. reduce memory requirement, addition first bin spectrum combining mass peaks within spectrum, aggregating mass peaks bins 0.01 m/z width. case large datasets, also recommended set processingChunkSize() parameter MsExperiment object finite value (default Inf) causing data processed (loaded memory) chunks processingChunkSize() spectra. can reduce memory demand speed process. can now generate BPS sample plot() .  Figure 1. BPS samples. , observable overlap ion content files, particularly around 300 m/z 700 m/z. however also differences sets samples. particular, BPS 1, 4, 7 10 (counting row-wise left right) seem different others. fact, four BPS QC samples, remaining six study samples. observed differences might explained fact QC samples pools serum samples different cohort, study samples represent plasma samples, different sample collection. Next visual inspection , can also calculate express similarity BPS heatmap. use compareSpectra() function calculate pairwise similarities BPS use pheatmap() function pheatmap package cluster visualize result.  Figure 2. Heatmap MS signals similarities. get first glance different samples distribute terms similarity. heatmap confirms observations made BPS, showing distinct clusters QCs study samples, owing different matrices sample collections. also strongly recommended delve deeper data exploring detail. can accomplished carefully assessing data extracting spectra regions interest examination. next chunk, look extract information specific spectrum distinct samples.  Figure 3. Intensity m/z values 125th spectrum two CTR samples. significant dissimilarities peak distribution intensity confirm difference composition QCs study samples. next compare full MS1 spectrum CVD CTR sample.  Figure 4. Intensity m/z values 125th spectrum one CVD one CTR sample. , can observe spectra CVD CTR samples entirely similar, exhibit similar main peaks 200 600 m/z general higher intensity control samples. However peak distribution (least intensity) seems vary m/z 10 210 m/z 600. CTR spectrum exhibits significant peaks around m/z 150 - 200 much lower intensity CVD sample. delve details specific spectrum, wide range functions can employed: Table 3. Intensity m/z values 125th spectrum one CTR sample.  Figure 6. BPC filtering retention time. Initially, examined entire BPC subsequently filtered based desired retention times. results smaller file size also facilitates straightforward interpretation BPC. final plot illustrates BPC sample colored phenotype, providing insights signal measured along retention times sample. reveals points compounds eluted LC column. essence, BPC condenses three-dimensional LC-MS data (m/z retention time intensity) two dimensions (retention time intensity). can also compare similarities BPCs heatmap. retention times however identical different samples. Thus bin() chromatographic signal per sample along retention time axis bins two seconds resulting data number bins/data points. can calculate pairwise similarities data vectors using cor() function visualize result using pheatmap().  Figure 7. Heatmap BPC similarities. heatmap reinforces exploration spectra data showed, strong separation QC study samples. important bear mind later analyses. Additionally, study samples group two clusters, cluster containing samples C F cluster II samples. plot TIC samples, using different color cluster.  Figure 8. Example TIC unusual signal. TIC samples look similar, samples cluster show different signal retention time range 40 160 seconds. Whether, strong difference impact following analysis remains determined. artificially isotope labeled compounds spiked individual samples, also signal endogenous compounds serum (plasma) samples. Thus, calculate next mass m/z [M+H]+ ion endogenous cystine chemical formula extract also EIC ion. calculation exact mass m/z selected ion adduct use calculateMass() mass2mz() functions MetaboCoreUtils package.  Figure 10. EIC endogenous cystine vs spiked. two cystine EICs look highly similar (endogenous shown left, isotope labeled right plot ), shift m/z, arises artificial labeling. shift allows us discriminate endogenous non-endogenous compound. load lcms1 object saved preprocessing. plot backgrounds signal study group. can interesting cases technical evaluation. cases expect similar background noise CVD CTR.  seems background noise CVD samples… coming soon…","code":"#' Setting the chunksize chunksize <- 1000 processingChunkSize(spectra(lcms1)) <- chunksize #' Combining all spectra per file into a single spectrum bps <- spectra(lcms1) |>     bin(binSize = 0.01) |>     combineSpectra(f = fromFile(lcms1), intensityFun = max, ppm = 3)  #' Plot the base peak spectra par(mar = c(2, 1, 1, 1)) plotSpectra(bps, main= \"\") #' Calculate similarities between BPS sim_matrix <- compareSpectra(bps)  #' Add sample names as rownames and colnames rownames(sim_matrix) <- colnames(sim_matrix) <- sampleData(lcms1)$sample_name ann <- data.frame(phenotype = sampleData(lcms1)[, \"phenotype\"]) rownames(ann) <- rownames(sim_matrix)  #' Plot the heatmap pheatmap(sim_matrix, annotation_col = ann,          annotation_colors = list(phenotype = col_phenotype)) #' Accessing a single spectrum - comparing with QC par(mfrow = c(1,2), mar = c(2, 2, 2, 2)) spec1 <- spectra(lcms1[1])[125] spec2 <- spectra(lcms1[3])[125] plotSpectra(spec1, main = \"QC sample\") plotSpectra(spec2, main = \"CTR sample\") #' Accessing a single spectrum - comparing CVD and CTR par(mfrow = c(1,2), mar = c(2, 2, 2, 2)) spec1 <- spectra(lcms1[2])[125] spec2 <- spectra(lcms1[3])[125] plotSpectra(spec1, main = \"CVD sample\") plotSpectra(spec2, main = \"CTR sample\") #' Checking its intensity intensity(spec2) NumericList of length 1 [[1]] 18.3266733266736 45.1666666666667 ... 27.1048951048951 34.9020979020979 #' Checking its rtime rtime(spec2) [1] 34.872 #' Checking its m/z mz(spec2) NumericList of length 1 [[1]] 51.1677328505635 53.0461968245186 ... 999.139446289161 999.315208803072 #' Filtering for a specific m/z range and viewing in a tabular format filt_spec <- filterMzRange(spec2,c(50,200))  data.frame(intensity = unlist(intensity(filt_spec)),            mz = unlist(mz(filt_spec))) |>   head() |> kable(format = \"markdown\") #' Filter the data based on retention time lcms1 <- filterRt(lcms1, c(10, 240)) Filter spectra bpc <- chromatogram(lcms1, aggregationFun = \"max\")  #' Plot after filtering plot(bpc, col = paste0(col_sample, 80),      main = \"BPC after filtering retention time\", lwd = 1.5) grid() legend(\"topright\", col = col_phenotype,        legend = names(col_phenotype), lty = 1, lwd = 2, horiz = TRUE, bty = \"n\") #' Total ion chromatogram tic <- chromatogram(lcms1, aggregationFun = \"sum\") |>   bin(binSize = 2)  #' Calculate similarity (Pearson correlation) between BPCs ticmap <- do.call(cbind, lapply(tic, intensity)) |>   cor()  rownames(ticmap) <- colnames(ticmap) <- sampleData(lcms1)$sample_name ann <- data.frame(phenotype = sampleData(lcms1)[, \"phenotype\"]) rownames(ann) <- rownames(ticmap)  #' Plot heatmap pheatmap(ticmap, annotation_col = ann,          annotation_colors = list(phenotype = col_phenotype)) cluster_I_idx <- sampleData(lcms1)$sample_name %in% c(\"F\", \"C\") cluster_II_idx <- sampleData(lcms1)$sample_name %in% c(\"A\", \"B\", \"D\", \"E\")  temp_col <- c(\"grey\", \"red\") names(temp_col) <- c(\"Cluster II\", \"Cluster I\") col <- rep(temp_col[1], length(lcms1)) col[cluster_I_idx] <- temp_col[2] col[sampleData(lcms1)$phenotype == \"QC\"] <- NA  lcms1 |>     chromatogram(aggregationFun = \"sum\") |>     plot( col = col,      main = \"TIC after filtering retention time\", lwd = 1.5) grid() legend(\"topright\", col = temp_col,        legend = names(temp_col), lty = 1, lwd = 2,        horiz = TRUE, bty = \"n\") #' extract endogenous cystine mass and EIC and plot. cysmass <- calculateMass(\"C6H12N2O4S2\") cys_endo <- mass2mz(cysmass, adduct = \"[M+H]+\")[, 1] eic_cys_endo <- chromatogram(lcms1, mz = cys_endo + c(-0.005, 0.005),                              rt = c(199, 219), aggregationFun = \"max\") eic_cys_spiked <-  chromatogram(lcms1 , mz = c(249.040276, 249.050276),                                  rt = c(199,219))  #' Plot versus spiked par(mfrow = c(1, 2)) plot(eic_cys_endo, col = paste0(col_sample, 80))  grid()  plot(eic_cys_spiked, col = paste0(col_sample, 80)) grid() legend(\"topright\", col = col_phenotype, legend = names(col_phenotype),         lty = 1, bty = \"n\") #load preprocessed xcmsExperiment lcms1 <- readMsObject(XcmsExperiment(),     AlabasterParam(system.file(\"extdata\", \"preprocessed_lcms1\",                                package = \"Metabonaut\")))  res <- readObject(system.file(\"extdata\", \"preprocessed_res\",                                package = \"Metabonaut\")) # overall signal in the dataset  #' - for each file calculate the sum of intensities  background  <- spectra(lcms1) |>     split(fromFile(lcms1)) |>     lapply(tic) |>     lapply(sum) |>     unlist()  # Overall signal that is in the chromatographic peaks detection  detected <- apply(assay(res), 2, function(x) sum(x, na.rm = TRUE))  names(background) <- names(detected) <- res$phenotype idx_qc <- sampleData(lcms1)$phenotype == \"QC\" noise <- background[!idx_qc] - detected[!idx_qc]  f <- factor(names(noise), levels = unique(names(noise))) group <- split(log2(noise), f)  plot(NULL, xlim = c(1, length(group)), ylim = range(unlist(group)),       xaxt = \"n\", xlab = \"Devices\", ylab = \"Noise\",       main = \"log2 background signal comparison between study group\") for (i in seq_along(group)) {   points(rep(i, length(group[[i]])), group[[i]], pch = 19) } axis(1, at = seq_along(group), labels = names(group))"},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/dataset-investigation.html","id":"spectra-data-visualization-bps","dir":"Articles","previous_headings":"","what":"Spectra Data Visualization: BPS","title":"Dataset investigation: What to do when you get your data","text":"BPS collapses data retention time dimension reveals prevalent ions present samples, creation BPS however straightforward. Mass peaks, even representing signals ion, never identical m/z values consecutive spectra due measurement error/resolution instrument. use combineSpectra function combine spectra one file (defined using parameter f = fromFile(data)) single spectrum. mass peaks difference m/z value smaller 3 parts-per-million (ppm) combined one mass peak, intensity representing maximum grouped mass peaks. reduce memory requirement, addition first bin spectrum combining mass peaks within spectrum, aggregating mass peaks bins 0.01 m/z width. case large datasets, also recommended set processingChunkSize() parameter MsExperiment object finite value (default Inf) causing data processed (loaded memory) chunks processingChunkSize() spectra. can reduce memory demand speed process. can now generate BPS sample plot() .  Figure 1. BPS samples. , observable overlap ion content files, particularly around 300 m/z 700 m/z. however also differences sets samples. particular, BPS 1, 4, 7 10 (counting row-wise left right) seem different others. fact, four BPS QC samples, remaining six study samples. observed differences might explained fact QC samples pools serum samples different cohort, study samples represent plasma samples, different sample collection. Next visual inspection , can also calculate express similarity BPS heatmap. use compareSpectra() function calculate pairwise similarities BPS use pheatmap() function pheatmap package cluster visualize result.  Figure 2. Heatmap MS signals similarities. get first glance different samples distribute terms similarity. heatmap confirms observations made BPS, showing distinct clusters QCs study samples, owing different matrices sample collections. also strongly recommended delve deeper data exploring detail. can accomplished carefully assessing data extracting spectra regions interest examination. next chunk, look extract information specific spectrum distinct samples.  Figure 3. Intensity m/z values 125th spectrum two CTR samples. significant dissimilarities peak distribution intensity confirm difference composition QCs study samples. next compare full MS1 spectrum CVD CTR sample.  Figure 4. Intensity m/z values 125th spectrum one CVD one CTR sample. , can observe spectra CVD CTR samples entirely similar, exhibit similar main peaks 200 600 m/z general higher intensity control samples. However peak distribution (least intensity) seems vary m/z 10 210 m/z 600. CTR spectrum exhibits significant peaks around m/z 150 - 200 much lower intensity CVD sample. delve details specific spectrum, wide range functions can employed: Table 3. Intensity m/z values 125th spectrum one CTR sample.","code":"#' Setting the chunksize chunksize <- 1000 processingChunkSize(spectra(lcms1)) <- chunksize #' Combining all spectra per file into a single spectrum bps <- spectra(lcms1) |>     bin(binSize = 0.01) |>     combineSpectra(f = fromFile(lcms1), intensityFun = max, ppm = 3)  #' Plot the base peak spectra par(mar = c(2, 1, 1, 1)) plotSpectra(bps, main= \"\") #' Calculate similarities between BPS sim_matrix <- compareSpectra(bps)  #' Add sample names as rownames and colnames rownames(sim_matrix) <- colnames(sim_matrix) <- sampleData(lcms1)$sample_name ann <- data.frame(phenotype = sampleData(lcms1)[, \"phenotype\"]) rownames(ann) <- rownames(sim_matrix)  #' Plot the heatmap pheatmap(sim_matrix, annotation_col = ann,          annotation_colors = list(phenotype = col_phenotype)) #' Accessing a single spectrum - comparing with QC par(mfrow = c(1,2), mar = c(2, 2, 2, 2)) spec1 <- spectra(lcms1[1])[125] spec2 <- spectra(lcms1[3])[125] plotSpectra(spec1, main = \"QC sample\") plotSpectra(spec2, main = \"CTR sample\") #' Accessing a single spectrum - comparing CVD and CTR par(mfrow = c(1,2), mar = c(2, 2, 2, 2)) spec1 <- spectra(lcms1[2])[125] spec2 <- spectra(lcms1[3])[125] plotSpectra(spec1, main = \"CVD sample\") plotSpectra(spec2, main = \"CTR sample\") #' Checking its intensity intensity(spec2) NumericList of length 1 [[1]] 18.3266733266736 45.1666666666667 ... 27.1048951048951 34.9020979020979 #' Checking its rtime rtime(spec2) [1] 34.872 #' Checking its m/z mz(spec2) NumericList of length 1 [[1]] 51.1677328505635 53.0461968245186 ... 999.139446289161 999.315208803072 #' Filtering for a specific m/z range and viewing in a tabular format filt_spec <- filterMzRange(spec2,c(50,200))  data.frame(intensity = unlist(intensity(filt_spec)),            mz = unlist(mz(filt_spec))) |>   head() |> kable(format = \"markdown\")"},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/dataset-investigation.html","id":"chromatographic-info","dir":"Articles","previous_headings":"","what":"Chromatographic info","title":"Dataset investigation: What to do when you get your data","text":"Figure 6. BPC filtering retention time. Initially, examined entire BPC subsequently filtered based desired retention times. results smaller file size also facilitates straightforward interpretation BPC. final plot illustrates BPC sample colored phenotype, providing insights signal measured along retention times sample. reveals points compounds eluted LC column. essence, BPC condenses three-dimensional LC-MS data (m/z retention time intensity) two dimensions (retention time intensity). can also compare similarities BPCs heatmap. retention times however identical different samples. Thus bin() chromatographic signal per sample along retention time axis bins two seconds resulting data number bins/data points. can calculate pairwise similarities data vectors using cor() function visualize result using pheatmap().  Figure 7. Heatmap BPC similarities. heatmap reinforces exploration spectra data showed, strong separation QC study samples. important bear mind later analyses. Additionally, study samples group two clusters, cluster containing samples C F cluster II samples. plot TIC samples, using different color cluster.  Figure 8. Example TIC unusual signal. TIC samples look similar, samples cluster show different signal retention time range 40 160 seconds. Whether, strong difference impact following analysis remains determined.","code":"#' Filter the data based on retention time lcms1 <- filterRt(lcms1, c(10, 240)) Filter spectra bpc <- chromatogram(lcms1, aggregationFun = \"max\")  #' Plot after filtering plot(bpc, col = paste0(col_sample, 80),      main = \"BPC after filtering retention time\", lwd = 1.5) grid() legend(\"topright\", col = col_phenotype,        legend = names(col_phenotype), lty = 1, lwd = 2, horiz = TRUE, bty = \"n\") #' Total ion chromatogram tic <- chromatogram(lcms1, aggregationFun = \"sum\") |>   bin(binSize = 2)  #' Calculate similarity (Pearson correlation) between BPCs ticmap <- do.call(cbind, lapply(tic, intensity)) |>   cor()  rownames(ticmap) <- colnames(ticmap) <- sampleData(lcms1)$sample_name ann <- data.frame(phenotype = sampleData(lcms1)[, \"phenotype\"]) rownames(ann) <- rownames(ticmap)  #' Plot heatmap pheatmap(ticmap, annotation_col = ann,          annotation_colors = list(phenotype = col_phenotype)) cluster_I_idx <- sampleData(lcms1)$sample_name %in% c(\"F\", \"C\") cluster_II_idx <- sampleData(lcms1)$sample_name %in% c(\"A\", \"B\", \"D\", \"E\")  temp_col <- c(\"grey\", \"red\") names(temp_col) <- c(\"Cluster II\", \"Cluster I\") col <- rep(temp_col[1], length(lcms1)) col[cluster_I_idx] <- temp_col[2] col[sampleData(lcms1)$phenotype == \"QC\"] <- NA  lcms1 |>     chromatogram(aggregationFun = \"sum\") |>     plot( col = col,      main = \"TIC after filtering retention time\", lwd = 1.5) grid() legend(\"topright\", col = temp_col,        legend = names(temp_col), lty = 1, lwd = 2,        horiz = TRUE, bty = \"n\")"},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/dataset-investigation.html","id":"known-compounds","dir":"Articles","previous_headings":"","what":"known compounds","title":"Dataset investigation: What to do when you get your data","text":"artificially isotope labeled compounds spiked individual samples, also signal endogenous compounds serum (plasma) samples. Thus, calculate next mass m/z [M+H]+ ion endogenous cystine chemical formula extract also EIC ion. calculation exact mass m/z selected ion adduct use calculateMass() mass2mz() functions MetaboCoreUtils package.  Figure 10. EIC endogenous cystine vs spiked. two cystine EICs look highly similar (endogenous shown left, isotope labeled right plot ), shift m/z, arises artificial labeling. shift allows us discriminate endogenous non-endogenous compound.","code":"#' extract endogenous cystine mass and EIC and plot. cysmass <- calculateMass(\"C6H12N2O4S2\") cys_endo <- mass2mz(cysmass, adduct = \"[M+H]+\")[, 1] eic_cys_endo <- chromatogram(lcms1, mz = cys_endo + c(-0.005, 0.005),                              rt = c(199, 219), aggregationFun = \"max\") eic_cys_spiked <-  chromatogram(lcms1 , mz = c(249.040276, 249.050276),                                  rt = c(199,219))  #' Plot versus spiked par(mfrow = c(1, 2)) plot(eic_cys_endo, col = paste0(col_sample, 80))  grid()  plot(eic_cys_spiked, col = paste0(col_sample, 80)) grid() legend(\"topright\", col = col_phenotype, legend = names(col_phenotype),         lty = 1, bty = \"n\")"},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/dataset-investigation.html","id":"further-post-processing-analysis","dir":"Articles","previous_headings":"","what":"Further post-processing analysis","title":"Dataset investigation: What to do when you get your data","text":"load lcms1 object saved preprocessing.","code":"#load preprocessed xcmsExperiment lcms1 <- readMsObject(XcmsExperiment(),     AlabasterParam(system.file(\"extdata\", \"preprocessed_lcms1\",                                package = \"Metabonaut\")))  res <- readObject(system.file(\"extdata\", \"preprocessed_res\",                                package = \"Metabonaut\"))"},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/dataset-investigation.html","id":"noise-analysis","dir":"Articles","previous_headings":"","what":"Noise analysis","title":"Dataset investigation: What to do when you get your data","text":"plot backgrounds signal study group. can interesting cases technical evaluation. cases expect similar background noise CVD CTR.  seems background noise CVD samples… coming soon…","code":"# overall signal in the dataset  #' - for each file calculate the sum of intensities  background  <- spectra(lcms1) |>     split(fromFile(lcms1)) |>     lapply(tic) |>     lapply(sum) |>     unlist()  # Overall signal that is in the chromatographic peaks detection  detected <- apply(assay(res), 2, function(x) sum(x, na.rm = TRUE))  names(background) <- names(detected) <- res$phenotype idx_qc <- sampleData(lcms1)$phenotype == \"QC\" noise <- background[!idx_qc] - detected[!idx_qc]  f <- factor(names(noise), levels = unique(names(noise))) group <- split(log2(noise), f)  plot(NULL, xlim = c(1, length(group)), ylim = range(unlist(group)),       xaxt = \"n\", xlab = \"Devices\", ylab = \"Noise\",       main = \"log2 background signal comparison between study group\") for (i in seq_along(group)) {   points(rep(i, length(group[[i]])), group[[i]], pch = 19) } axis(1, at = seq_along(group), labels = names(group))"},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/install_v0.html","id":"running-workflows-locally","dir":"Articles","previous_headings":"","what":"Running workflows locally","title":"Install","text":"install computer packages necessary workflows run code follow: get error message downloading form GitHub might due expired token. Remove using code try install :","code":"install.packages(\"BiocManager\") BiocManager::install('RforMassSpectrometry/MsIO', ask = FALSE,                      dependencies = TRUE)  BiocManager::install(\"RforMassSpectrometry/Metabonaut\",                      dependencies = TRUE, ask = FALSE, update = TRUE) #See if any token is there: gitcreds::gitcreds_get()  # Delete them: gitcreds::gitcreds_delete()"},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/install_v0.html","id":"docker-image","dir":"Articles","previous_headings":"","what":"Docker image","title":"Install","text":"vignettes files along R runtime environment including required packages RStudio (Posit) editor bundled docker container. installation, docker container can run computer code examples vignettes can evaluated within environment (without need install additional packages files). don’t already , install docker. Find installation information . Get docker image tutorial e.g. command line : Start docker container, either Docker Desktop, command line Enter http://localhost:8787 web browser log username rstudio password bioc. RStudio server version: open Quarto files vignettes folder evaluate R code blocks document.","code":"docker pull rformassspectrometry/metabonaut:latest docker run -e PASSWORD=bioc -p 8787:8787 rformassspectrometry/metabonaut:latest"},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/large-scale-analysis.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Large Scale Data Preprocessing with xcms","text":"design, xcms supports preprocessing large scale data even 10,000 samples/data files. Handling results experiments however non-trivial can require large amount main memory. Recent updates xcms, include full support MS data infrastructure provided Spectra package well new -disk storage mode preprocessing results, reduce xcms’ memory demand hence enable memory-saving large scale data processing also regular computer setups. document large public metabolomics data set 4,000 data files analyzed xcms’ memory usage performance tracked. Performance memory usage different configurations compared smaller data subset. Finally, details internal data memory handling xcms presented properties different configurations efficient (parallel) processing large scale data discussed.","code":""},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/large-scale-analysis.html","id":"data-import","dir":"Articles","previous_headings":"","what":"Data import","title":"Large Scale Data Preprocessing with xcms","text":"data analyzed document originally described paper. full data available MetaboLights repository accession ID MTBLS93. Detailed description study cohort, LC-MS setup data acquisition provided original article’s supplement. brief, samples analyzed Waters MSe mode, .e., following MS1 scan, -ion fragmentation performed recorded MS2 scan. MS1 MS2 data samples stored two separate MS data files CDF format. MS1 data files ending wiht 01.CDF respective MS2 scans file name, ending 02.CDF. present analysis focus MS1 data thus restrict import MS1-data files. MsIO R package Bioconductor’s MsBackendMetaboLights packages used retrieve cache MS data directly MetaboLights repository. data set includes total 12082605 MS spectra 4063 samples. size data object memory: Note data object contains MS metadata (.e., retention times, MS levels etc), MS peaks data (.e., m/z intensity values). default data representation Spectra package, MS peaks data loaded upon demand original data files.","code":"#' Load required libraries library(MsBackendMetaboLights) library(MsExperiment) library(MsIO) library(xcms)  library(peakRAM) # Track memory usage and processing time library(pander)  # To render tables  #' Retrieve the MS1 data from the MetaboLights data set mlp <- MetaboLightsParam(mtblsId = \"MTBLS93\", filePattern = \"01.CDF$\")  twins <- readMsObject(MsExperiment(), mlp, keepOntology = FALSE,                       keepProtocol = FALSE, simplify = FALSE) twins #> Object of class MsExperiment #>  Spectra: MS1 (12082605) #>  Experiment data: 4063 sample(s) #>  Sample data links: #>   - spectra: 4063 sample(s) to 12082605 element(s). print(object.size(twins), units = \"GB\") #> 2.7 Gb"},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/large-scale-analysis.html","id":"overview-of-sample-and-experiment-metadata","dir":"Articles","previous_headings":"Data import","what":"Overview of sample and experiment metadata","title":"Large Scale Data Preprocessing with xcms","text":"Various experimental sample metadata available data set imported object’s sampleData(). directly imported respective data files MetaboLights. format imported variable names however ideal R-based data processing thus rename relevant ones .","code":"#' Select variable names with eventually interesting information scol <- c(\"Factor Value[Gender]\", \"Factor Value[Age]\",           \"Factor Value[Cluster effect]\", \"Factor Value[RMSD]\",           \"Factor Value[Injection number]\", \"Factor Value[Spectrum type]\",           \"Factor Value[Analysis date]\", \"Sample Name\") #' Define R-save names for these names(scol) <- c(\"sex\", \"age\", \"cluster_effect\", \"rmsd\", \"injection_number\",                  \"spectrum_type\", \"analysis_date\", \"sample_name\") #' Rename the variables colnames(sampleData(twins))[match(scol, colnames(sampleData(twins)))] <-     names(scol)  table(sampleData(twins)$sex) #> #> Female   Male #>   1747   2316"},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/large-scale-analysis.html","id":"parallel-processing-setup","dir":"Articles","previous_headings":"Data import","what":"Parallel processing setup","title":"Large Scale Data Preprocessing with xcms","text":"Many functions xcms, particular ones requiring heavy calculations, support parallel processing. Processing functions split data among processes perform calculations parallel. parallel processing can reduce processing time, important note also requires data processed memory. thus always balance number parallel processes available/required memory needed. See also section Performance evaluation information. example use 8 CPUs parallel. Every function xcms supporting parallel processing now use default parallel processing setup.","code":"#' Default parallel processing setup. register(MulticoreParam(8L))"},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/large-scale-analysis.html","id":"initial-data-evaluation","dir":"Articles","previous_headings":"Data import","what":"Initial data evaluation","title":"Large Scale Data Preprocessing with xcms","text":"preprocessing, inspect available LC-MS data create base peak chromatogram (BPC). reduce processing time, create BPC 200 randomly selected samples. next create BPC. parameter chunkSize = 8L specify load process MS peaks data 8 MS data files time. peakRAM() function used track memory usage processing time. function process data 8 files time parallel, large performance gain , processing consists simply returning maximum intensity per spectrum. time maximal (peak) memory used : Peak RAM memory usage processing time BPC extraction 200 random samples. BPC 200 random samples shown . Based BPC , filter data set spectra measured 20 900 seconds. restriction data set also avoids perform chromatographic peak detection part LC compounds expected elute. strongly recommend filtering starting preprocessing reduce running time. next inspect signal selected lipids annotated original article (described Figure S2 original paper). retention times m/z values compounds taken original publication. Selected lipids annotated original article. extract plot ion chromatograms (EIC) 3 compounds 200 randomly selected samples. Apparent retention time shifts visible 3 compounds. can next evaluate chromatographic peak detection settings example signals. Chromatographic peaks detected cases, due large number samples investigated easy evaluate results properly. thus create plot first 5 samples. large peak thus correctly identified. Also lower abundance peak detected snthresh reduced peak detection EIC signal. Noise estimation difficult peak detection extracted ion signals, chromatogram contains actual signal ion. different preprocessing full data set performed next section much real background signal present full MS data properly estimate noise.","code":"#' Select 200 randomly selected samples set.seed(123) twins_rand <- twins[sample(seq_along(twins), 200)] #' Create the BPC for the data subset p <- peakRAM(     bpc <- chromatogram(twins_rand, aggregationFun = \"max\", chunkSize = 8) ) tmp <- data.frame(     `Peak RAM [MiB]` = p$Peak_RAM_Used_MiB,     `Processing time [min]` = p$Elapsed_Time_sec / 60,     check.names = FALSE) pandoc.table(     tmp, style = \"rmarkdown\", split.table = Inf,     caption = paste0(\"Peak RAM memory usage and processing time for \",                      \"BPC extraction from 200 random samples.\")) plot(bpc, col = \"#00000060\") twins <- filterSpectra(twins, filterRt, rt = c(20, 900)) #' Define m/z and retention times for annotated lipids kc <- data.frame(     name = c(\"LysoPC_18:1\", \"LysoPC_18:2\", \"MG_18:2\"),     mz = c(522.356, 520.341, 337.269),     rt = c(382.20, 347.28, 384.00) ) rownames(kc) <- kc$name kc$rtmin <- kc$rt - 20 kc$rtmax <- kc$rt + 20 kc$mzmin <- kc$mz - 0.01 kc$mzmax <- kc$mz + 0.01  pandoc.table(     kc, split.table = Inf, style = \"rmarkdown\",     caption = \"Selected lipids that were annotated in the original article.\") #' Extract the ion chromatogram for the 3 compounds eics <- chromatogram(twins_rand, mz = cbind(kc$mzmin, kc$mzmax),                      rt = cbind(kc$rtmin, kc$rtmax), chunkSize = 8) #' Plot the EICs plot(eics, col = \"#00000040\") param <- CentWaveParam(ppm = 25,                        peakwidth = c(2, 20),                        snthresh = 0,                        mzCenterFun = \"wMean\",                        integrate = 2) met_test <- findChromPeaks(eics, param = param) chromPeaks(met_test[1]) #>            mz   mzmin   mzmax      rt   rtmin   rtmax      into       intb #> mzmin 522.356 522.346 522.366 383.178 375.894 388.319 2329316.3 1691671.50 #> mzmin 522.356 522.346 522.366 382.749 375.894 387.890 2109446.7 1535929.04 #> mzmin 522.356 522.346 522.366 382.318 375.034 387.031 2393436.5 1751258.46 #> mzmin 522.356 522.346 522.366 370.321 363.636 375.034  434015.4   74434.92 #> mzmin 522.356 522.346 522.366 382.747 376.321 388.317 2208231.7 1624551.74 #> mzmin 522.356 522.346 522.366 382.318 374.606 387.031 2392099.1 1752668.52 #> mzmin 522.356 522.346 522.366 370.321 364.494 374.606  430126.8   76103.65 #> mzmin 522.356 522.346 522.366 377.607 371.180 382.320 1214597.6  891277.16 #> mzmin 522.356 522.346 522.366 381.044 374.617 386.614 2051008.3 1510790.55 #> mzmin 522.356 522.346 522.366 369.904 364.505 374.617  352557.5   62286.20 #> mzmin 522.356 522.346 522.366 383.181 376.754 387.894 1531550.0 1129829.15 #> mzmin 522.356 522.346 522.366 377.607 371.180 382.748 1927843.5 1423372.16 #> mzmin 522.356 522.346 522.366 383.175 375.892 388.317 1629758.9 1184918.57 #> mzmin 522.356 522.346 522.366 383.612 377.185 389.440 1589031.2 1176171.86 #> mzmin 522.356 522.346 522.366 383.173 376.746 389.429 2576501.4 1899088.63 #> mzmin 522.356 522.346 522.366 366.214 362.358 371.614  425588.7   96881.15 #> mzmin 522.356 522.346 522.366 378.040 371.614 383.610 2195087.6 1621585.16 #> mzmin 522.356 522.346 522.366 382.754 375.899 388.324 2159818.3 1602575.03 #> mzmin 522.356 522.346 522.366 383.177 376.322 388.318 2948737.8 2170209.49 #> mzmin 522.356 522.346 522.366 381.464 374.609 386.605 3191880.9 2385121.53 #> mzmin 522.356 522.346 522.366 369.896 362.354 374.609  554584.3  104143.98 #> mzmin 522.356 522.346 522.366 375.889 369.462 380.602 2631447.2 1968139.48 #> mzmin 522.356 522.346 522.366 382.745 376.318 387.886 1732314.5 1264163.10 #> mzmin 522.356 522.346 522.366 383.173 376.317 388.314 2641640.3 1942733.78 #> mzmin 522.356 522.346 522.366 383.181 376.326 388.322 2707103.2 1991534.74 #> mzmin 522.356 522.346 522.366 383.607 376.752 388.323 1820800.0 1341464.66 #> mzmin 522.356 522.346 522.366 382.317 375.462 387.887 3086967.1 2267324.93 #> mzmin 522.356 522.346 522.366 383.173 376.318 388.314 1833619.3 1328743.13 #> mzmin 522.356 522.346 522.366 375.893 369.038 381.463 3575538.5 2586045.65 #> mzmin 522.356 522.346 522.366 382.316 375.032 387.885 2528997.2 1869255.11 #> mzmin 522.356 522.346 522.366 381.460 374.604 387.029 2386099.7 1765416.93 #> mzmin 522.356 522.346 522.366 369.891 363.635 374.604  434664.0   93316.89 #> mzmin 522.356 522.346 522.366 377.176 370.320 382.317 1372886.0 1020096.86 #> mzmin 522.356 522.346 522.366 382.744 375.889 387.457 3882497.9 2902222.68 #> mzmin 522.356 522.346 522.366 383.606 376.750 389.433 2290938.3 1701392.78 #> mzmin 522.356 522.346 522.366 381.467 375.041 387.037 2205818.0 1605043.83 #> mzmin 522.356 522.346 522.366 369.899 364.068 375.041  400725.1   69333.14 #> mzmin 522.356 522.346 522.366 382.322 375.466 387.463 2983000.5 2215309.75 #> mzmin 522.356 522.346 522.366 370.325 364.069 375.466  536203.8  100866.18 #> mzmin 522.356 522.346 522.366 381.470 374.614 387.039 1744270.9 1277046.70 #> mzmin 522.356 522.346 522.366 369.901 363.217 374.614  310520.7   62002.05 #> mzmin 522.356 522.346 522.366 381.887 375.461 387.457 2570326.9 1902625.93 #> mzmin 522.356 522.346 522.366 370.319 364.063 375.461  461963.8   90928.84 #> mzmin 522.356 522.346 522.366 365.787 362.359 370.329  336029.1   77130.24 #> mzmin 522.356 522.346 522.366 377.612 370.329 382.754 1753468.1 1295049.99 #> mzmin 522.356 522.346 522.366 381.462 375.035 386.603 1960124.3 1461845.40 #> mzmin 522.356 522.346 522.366 369.894 364.066 375.035  351685.1   65673.61 #> mzmin 522.356 522.346 522.366 384.030 378.032 389.429 2839861.5 2148561.46 #> mzmin 522.356 522.346 522.366 383.177 375.893 387.890 2022734.3 1424566.11 #> mzmin 522.356 522.346 522.366 381.464 374.609 387.034 2120881.8 1556217.28 #> mzmin 522.356 522.346 522.366 382.327 375.472 387.468 3059265.1 2290832.82 #> mzmin 522.356 522.346 522.366 376.750 369.894 381.463 1572198.4 1164669.17 #> mzmin 522.356 522.346 522.366 382.754 375.899 388.324 2175046.0 1601646.34 #> mzmin 522.356 522.346 522.366 384.037 377.610 389.436 2592548.2 1898588.63 #> mzmin 522.356 522.346 522.366 383.172 376.317 388.314 3459509.6 2586778.59 #> mzmin 522.356 522.346 522.366 378.032 371.177 383.173 4115139.5 3083989.90 #> mzmin 522.356 522.346 522.366 381.890 374.607 387.032 2435019.5 1780321.29 #> mzmin 522.356 522.346 522.366 369.894 364.065 374.607  438228.2   75817.86 #> mzmin 522.356 522.346 522.366 382.751 375.896 387.892 2108334.0 1528709.51 #> mzmin 522.356 522.346 522.366 365.785 362.357 371.184  257020.8   58746.50 #> mzmin 522.356 522.346 522.366 377.611 371.184 382.752 1279288.1  945989.96 #> mzmin 522.356 522.346 522.366 382.754 376.327 388.323 2860061.5 2110207.60 #> mzmin 522.356 522.346 522.366 383.174 376.747 388.316 1623732.7 1181611.49 #> mzmin 522.356 522.346 522.366 377.177 369.893 381.890 1450736.1 1070691.17 #> mzmin 522.356 522.346 522.366 376.747 369.892 381.888 2417939.6 1790279.09 #> mzmin 522.356 522.346 522.366 364.921 362.350 369.892  477242.6  108814.56 #> mzmin 522.356 522.346 522.366 382.327 375.469 387.468 2054364.1 1489768.27 #> mzmin 522.356 522.346 522.366 376.323 369.468 381.465 1896668.1 1341881.84 #> mzmin 522.356 522.346 522.366 374.614 367.501 380.183 2512580.9 1802720.55 #> mzmin 522.356 522.346 522.366 363.214 362.357 367.501  267706.8   31522.33 #> mzmin 522.356 522.346 522.366 374.186 367.929 380.184 2806922.9 2037468.41 #> mzmin 522.356 522.346 522.366 363.216 362.360 367.929  305205.5   44233.13 #> mzmin 522.356 522.346 522.366 383.610 376.326 389.437 1680233.2 1223924.74 #> mzmin 522.356 522.346 522.366 381.890 375.035 387.035 2839944.8 2124523.57 #> mzmin 522.356 522.346 522.366 369.893 363.209 375.035  498447.0   92836.46 #> mzmin 522.356 522.346 522.366 382.321 375.037 387.462 2387610.9 1770255.07 #> mzmin 522.356 522.346 522.366 370.753 364.497 375.037  418502.6   76885.77 #> mzmin 522.356 522.346 522.366 383.609 376.753 389.436 1707869.3 1240638.55 #> mzmin 522.356 522.346 522.366 382.748 375.893 387.890 2715833.1 2011645.71 #> mzmin 522.356 522.346 522.366 381.039 374.613 386.181 2383458.6 1789110.73 #> mzmin 522.356 522.346 522.366 369.471 362.355 374.613  405286.9   68922.42 #> mzmin 522.356 522.346 522.366 382.321 375.894 388.319 1553144.1 1137669.96 #> mzmin 522.356 522.346 522.366 381.463 373.750 386.175 1671733.5 1207688.53 #> mzmin 522.356 522.346 522.366 369.466 364.495 373.750  288513.7   47258.66 #> mzmin 522.356 522.346 522.366 381.889 375.463 387.888 3441607.2 2533879.00 #> mzmin 522.356 522.346 522.366 370.321 363.636 375.463  634226.3  126315.55 #> mzmin 522.356 522.346 522.366 383.177 376.322 388.318 2602114.3 1905624.44 #> mzmin 522.356 522.346 522.366 374.181 367.068 379.751 1849167.8 1327442.63 #> mzmin 522.356 522.346 522.366 362.784 362.355 367.068  181227.7   24808.36 #> mzmin 522.356 522.346 522.366 377.611 371.185 382.753 1836921.1 1339196.74 #> mzmin 522.356 522.346 522.366 381.033 374.178 386.174 2273686.2 1685856.81 #> mzmin 522.356 522.346 522.366 369.465 362.351 374.178  386210.5   58625.22 #> mzmin 522.356 522.346 522.366 382.750 375.037 387.462 1941136.0 1407841.42 #> mzmin 522.356 522.346 522.366 382.317 375.462 387.887 2908273.1 2171393.49 #> mzmin 522.356 522.346 522.366 370.749 364.492 375.462  525866.9  107235.46 #> mzmin 522.356 522.346 522.366 382.324 375.897 388.323 1930101.1 1433470.24 #> mzmin 522.356 522.346 522.366 381.888 375.033 387.029 2104067.1 1579663.86 #> mzmin 522.356 522.346 522.366 369.891 364.064 375.033  374093.3   82309.65 #> mzmin 522.356 522.346 522.366 384.030 377.603 390.286 2816404.0 2105579.31 #> mzmin 522.356 522.346 522.366 383.173 376.318 387.886 1860123.3 1353316.23 #> mzmin 522.356 522.346 522.366 382.752 375.897 387.894 2060690.8 1524632.98 #> mzmin 522.356 522.346 522.366 377.183 370.328 382.753 2398310.6 1776359.45 #> mzmin 522.356 522.346 522.366 384.033 377.178 389.433 2016474.3 1503485.86 #> mzmin 522.356 522.346 522.366 376.747 369.892 381.888 1547326.5 1146186.03 #> mzmin 522.356 522.346 522.366 377.175 370.320 383.603 3267830.4 2455793.13 #> mzmin 522.356 522.346 522.366 382.743 375.887 388.313 2594247.4 1873505.46 #> mzmin 522.356 522.346 522.366 383.601 377.174 389.429 2290447.0 1698780.21 #> mzmin 522.356 522.346 522.366 384.035 377.180 389.436 2188753.8 1616893.48 #> mzmin 522.356 522.346 522.366 383.603 376.747 388.316 2460009.9 1810715.92 #> mzmin 522.356 522.346 522.366 374.179 367.495 379.749 3427851.9 2473450.62 #> mzmin 522.356 522.346 522.366 362.782 362.353 367.495  372087.4   56528.76 #> mzmin 522.356 522.346 522.366 378.462 372.036 383.175 1732354.5 1291130.12 #> mzmin 522.356 522.346 522.366 366.636 362.352 372.036  321711.8   65439.54 #> mzmin 522.356 522.346 522.366 381.888 375.461 387.457 2398272.9 1782877.22 #> mzmin 522.356 522.346 522.366 370.319 364.063 375.461  430338.6   87766.60 #> mzmin 522.356 522.346 522.366 383.181 375.897 388.322 1603270.6 1175248.15 #> mzmin 522.356 522.346 522.366 376.320 369.465 381.461 1869104.7 1372367.90 #> mzmin 522.356 522.346 522.366 382.328 375.044 387.469 3082433.4 2268962.12 #> mzmin 522.356 522.346 522.366 374.604 367.920 394.144 4831351.8 3201555.22 #> mzmin 522.356 522.346 522.366 363.207 362.350 367.920  518646.0   67333.93 #> mzmin 522.356 522.346 522.366 381.034 374.179 386.176 3515374.7 2613813.20 #> mzmin 522.356 522.346 522.366 369.466 363.210 374.179  618747.6  112703.34 #> mzmin 522.356 522.346 522.366 382.747 375.892 387.888 3926847.7 2911104.77 #> mzmin 522.356 522.346 522.366 382.319 375.892 387.461 2903971.2 2149496.31 #> mzmin 522.356 522.346 522.366 381.462 374.178 386.603 2455397.1 1777168.53 #> mzmin 522.356 522.346 522.366 381.036 374.180 386.177 3655263.1 2735203.41 #> mzmin 522.356 522.346 522.366 369.467 362.783 374.180  600349.1   89983.64 #> mzmin 522.356 522.346 522.366 381.031 374.176 386.173 2734818.9 2068683.65 #> mzmin 522.356 522.346 522.366 369.463 363.207 374.176  464874.5   87599.05 #> mzmin 522.356 522.346 522.366 381.474 375.476 387.472 2500566.2 1870099.34 #> mzmin 522.356 522.346 522.366 369.906 364.506 375.476  454479.8   95211.65 #> mzmin 522.356 522.346 522.366 383.178 375.894 387.891  975931.6  709929.88 #> mzmin 522.356 522.346 522.366 383.608 377.182 390.722 2575421.6 1917031.01 #> mzmin 522.356 522.346 522.366 383.612 376.757 389.440 2023281.7 1480673.18 #> mzmin 522.356 522.346 522.366 377.608 371.610 382.321 1768729.0 1311186.28 #> mzmin 522.356 522.346 522.366 383.185 377.187 389.441 2221410.8 1660751.00 #> mzmin 522.356 522.346 522.366 377.615 370.331 382.328 1596238.2 1164622.07 #> mzmin 522.356 522.346 522.366 382.755 375.900 387.897 2174740.6 1571647.17 #> mzmin 522.356 522.346 522.366 383.601 376.318 388.314 3141739.6 2290738.90 #> mzmin 522.356 522.346 522.366 366.215 362.359 370.758  342072.9   75665.96 #> mzmin 522.356 522.346 522.366 377.613 370.758 383.183 1801191.5 1338311.43 #> mzmin 522.356 522.346 522.366 383.173 375.890 387.886 1952504.9 1414881.83 #> mzmin 522.356 522.346 522.366 381.891 375.464 387.032 2689176.8 2019966.43 #> mzmin 522.356 522.346 522.366 369.894 363.638 375.464  491346.9  107065.33 #> mzmin 522.356 522.346 522.366 374.605 367.492 379.746 2820994.7 2039365.32 #> mzmin 522.356 522.346 522.366 363.207 362.350 367.492  325471.8   49337.28 #> mzmin 522.356 522.346 522.366 377.183 370.327 381.896 2491687.0 1827564.73 #> mzmin 522.356 522.346 522.366 382.747 375.892 387.891 2030175.9 1488602.17 #> mzmin 522.356 522.346 522.366 381.893 375.035 387.034 3042707.7 2186548.50 #> mzmin 522.356 522.346 522.366 382.754 376.327 387.895 2317259.0 1712817.01 #> mzmin 522.356 522.346 522.366 366.216 362.360 371.615  407195.8   88697.78 #> mzmin 522.356 522.346 522.366 378.042 371.615 383.183 2115309.4 1574874.53 #> mzmin 522.356 522.346 522.366 384.041 376.757 389.440 1698767.8 1225010.04 #> mzmin 522.356 522.346 522.366 382.755 375.900 388.325 2381527.4 1774809.40 #> mzmin 522.356 522.346 522.366 382.756 375.900 387.897 2646746.7 1949922.67 #> mzmin 522.356 522.346 522.366 381.893 375.037 387.034 1716654.1 1267824.37 #> mzmin 522.356 522.346 522.366 369.896 363.638 375.037  302022.7   56762.70 #> mzmin 522.356 522.346 522.366 382.322 375.467 387.892 3003463.9 2171491.76 #> mzmin 522.356 522.346 522.366 373.748 367.492 379.318 4314066.9 3216038.15 #> mzmin 522.356 522.346 522.366 362.779 362.350 367.492  462992.4   88084.72 #> mzmin 522.356 522.346 522.366 381.891 374.608 386.604 2589521.9 1884998.67 #> mzmin 522.356 522.346 522.366 375.034 367.921 380.175 3795309.3 2731289.55 #> mzmin 522.356 522.346 522.366 377.606 370.750 382.747 1593461.9 1182094.34 #> mzmin 522.356 522.346 522.366 381.035 373.751 387.462 2679117.9 1929073.93 #> mzmin 522.356 522.346 522.366 369.467 362.354 373.751  460677.3   69319.93 #> mzmin 522.356 522.346 522.366 382.750 375.895 388.320 2211528.4 1614088.25 #> mzmin 522.356 522.346 522.366 383.179 376.753 389.436 2728839.6 2033429.50 #> mzmin 522.356 522.346 522.366 382.747 376.749 388.317 4462456.3 3359281.38 #> mzmin 522.356 522.346 522.366 375.891 369.036 380.175 2765294.8 2051628.31 #> mzmin 522.356 522.346 522.366 384.893 378.466 389.864 1850762.9 1357849.61 #> mzmin 522.356 522.346 522.366 376.746 370.319 381.887 1838111.4 1384937.19 #> mzmin 522.356 522.346 522.366 364.920 362.349 370.319  348657.3   79093.96 #> mzmin 522.356 522.346 522.366 377.187 370.331 382.328 1919850.2 1414417.19 #> mzmin 522.356 522.346 522.366 382.319 375.463 387.460 2512170.8 1825938.48 #> mzmin 522.356 522.346 522.366 383.176 375.893 388.318 3464110.3 2548938.97 #> mzmin 522.356 522.346 522.366 382.325 375.041 387.895 1711929.3 1236520.51 #> mzmin 522.356 522.346 522.366 382.750 375.466 387.463 1874994.7 1356212.89 #> mzmin 522.356 522.346 522.366 384.031 378.032 389.430 2335830.3 1750741.50 #> mzmin 522.356 522.346 522.366 382.326 375.043 387.468 1856984.8 1353801.10 #> mzmin 522.356 522.346 522.366 382.750 375.466 387.891 2374613.8 1731508.24 #> mzmin 522.356 522.346 522.366 382.755 376.329 387.897 1224086.2  912666.04 #> mzmin 522.356 522.346 522.366 370.759 365.785 376.329  234859.9   48467.91 #> mzmin 522.356 522.346 522.366 375.471 367.930 380.613 2815492.0 2039228.18 #> mzmin 522.356 522.346 522.366 383.177 375.894 387.890 3520511.7 2543703.97 #> mzmin 522.356 522.346 522.366 384.040 377.185 389.868 2177350.0 1587466.74 #> mzmin 522.356 522.346 522.366 366.207 362.351 371.606  433835.4  108867.86 #> mzmin 522.356 522.346 522.366 377.604 371.606 382.746 2115917.6 1586722.51 #> mzmin 522.356 522.346 522.366 382.319 375.035 387.032 1836587.3 1332930.29 #> mzmin 522.356 522.346 522.366 370.751 364.495 375.035  345512.1   60528.73 #> mzmin 522.356 522.346 522.366 374.608 367.923 379.749 3913180.9 2967303.64 #> mzmin 522.356 522.346 522.366 363.210 362.353 367.923  441399.8  101855.91 #> mzmin 522.356 522.346 522.366 377.181 370.326 381.894 1647764.0 1230961.34 #> mzmin 522.356 522.346 522.366 383.172 375.460 387.885 3167492.8 2323885.71 #> mzmin 522.356 522.346 522.366 383.175 376.748 387.888 2019163.5 1477971.10 #> mzmin 522.356 522.346 522.366 374.607 367.923 387.032 2550426.6 1808383.23 #> mzmin 522.356 522.346 522.366 363.210 362.353 367.923  307543.1   71084.43 #> mzmin 522.356 522.346 522.366 377.605 370.321 382.318 1556959.9 1109312.71 #> mzmin 522.356 522.346 522.366 383.605 376.749 389.432 2800439.6 2068253.05 #> mzmin 522.356 522.346 522.366 383.182 375.899 388.327 2135799.0 1549305.38 #> mzmin 522.356 522.346 522.366 382.321 375.466 387.891 2858350.2 2122520.26 #> mzmin 522.356 522.346 522.366 370.325 364.068 375.466  533950.6  119288.08 #> mzmin 522.356 522.346 522.366 382.320 375.893 387.890 2309688.4 1722115.28 #> mzmin 522.356 522.346 522.366 370.752 364.924 375.893  434450.1   88519.09 #> mzmin 522.356 522.346 522.366 381.040 374.184 386.181 3162709.2 2365360.58 #> mzmin 522.356 522.346 522.366 369.900 363.644 374.184  538486.3   94416.87 #> mzmin 522.356 522.346 522.366 381.891 374.608 386.604 1919625.7 1413361.24 #> mzmin 522.356 522.346 522.366 369.895 363.210 374.608  338807.8   64929.27 #> mzmin 522.356 522.346 522.366 384.031 376.747 389.430 3574349.2 2619786.77 #> mzmin 522.356 522.346 522.366 381.035 374.180 386.605 2846110.7 2107483.17 #> mzmin 522.356 522.346 522.366 369.467 364.068 374.180  503873.6   94600.22 #> mzmin 522.356 522.346 522.366 382.747 375.892 388.317 1914724.6 1369926.79 #> mzmin 522.356 522.346 522.366 383.175 376.320 388.316 3006959.5 2220269.66 #> mzmin 522.356 522.346 522.366 378.889 371.606 384.031 1921871.0 1407428.48 #> mzmin 522.356 522.346 522.366 366.635 362.350 371.606  349116.9   72229.71 #> mzmin 522.356 522.346 522.366 383.174 376.747 389.433 3403531.9 2527401.86 #> mzmin 522.356 522.346 522.366 383.171 376.744 389.427 2312758.2 1705158.93 #> mzmin 522.356 522.346 522.366 383.172 376.317 388.314 1932861.1 1371756.67 #> mzmin 522.356 522.346 522.366 382.749 376.322 388.319 2648367.9 1961782.47 #> mzmin 522.356 522.346 522.366 375.466 369.039 381.036 3384097.4 2491074.90 #> mzmin 522.356 522.346 522.366 365.351 362.352 370.322  244400.6   56296.32 #> mzmin 522.356 522.346 522.366 377.177 370.322 382.747 1243229.5  919984.16 #> mzmin 522.356 522.346 522.366 375.044 367.931 379.757 3401917.5 2532918.45 #> mzmin 522.356 522.346 522.366 363.218 362.361 367.931  440918.5   93091.05 #> mzmin 522.356 522.346 522.366 384.459 378.032 390.287 2550648.3 1908433.56 #> mzmin 522.356 522.346 522.366 376.318 369.891 381.888 3853586.8 2846487.26 #> mzmin 522.356 522.346 522.366 381.032 374.177 385.745 2821263.8 2085828.83 #> mzmin 522.356 522.346 522.366 369.464 363.208 374.177  482147.5   70749.46 #> mzmin 522.356 522.346 522.366 383.178 376.751 389.434 2897790.2 2154484.07 #> mzmin 522.356 522.346 522.366 381.462 374.606 386.603 1647892.9 1226547.13 #> mzmin 522.356 522.346 522.366 369.893 365.351 374.606  278696.2   46999.41 #> mzmin 522.356 522.346 522.366 381.036 373.752 386.177 2020923.5 1462086.20 #> mzmin 522.356 522.346 522.366 369.468 362.355 373.752  340468.3   47034.35 #> mzmin 522.356 522.346 522.366 383.179 376.324 388.320 1577779.1 1139311.95 #> mzmin 522.356 522.346 522.366 383.178 376.751 388.319 3359094.6 2486753.17 #> mzmin 522.356 522.346 522.366 383.175 376.748 388.316 1841937.5 1354622.15 #> mzmin 522.356 522.346 522.366 382.745 376.746 388.314 1166437.2  837247.79 #> mzmin 522.356 522.346 522.366 381.890 375.034 387.459 2743686.0 2046556.01 #> mzmin 522.356 522.346 522.366 370.322 364.065 375.034  481238.6   92630.72 #> mzmin 522.356 522.346 522.366 383.602 376.747 389.429 3428582.1 2588084.81 #> mzmin 522.356 522.346 522.366 371.604 365.776 376.747  646964.6  147756.72 #> mzmin 522.356 522.346 522.366 382.323 375.468 387.465 1145822.5  838750.87 #> mzmin 522.356 522.346 522.366 370.755 364.927 375.468  214481.2   39355.57 #> mzmin 522.356 522.346 522.366 381.036 373.752 385.751 1445241.5 1048126.32 #> mzmin 522.356 522.346 522.366 369.467 362.354 373.752  244374.5   32865.30 #> mzmin 522.356 522.346 522.366 382.751 375.896 387.896 1589300.4 1130817.52 #> mzmin 522.356 522.346 522.366 364.923 362.352 370.322  624172.7  175046.58 #> mzmin 522.356 522.346 522.366 376.749 370.322 382.747 2966208.1 2234019.11 #> mzmin 522.356 522.346 522.366 374.183 367.927 379.753 3288162.9 2508525.88 #> mzmin 522.356 522.346 522.366 363.214 362.357 367.927  363254.6   85045.73 #> mzmin 522.356 522.346 522.366 381.474 374.619 386.616 2327763.7 1693686.86 #> mzmin 522.356 522.346 522.366 369.906 362.793 374.619  412984.1   72401.54 #> mzmin 522.356 522.346 522.366 374.604 367.920 381.459 2613982.1 1896292.25 #> mzmin 522.356 522.346 522.366 363.207 362.350 367.920  297866.1   54577.98 #> mzmin 522.356 522.346 522.366 382.321 375.466 387.891 3033563.0 2222154.91 #> mzmin 522.356 522.346 522.366 380.606 373.323 385.748 2129342.8 1578041.91 #> mzmin 522.356 522.346 522.366 369.467 362.354 373.323  375599.6   60424.71 #> mzmin 522.356 522.346 522.366 382.746 375.462 387.887 1978066.9 1434326.17 #> mzmin 522.356 522.346 522.366 374.609 367.924 381.039 3001146.6 2197610.82 #> mzmin 522.356 522.346 522.366 363.211 362.354 367.924  349321.1   65234.48 #> mzmin 522.356 522.346 522.366 381.901 374.617 386.617 1959836.4 1441143.39 #> mzmin 522.356 522.346 522.366 369.904 364.076 374.617  361967.8   73823.90 #> mzmin 522.356 522.346 522.366 382.749 375.466 387.891 1931735.0 1421249.78 #> mzmin 522.356 522.346 522.366 375.033 367.920 381.032 1568617.2 1113491.16 #> mzmin 522.356 522.346 522.366 363.207 362.350 367.920  195614.8   34299.58 #> mzmin 522.356 522.346 522.366 381.893 375.037 387.462 2206663.4 1618709.06 #> mzmin 522.356 522.346 522.366 370.324 362.783 375.037  400282.3   73240.71 #> mzmin 522.356 522.346 522.366 382.754 376.756 387.896 2397374.5 1777954.32 #> mzmin 522.356 522.346 522.366 374.176 367.492 379.746 2819379.4 2046839.32 #> mzmin 522.356 522.346 522.366 362.779 362.350 367.492  304216.8   48229.23 #> mzmin 522.356 522.346 522.366 383.176 376.318 388.317 2574295.2 1863297.21 #> mzmin 522.356 522.346 522.366 365.784 362.357 369.898  250445.9   55641.36 #> mzmin 522.356 522.346 522.366 377.610 369.898 382.323 1262619.8  918800.48 #> mzmin 522.356 522.346 522.366 377.611 370.756 382.753 1538661.9 1141035.50 #>            maxo sn row column #> mzmin 505062.25  5   1      1 #> mzmin 469037.25  5   1      2 #> mzmin 527234.00  5   1      3 #> mzmin  99709.62  0   1      3 #> mzmin 476111.50  5   1      4 #> mzmin 544067.50  5   1      5 #> mzmin  99405.19  0   1      5 #> mzmin 274477.00  5   1      6 #> mzmin 460259.50  5   1      7 #> mzmin  86726.44  0   1      7 #> mzmin 341555.25  5   1      8 #> mzmin 422490.25  5   1      9 #> mzmin 358786.75  5   1     10 #> mzmin 337271.50  5   1     11 #> mzmin 530651.00  5   1     12 #> mzmin  97933.19  0   1     13 #> mzmin 495421.50  5   1     13 #> mzmin 482105.50  5   1     14 #> mzmin 654380.00  5   1     15 #> mzmin 696622.00  5   1     16 #> mzmin 133485.38  0   1     16 #> mzmin 580158.50  5   1     17 #> mzmin 386764.50  5   1     18 #> mzmin 567964.00  5   1     19 #> mzmin 599651.50  5   1     20 #> mzmin 396753.25  5   1     21 #> mzmin 670585.00  5   1     22 #> mzmin 412412.75  5   1     23 #> mzmin 783054.50  5   1     24 #> mzmin 560243.00  5   1     25 #> mzmin 535759.50  5   1     26 #> mzmin 105577.31  0   1     26 #> mzmin 310655.00  5   1     27 #> mzmin 871173.50  5   1     28 #> mzmin 485717.75  5   1     29 #> mzmin 484035.50  5   1     30 #> mzmin  94391.25  0   1     30 #> mzmin 659508.50  5   1     31 #> mzmin 127623.81  0   1     31 #> mzmin 378348.25  5   1     32 #> mzmin  76249.00  0   1     32 #> mzmin 588307.50  5   1     33 #> mzmin 111054.12  0   1     33 #> mzmin  80581.44  0   1     34 #> mzmin 398369.00  5   1     34 #> mzmin 429353.25  5   1     35 #> mzmin  85248.75  0   1     35 #> mzmin 613045.00  5   1     36 #> mzmin 433912.25  5   1     37 #> mzmin 443480.00  5   1     38 #> mzmin 688977.50  5   1     39 #> mzmin 347689.25  5   1     40 #> mzmin 469665.50  5   1     41 #> mzmin 560474.00  5   1     42 #> mzmin 769049.00  5   1     43 #> mzmin 909657.00  5   1     44 #> mzmin 522593.00  5   1     45 #> mzmin 100564.25  0   1     45 #> mzmin 450016.75  5   1     46 #> mzmin  58704.38  0   1     47 #> mzmin 282637.75  5   1     47 #> mzmin 648903.00  5   1     48 #> mzmin 349884.75  5   1     49 #> mzmin 324932.25  5   1     50 #> mzmin 550390.50  5   1     51 #> mzmin 110184.38  0   1     51 #> mzmin 453999.75  5   1     52 #> mzmin 394729.00  5   1     53 #> mzmin 467216.75  4   1     54 #> mzmin  80938.94  0   1     54 #> mzmin 505360.50  4   1     55 #> mzmin  97738.19  0   1     55 #> mzmin 354359.25  5   1     56 #> mzmin 618766.50  5   1     57 #> mzmin 115579.00  0   1     57 #> mzmin 535672.00  5   1     58 #> mzmin  97729.69  0   1     58 #> mzmin 345654.75  5   1     59 #> mzmin 617972.00  5   1     60 #> mzmin 528756.50  5   1     61 #> mzmin  99231.75  0   1     61 #> mzmin 346038.25  5   1     62 #> mzmin 377532.75  5   1     63 #> mzmin  71880.00  0   1     63 #> mzmin 749257.50  5   1     64 #> mzmin 148101.75  0   1     64 #> mzmin 563324.50  5   1     65 #> mzmin 338636.25  4   1     66 #> mzmin  64183.00  0   1     66 #> mzmin 415433.75  5   1     67 #> mzmin 493507.75  5   1     68 #> mzmin  91182.31  0   1     68 #> mzmin 432411.75  5   1     69 #> mzmin 652434.00  5   1     70 #> mzmin 120804.25  0   1     70 #> mzmin 416632.00  5   1     71 #> mzmin 468365.75  5   1     72 #> mzmin  90546.19  0   1     72 #> mzmin 596241.50  4   1     73 #> mzmin 410788.25  5   1     74 #> mzmin 459830.75  5   1     75 #> mzmin 540872.50  5   1     76 #> mzmin 429923.75  5   1     77 #> mzmin 337735.75  5   1     78 #> mzmin 725348.50  5   1     79 #> mzmin 542000.00  5   1     80 #> mzmin 468235.75  5   1     81 #> mzmin 468371.00  5   1     82 #> mzmin 552889.50  5   1     83 #> mzmin 636915.50  4   1     84 #> mzmin 123911.31  0   1     84 #> mzmin 390472.50  5   1     85 #> mzmin  75670.31  0   1     85 #> mzmin 534114.50  5   1     86 #> mzmin 102293.38  0   1     86 #> mzmin 349704.50  5   1     87 #> mzmin 411993.75  5   1     88 #> mzmin 684744.50  5   1     89 #> mzmin 784298.00  4   1     90 #> mzmin 146382.75  0   1     90 #> mzmin 801146.50  5   1     91 #> mzmin 155463.50  0   1     91 #> mzmin 880783.50  5   1     92 #> mzmin 631979.00  5   1     93 #> mzmin 526810.00  5   1     94 #> mzmin 797662.00  5   1     95 #> mzmin 150555.62  0   1     95 #> mzmin 627422.50  5   1     96 #> mzmin 118060.19  0   1     96 #> mzmin 535503.00  5   1     97 #> mzmin 108710.06  0   1     97 #> mzmin 214049.50  5   1     98 #> mzmin 546659.00  5   1     99 #> mzmin 418177.25  4   1    100 #> mzmin 395658.00  5   1    101 #> mzmin 476857.25  5   1    102 #> mzmin 349556.75  5   1    103 #> mzmin 463396.75  5   1    104 #> mzmin 689120.50  5   1    105 #> mzmin  79409.56  0   1    106 #> mzmin 409021.00  5   1    106 #> mzmin 431215.25  5   1    107 #> mzmin 595986.00  5   1    108 #> mzmin 115880.94  0   1    108 #> mzmin 525786.00  4   1    109 #> mzmin 100198.44  0   1    109 #> mzmin 542828.00  5   1    110 #> mzmin 435780.00  5   1    111 #> mzmin 654031.50  5   1    112 #> mzmin 507430.50  5   1    113 #> mzmin  93856.75  0   1    114 #> mzmin 472216.50  5   1    114 #> mzmin 357488.25  5   1    115 #> mzmin 522813.25  5   1    116 #> mzmin 584634.00  5   1    117 #> mzmin 380565.00  5   1    118 #> mzmin  72141.19  0   1    118 #> mzmin 646349.00  5   1    119 #> mzmin 876852.00  5   1    120 #> mzmin 158602.38  0   1    120 #> mzmin 570932.50  5   1    121 #> mzmin 770536.00  5   1    122 #> mzmin 351706.25  5   1    123 #> mzmin 545440.50  5   1    124 #> mzmin 111217.25  0   1    124 #> mzmin 470147.75  5   1    125 #> mzmin 577577.50  5   1    126 #> mzmin 982702.50  5   1    127 #> mzmin 618394.50  5   1    128 #> mzmin 393125.00  5   1    129 #> mzmin 418638.25  5   1    130 #> mzmin  84117.31  0   1    130 #> mzmin 436238.00  5   1    131 #> mzmin 539739.00  5   1    132 #> mzmin 751589.50  5   1    133 #> mzmin 369992.25  5   1    134 #> mzmin 408669.75  5   1    135 #> mzmin 489026.75  5   1    136 #> mzmin 413686.00  5   1    137 #> mzmin 525865.00  5   1    138 #> mzmin 278108.50  5   1    139 #> mzmin  53870.31  0   1    139 #> mzmin 574771.00  5   1    140 #> mzmin 784325.50  5   1    141 #> mzmin 462810.50  5   1    142 #> mzmin 101750.38  1   1    143 #> mzmin 480395.25  5   1    143 #> mzmin 408442.75  5   1    144 #> mzmin  82881.75  0   1    144 #> mzmin 800261.50  5   1    145 #> mzmin 148591.75  0   1    145 #> mzmin 387537.25  5   1    146 #> mzmin 696948.00  5   1    147 #> mzmin 453467.25  5   1    148 #> mzmin 500884.00  5   1    149 #> mzmin  91079.81  0   1    149 #> mzmin 334148.25  5   1    150 #> mzmin 583614.00  5   1    151 #> mzmin 475058.50  5   1    152 #> mzmin 626606.00  5   1    153 #> mzmin 129955.50  0   1    153 #> mzmin 516856.50  5   1    154 #> mzmin 101405.25  0   1    154 #> mzmin 710441.50  5   1    155 #> mzmin 134606.62  0   1    155 #> mzmin 434388.50  5   1    156 #> mzmin  84035.31  0   1    156 #> mzmin 745037.00  5   1    157 #> mzmin 623132.00  5   1    158 #> mzmin 129783.62  0   1    158 #> mzmin 408664.25  5   1    159 #> mzmin 667948.50  5   1    160 #> mzmin 421596.00  5   1    161 #> mzmin  82891.94  0   1    161 #> mzmin 699641.50  5   1    162 #> mzmin 478371.75  5   1    163 #> mzmin 404516.75  4   1    164 #> mzmin 592300.50  5   1    165 #> mzmin 723406.00  5   1    166 #> mzmin  58321.78  1   1    167 #> mzmin 281265.50  5   1    167 #> mzmin 705038.00  5   1    168 #> mzmin 132605.12  0   1    168 #> mzmin 542212.00  5   1    169 #> mzmin 831527.50  5   1    170 #> mzmin 637830.50  5   1    171 #> mzmin 118921.50  0   1    171 #> mzmin 589878.50  5   1    172 #> mzmin 359412.25  5   1    173 #> mzmin  66032.00  0   1    173 #> mzmin 438044.25  5   1    174 #> mzmin  81963.75  0   1    174 #> mzmin 340489.75  4   1    175 #> mzmin 764716.00  5   1    176 #> mzmin 413497.00  5   1    177 #> mzmin 252840.25  5   1    178 #> mzmin 608550.00  5   1    179 #> mzmin 113447.69  0   1    179 #> mzmin 742607.00  5   1    180 #> mzmin 146555.12  0   1    180 #> mzmin 256186.12  5   1    181 #> mzmin  51481.81  0   1    181 #> mzmin 315986.25  5   1    182 #> mzmin  62163.91  0   1    182 #> mzmin 347370.50  5   1    183 #> mzmin 142201.88  1   1    184 #> mzmin 641799.00  5   1    184 #> mzmin 705950.50  5   1    185 #> mzmin 126246.38  0   1    185 #> mzmin 503605.75  5   1    186 #> mzmin 102277.75  0   1    186 #> mzmin 483006.25  4   1    187 #> mzmin  92715.88  0   1    187 #> mzmin 657469.50  5   1    188 #> mzmin 458763.25  5   1    189 #> mzmin  91418.88  0   1    189 #> mzmin 433193.75  5   1    190 #> mzmin 560260.00  4   1    191 #> mzmin 106375.75  0   1    191 #> mzmin 436491.50  5   1    192 #> mzmin  87910.88  0   1    192 #> mzmin 439303.50  5   1    193 #> mzmin 284208.00  4   1    194 #> mzmin  56540.03  0   1    194 #> mzmin 468735.50  5   1    195 #> mzmin  91264.31  0   1    195 #> mzmin 528609.00  5   1    196 #> mzmin 525601.00  4   1    197 #> mzmin 100532.81  0   1    197 #> mzmin 574200.50  5   1    198 #> mzmin  58813.25  0   1    199 #> mzmin 284014.00  5   1    199 #> mzmin 351122.25  5   1    200 plot(met_test) plot(met_test[, 1:5])"},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/large-scale-analysis.html","id":"preprocessing","dir":"Articles","previous_headings":"Data import","what":"Preprocessing","title":"Large Scale Data Preprocessing with xcms","text":"next perform preprocessing LC-MS data. Settings individual processing steps taken original data analysis R script adapted new xcms interface. first perform chromatographic peak detection using centWave method. parameter hdf5File define name (eventually path) file keep preprocessing results. Information identified chromatographic peaks results later preprocessing steps stored file. HDF5 file format guarantees efficient storage, retrieval, results subsets thereof. memory footprint new result object thus small ideal processing large data sets, also conventional computing infrastructure (e.g. laptop). chunkSize = 8 define load process MS data 8 data files time. Peak detection performed parallel 8 CPUs using predefined default parallel processing setup. Memory usage time elapsed processing step : Peak RAM memory usage processing time chromatographic peak detection step full data. result, findChromPeaks() function returned object type XcmsExperimentHdf5, , described , stored preprocessing results -disk file HDF5 format. size result object memory thus much larger original object representing MS data: identified chromatographic peaks stored numeric matrix. Depending size experiment MS data files well used peak detection settings, matrix can also large use big part main memory, can significantly slow subsequent analysis steps. load data matrix memory evaluate size. present data set used settings, size chromatographic peak matrix seems manageable also regular computers. However, data object time memory can negative impact processing efficiency worst case R running memory along analysis. count number chromatographic peaks detected per sample determine also total sum. take advantage possibility load selected columns chromatographic peak matrix, reduce memory need present calculation. Also, use bySample = TRUE returns result list chromatographic peak matrices. length list equal number samples element chromatographic peak matrix one sample. 5000 6000 chromatographic peaks detected per sample. total number peaks : Next perform peak refinement. step helps reduce common peak detection artifacts, duplicated peaks, overlapping peaks artificially split peaks. , process data chunks 8 data files time keep memory usage manageable used computer system. Memory usage time elapsed processing step : Peak RAM memory usage processing time chromatographic peak refinement. retention time alignment use peak groups method, adjusts retention time shifts samples based retention times common compounds present samples (called anchor peaks). thus run next initial correspondence analysis (relaxed settings retention time differences) order define . Peak RAM memory usage processing time correspondence analysis. can next perform retention time alignment using peak groups method. Peak RAM memory usage processing time retention time alignment analysis. evaluate performance alignment EICs 3 known compounds 200 random samples. EICs nicely aligned. perform now final correspondence analysis match aligned chromatographic peaks across samples define LC-MS features. reduce minFraction parameter also define features chromatographic peaks present 30% samples use stringent bw parameter. Peak RAM memory usage processing time final correspondence analysis. also evaluate whether correspondence correctly define features 3 selected lipids. Correspondence able correctly assign chromatographic peaks left center peaks separate feature. Also second example, chromatographic peaks assigned two separate features. Finally, also last example chromatographic peaks correctly assigned features. extract feature abundances features samples count total number defined features. featureValues() function collects extracts information associated HDF5 file used store correspondence results. total number missing values data matrix : last step therefore perform gap-filling rescue abundances features samples chromatographic peak detected (hence missing value reported). can benefit chunk-wise parallel processing. Peak RAM memory usage processing time gap filling. number missing values gap filling: Since preprocessing results stored HDF5 file hence -disk, size final results object larger size initial data object representing MS data experiment. Note size reduced (eventually overall performance improved) storing MS data SQL database representing/interfacing Spectra backend MsBackendSql package (see last section vignette information). results preprocessing now converted SummarizedExperiment object using quantify() function continue analysis e.g. performing data exploration, normalization statistical data analysis.","code":"cwp <- CentWaveParam(ppm = 25,                      peakwidth = c(2, 20),                      prefilter = c(3, 500),                      snthresh = 8,                      mzCenterFun = \"wMean\",                      integrate = 2)  if (file.exists(\"twins.h5\")) invisible(file.remove(\"twins.h5\")) p <- peakRAM(     twins <- findChromPeaks(twins, param = cwp, chunkSize = 8,                             hdf5File = \"twins.h5\") ) tmp <- data.frame(     `Peak RAM [MiB]` = p$Peak_RAM_Used_MiB,     `Processing time [min]` = p$Elapsed_Time_sec / 60,     check.names = FALSE) pandoc.table(     tmp, style = \"rmarkdown\", split.table = Inf,     caption = paste0(\"Peak RAM memory usage and processing time for \",                      \"the chromatographic peak detection step on the\",                      \" full data.\")) print(object.size(twins), units = \"GB\") #> 1.8 Gb #' Load the chromatographic peak detection results and #' get its size. chromPeaks(twins) |>     object.size() |>     print(units = \"GB\") #> 3.4 Gb #' Load the \"into\" column from the chrom peak matrix pc <- chromPeaks(twins, columns = \"into\", bySample = TRUE)  #' The distribution of the number of peaks counts vapply(pc, nrow, integer(1)) |>     quantile() #>     0%    25%    50%    75%   100% #> 3344.0 4919.5 5511.0 6124.0 9167.0 vapply(pc, nrow, integer(1)) |>     sum() #> [1] 22568648 #' Perform peak refinement mnpp <- MergeNeighboringPeaksParam(expandRt = 5)  p <- peakRAM(     twins <- refineChromPeaks(twins, param = mnpp, chunkSize = 8) ) tmp <- data.frame(     `Peak RAM [MiB]` = p$Peak_RAM_Used_MiB,     `Processing time [hours]` = p$Elapsed_Time_sec / 60 / 60,     check.names = FALSE) pandoc.table(     tmp, style = \"rmarkdown\", split.table = Inf,     caption = paste0(\"Peak RAM memory usage and processing time for \",                      \"the chromatographic peak refinement.\")) #' Define settings for an initial correspondence analysis: #' require anchor peaks to be present in 70% of samples, but use a #' larger bw to allow rt shifts pdp <- PeakDensityParam(sampleGroups = rep(1L, length(twins)),                         minFraction = 0.7,                         binSize = 0.01,                         ppm = 10,                         bw = 3.5)  p <- peakRAM(     twins <- groupChromPeaks(twins, param = pdp) ) tmp <- data.frame(     `Peak RAM [MiB]` = p$Peak_RAM_Used_MiB,     `Processing time [min]` = p$Elapsed_Time_sec / 60,     check.names = FALSE) pandoc.table(     tmp, style = \"rmarkdown\", split.table = Inf,     caption = paste0(\"Peak RAM memory usage and processing time for \",                      \"a correspondence analysis.\")) pgp <- PeakGroupsParam(minFraction = 0.8, extraPeaks = 100,                        span = 0.5) #' Perform the alignment p <- peakRAM(     twins <- adjustRtime(twins, param = pgp) ) tmp <- data.frame(     `Peak RAM [MiB]` = p$Peak_RAM_Used_MiB,     `Processing time [min]` = p$Elapsed_Time_sec / 60,     check.names = FALSE) pandoc.table(     tmp, style = \"rmarkdown\", split.table = Inf,     caption = paste0(\"Peak RAM memory usage and processing time for \",                      \"the retention time alignment analysis.\")) #' Select 200 random samples and extract ion chromatograms for the 3 #' annotated lipids. We reuse the same random seed to choose the same #' random samples selected before. Note that we use `keepAdjustedRtime = TRUE` #' to avoid the retention times being restored to the original values. set.seed(123) twins_rand <- twins[sample(seq_along(twins), 200), keepAdjustedRtime = TRUE] #' Extract the ion chromatogram for the 3 compounds eics <- chromatogram(twins_rand, mz = cbind(kc$mzmin, kc$mzmax),                      rt = cbind(kc$rtmin, kc$rtmax), chunkSize = 8) #' Plot the EICs plot(eics, col = \"#00000020\", peakBg = NA) pdp <- PeakDensityParam(sampleGroups = rep(1L, length(twins)),                         minFraction = 0.3,                         binSize = 0.01,                         ppm = 10,                         bw = 1.5)  p <- peakRAM(     twins <- groupChromPeaks(twins, param = pdp) ) tmp <- data.frame(     `Peak RAM [MiB]` = p$Peak_RAM_Used_MiB,     `Processing time [min]` = p$Elapsed_Time_sec / 60,     check.names = FALSE) pandoc.table(     tmp, style = \"rmarkdown\", split.table = Inf,     caption = paste0(\"Peak RAM memory usage and processing time for \",                      \"the final correspondence analysis.\")) set.seed(123) twins_rand <- twins[sample(seq_along(twins), 200),                     keepAdjustedRtime = TRUE, keepFeatures = TRUE] eics <- chromatogram(twins_rand, mz = cbind(kc$mzmin, kc$mzmax),                      rt = cbind(kc$rtmin, kc$rtmax), chunkSize = 8) plotChromPeakDensity(eics[1]) plotChromPeakDensity(eics[2]) plotChromPeakDensity(eics[3]) #' Extract the feature abundances for all features in all samples fvals <- featureValues(twins, value = \"into\", method = \"sum\") nrow(fvals) #> [1] 4981 sum(is.na(fvals)) #> [1] 6690736 #' Perform the gap filling cpap <- ChromPeakAreaParam()  p <- peakRAM(     twins <- fillChromPeaks(twins, param = cpap, chunkSize = 8) ) tmp <- data.frame(     `Peak RAM [MiB]` = p$Peak_RAM_Used_MiB,     `Processing time [hours]` = p$Elapsed_Time_sec / 60 / 60,     check.names = FALSE) pandoc.table(     tmp, style = \"rmarkdown\", split.table = Inf,     caption = paste0(\"Peak RAM memory usage and processing time for \",                      \"gap filling.\")) sum(is.na(featureValues(twins, value = \"into\", method = \"sum\"))) #> [1] 61443 print(object.size(twins), unit = \"GB\") #> 1.9 Gb"},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/large-scale-analysis.html","id":"performance-evaluation","dir":"Articles","previous_headings":"","what":"Performance evaluation","title":"Large Scale Data Preprocessing with xcms","text":"section evaluate performance memory requirements xcms data preprocessing. R’s copy--change strategy can bottleneck, particular large data sets data objects (hence preprocessing results) copied temporarily data analysis. compare memory usage default XcmsExperiment object well new XcmsExperimentHdf5 result object evaluate scalability preprocessing distributing load separate CPUs. contract XcmsExperiment object, XcmsExperimentHdf5 object keeps preprocessing results -disk HDF5 file reducing thus memory footprint. create subset data consisting 100 randomly selected files. perform chromatographic peak detection subset different configurations: Peak detection using default XcmsExperiment result object. Peak detection using XcmsExperimentHdf5 result object. Peak detection using 1, 2, 4 8 CPUs result objects. use chunkSize = 8 setups, load MS data 8 data files memory. time memory usage access data : memory used resulting MS data: next execute performance tests. use new XcmsExperimentHdf5, need specify path file name HDF5 file results stored . peakRAM can correctly monitor memory usage multi-core processing, thus evaluate memory usage serial processing setup. Peak RAM memory usage processing time chromatographic peak detection using different number CPUs. Data loaded processed chunks 8 data files. memory demand dependent chunkSize parameter, .e., number files (samples) MS data loaded processed time. peak RAM usage chunkSize = 8 , present data set, twice large size respective MS data memory. processing time reduced increase number CPUs used, relationship linear. likely due overhead data splitting distribution individual calculation nodes well result collection merging/export. largest performance gain serial processing parallel processing two CPUs. Importantly, performance keeping results memory (XcmsExperiment result object) storing HDF5 file (XcmsExperimentHdf5 file) comparable. next evaluate performance peak refinement step different setups re-using parameter object peak refinement full data. Processing XcmsExperimentHdf5 object overwrite results associated HDF5 files. perform peak refinement initial data thus need create copies original HDF5 file configuration. Peak RAM memory usage processing time chromatographic peak refinement using different number CPUs. Data loaded processed chunks 8 data files. maximum memory usage settings depending number data files raw data imported. processing time reduced considerably number CPUs. however depends also data set number candidate peaks merging. Processing times also similar -memory -disk results XcmsExperiment XcmsExperimentHdf5 objects. Next evaluate performance correspondence analysis peak density method. method uses chromPeaks() matrix analysis thus support chunkSize parameter support parallel processing. thus compare performance -memory -disk results . Peak RAM memory usage processing time correspondence analysis. performance memory demand similar two result objects. Next evaluate performance retention time alignment step using peak groups approach. method relies peak detection correspondence results support parallel processing. Peak RAM memory usage processing time retention time alignment analysis. Processing time similar result objects, memory requirement much lower XcmsExperimentHdf5 object. Finally evaluate performance gap-filling step. method requires access full MS data can thus configured chunkSize parameter different parallel processing setups. Peak RAM memory usage processing time gap filling using different number CPUs. Data loaded processed chunks 8 data files.","code":"set.seed(123)  tsub <- as(twins, \"MsExperiment\")[sample(seq_along(twins), 100)] library(peakRAM)  peakRAM(tmp <- peaksData(spectra(tsub[1:8]))) #>                        Function_Call Elapsed_Time_sec Total_RAM_Used_MiB #> 1 tmp<-peaksData(spectra(tsub[1:8]))            5.833             1922.9 #>   Peak_RAM_Used_MiB #> 1            3864.8 print(object.size(tmp), units = \"GB\") #> 1.9 Gb rm(tmp) #' Settings cwp <- CentWaveParam(ppm = 25,                      peakwidth = c(2, 20),                      prefilter = c(3, 500),                      snthresh = 8,                      mzCenterFun = \"wMean\",                      integrate = 2)  #' Eventually remove the result HDF5 object if present if (file.exists(\"tres.h5\")) invisible(file.remove(\"tres.h5\"))  #' Perform the comparison p <- peakRAM(     tres <- findChromPeaks(tsub, param = cwp, chunkSize = 8,                            BPPARAM = SerialParam()),     findChromPeaks(tsub, param = cwp, chunkSize = 8,                    BPPARAM = MulticoreParam(2)),     findChromPeaks(tsub, param = cwp, chunkSize = 8,                    BPPARAM = MulticoreParam(4)),     findChromPeaks(tsub, param = cwp, chunkSize = 8,                    BPPARAM = MulticoreParam(8)),     tres_h5 <- findChromPeaks(tsub, param = cwp, chunkSize = 8,                               BPPARAM = SerialParam(), hdf5File = \"tres.h5\"),     findChromPeaks(tsub, param = cwp, chunkSize = 8,                    BPPARAM = MulticoreParam(2), hdf5File = tempfile()),     findChromPeaks(tsub, param = cwp, chunkSize = 8,                    BPPARAM = MulticoreParam(4), hdf5File = tempfile()),     findChromPeaks(tsub, param = cwp, chunkSize = 8,                    BPPARAM = MulticoreParam(8), hdf5File = tempfile()) ) tmp <- data.frame(     `Result object` = rep(c(\"XcmsExperiment\", \"XcmsExperimentHdf5\"), each = 4),     `CPUs` = c(1, 2, 4, 8, 1, 2, 4, 8),     `Peak RAM [MiB]` = p$Peak_RAM_Used_MiB,     `Processing time [min]` = p$Elapsed_Time_sec / 60,     check.names = FALSE) pandoc.table(     tmp, style = \"rmarkdown\", split.table = Inf,     caption = paste0(\"Peak RAM memory usage and processing time for \",                      \"chromatographic peak detection using different number \",                      \"of CPUs. Data was loaded and processed in chunks of \",                      \"8 data files.\")) plot(tmp[1:4, \"CPUs\"], tmp[1:4, \"Processing time [min]\"],      type = \"b\", col = \"#ff000080\", xlab = \"CPUs\", ylab = \"Time [min]\") points(tmp[5:8, \"CPUs\"], tmp[5:8, \"Processing time [min]\"],        type = \"b\", col = \"#0000ff80\") grid() legend(\"topright\", col = c(\"#ff000080\", \"#0000ff80\"), pch = 1,        legend = c(\"Memory\", \"HDF5 file\")) #' Settings mnpp <- MergeNeighboringPeaksParam(expandRt = 5)  #' Create copies of the original peak detection results t1 <- tres_h5 tf <- tempfile() file.copy(tres_h5@hdf5_file, tf) #> [1] TRUE t1@hdf5_file <- tf  t2 <- tres_h5 tf <- tempfile() file.copy(tres_h5@hdf5_file, tf) #> [1] TRUE t2@hdf5_file <- tf  t4 <- tres_h5 tf <- tempfile() file.copy(tres_h5@hdf5_file, tf) #> [1] TRUE t4@hdf5_file <- tf  t8 <- tres_h5 tf <- tempfile() file.copy(tres_h5@hdf5_file, tf) #> [1] TRUE t8@hdf5_file <- tf  #' Run peak refinement with different configurations p <- peakRAM(     tres_2 <- refineChromPeaks(tres, param = mnpp, chunkSize = 8,                                BPPARAM = SerialParam()),     refineChromPeaks(tres, param = mnpp, chunkSize = 8,                      BPPARAM = MulticoreParam(2)),     refineChromPeaks(tres, param = mnpp, chunkSize = 8,                      BPPARAM = MulticoreParam(4)),     refineChromPeaks(tres, param = mnpp, chunkSize = 8,                      BPPARAM = MulticoreParam(8)),     t1 <- refineChromPeaks(t1, param = mnpp, chunkSize = 8,                            BPPARAM = SerialParam()),     t2 <- refineChromPeaks(t2, param = mnpp, chunkSize = 8,                            BPPARAM = MulticoreParam(2)),     t4 <- refineChromPeaks(t4, param = mnpp, chunkSize = 8,                            BPPARAM = MulticoreParam(4)),     t8 <- refineChromPeaks(t8, param = mnpp, chunkSize = 8,                            BPPARAM = MulticoreParam(8)) ) tmp <- data.frame(     `Result object` = rep(c(\"XcmsExperiment\", \"XcmsExperimentHdf5\"), each = 4),     `CPUs` = c(1, 2, 4, 8, 1, 2, 4, 8),     `Peak RAM [MiB]` = p$Peak_RAM_Used_MiB,     `Processing time [min]` = p$Elapsed_Time_sec / 60,     check.names = FALSE) pandoc.table(     tmp, style = \"rmarkdown\", split.table = Inf,     caption = paste0(\"Peak RAM memory usage and processing time for \",                      \"chromatographic peak refinement using different number \",                      \"of CPUs. Data was loaded and processed in chunks of \",                      \"8 data files.\")) #' Settings pdp <- PeakDensityParam(sampleGroups = rep(1, length(tsub)),                         minFraction = 0.3,                         binSize = 0.01, ppm = 10,                         bw = 3)  #' Evaluate performance of the correspondence analysis p <- peakRAM(     tres_2 <- groupChromPeaks(tres_2, param = pdp),     t1 <- groupChromPeaks(t1, param = pdp) ) tmp <- data.frame(     `Result object` = rep(c(\"XcmsExperiment\", \"XcmsExperimentHdf5\")),     `CPUs` = c(1, 1),     `Peak RAM [MiB]` = p$Peak_RAM_Used_MiB,     `Processing time [sec]` = p$Elapsed_Time_sec,     check.names = FALSE) pandoc.table(     tmp, style = \"rmarkdown\", split.table = Inf,     caption = paste0(\"Peak RAM memory usage and processing time for \",                      \"correspondence analysis.\")) #' Settings pgp <- PeakGroupsParam(minFraction = 0.9, extraPeaks = 1000,                        span = 0.5)  #' Evaluate performance of the correspondence analysis p <- peakRAM(     tres_2 <- adjustRtime(tres_2, param = pgp),     t1 <- adjustRtime(t1, param = pgp) ) #> Error in .local(object, param, ...): Alignment results already present. Please either remove them with 'dropAdjustedRtime' in order to perform an alternative, new, alignment, or use 'applyAdjustedRtime' prior 'adjustRtime' to perform a second round of alignment. tmp <- data.frame(     `Result object` = rep(c(\"XcmsExperiment\", \"XcmsExperimentHdf5\")),     `CPUs` = c(1, 1),     `Peak RAM [MiB]` = p$Peak_RAM_Used_MiB,     `Processing time [sec]` = p$Elapsed_Time_sec,     check.names = FALSE) pandoc.table(     tmp, style = \"rmarkdown\", split.table = Inf,     caption = paste0(\"Peak RAM memory usage and processing time for \",                      \"retention time alignment analysis.\")) #> Error in .local(object, param, ...): Alignment results already present. Please either remove them with 'dropAdjustedRtime' in order to perform an alternative, new, alignment, or use 'applyAdjustedRtime' prior 'adjustRtime' to perform a second round of alignment. #> Error in .local(object, param, ...): Alignment results already present. Please either remove them with 'dropAdjustedRtime' in order to perform an alternative, new, alignment, or use 'applyAdjustedRtime' prior 'adjustRtime' to perform a second round of alignment. #> Error in .local(object, param, ...): Alignment results already present. Please either remove them with 'dropAdjustedRtime' in order to perform an alternative, new, alignment, or use 'applyAdjustedRtime' prior 'adjustRtime' to perform a second round of alignment. #' Settings cpap <- ChromPeakAreaParam()  p <- peakRAM(     tres_2 <- fillChromPeaks(tres_2, param = cpap, chunkSize = 8,                              BPPARAM = SerialParam()),     fillChromPeaks(tres_2, param = cpap, chunkSize = 8,                    BPPARAM = MulticoreParam(2)),     fillChromPeaks(tres_2, param = cpap, chunkSize = 8,                    BPPARAM = MulticoreParam(4)),     fillChromPeaks(tres_2, param = cpap, chunkSize = 8,                    BPPARAM = MulticoreParam(8)),     t1 <- fillChromPeaks(t1, param = cpap, chunkSize = 8,                          BPPARAM = SerialParam()),     t2 <- fillChromPeaks(t2, param = cpap, chunkSize = 8,                          BPPARAM = MulticoreParam(2)),     t4 <- fillChromPeaks(t4, param = cpap, chunkSize = 8,                          BPPARAM = MulticoreParam(4)),     t8 <- fillChromPeaks(t8, param = cpap, chunkSize = 8,                          BPPARAM = MulticoreParam(8)) ) tmp <- data.frame(     `Result object` = rep(c(\"XcmsExperiment\", \"XcmsExperimentHdf5\"), each = 4),     `CPUs` = c(1, 2, 4, 8, 1, 2, 4, 8),     `Peak RAM [MiB]` = p$Peak_RAM_Used_MiB,     `Processing time [min]` = p$Elapsed_Time_sec / 60,     check.names = FALSE) pandoc.table(     tmp, style = \"rmarkdown\", split.table = Inf,     caption = paste0(\"Peak RAM memory usage and processing time for \",                      \"gap filling using different number \",                      \"of CPUs. Data was loaded and processed in chunks of \",                      \"8 data files.\"))"},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/large-scale-analysis.html","id":"details-of-the-software-structure-and-data-flow","dir":"Articles","previous_headings":"Performance evaluation","what":"Details of the software structure and data flow","title":"Large Scale Data Preprocessing with xcms","text":"reduce memory demand, processing steps applied chunks data time. Thus, MS data currently processed chunks realized memory. using Spectra package represent provide MS data, xcms now also benefits dedicated Spectra data backends e.g. retrieve MS data --fly original MS data files (MsBackendMzR) SQL database (using backends r Biocpkg(\"MsBackendSql\") package). alternative data representations seamlessly integrated xcms increase flexibility reducing memory demand. XcmsExperiment result object keeps, similar older result objects xcms, preprocessing results memory, chromatographic peak detection results (chromPeaks() matrix) large numeric matrix correspondence results (featureDefinitions()) data frame. Accessing data thus fast, , depending size experiment, can also large eventually blocking large part system’s main memory. , additional analysis steps, tables might need processed, e.g. split sample, can result (least temporary) additional copies data memory (can complicated R’s copy--change strategy). Memory usage can thus, unexpectedly user, exceed available system memory. new XcmsExperimentHdf5 designed address issue storing preprocessing results HDF5 file disk, keeping thus lean memory footprint. Thus, described chunk-wise processing xcms also load preprocessing results currently processed chunk memory. Importing preprocessing results HDF5 file comes little overhead, functions optimized import subsets data time.","code":""},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/large-scale-analysis.html","id":"summary-and-guidance","dir":"Articles","previous_headings":"Performance evaluation","what":"Summary and guidance","title":"Large Scale Data Preprocessing with xcms","text":"Use parameter chunkSize specify number samples/files processed time. Ensure set value according system’s main memory. MS data samples one chunk exceed still available (!) system memory. Parallel processing helps reduce processing time, scale linearly, since parallel processing involves also distribution data , collection results , individual processing nodes. present analysis, big part computation time spent needed --fly import MS data original data files. CDF files might efficient data storage container -demand data retrieval. Storing original MS data SQL database (either SQLite MariaDB/MySQL) can improve performance. See MsbackendSql details. code used store full MS data current experiment SQLite database shown :","code":"library(RSQLite)  #' Create a SQLite database con <- dbConnect(SQLite(), \"twins.sqlite\")  library(MsBackendSql) twins_db <- twins  #' Save the full MS data into this database twins_db@spectra <- setBackend(twins_db@spectra, MsBackendSql(), dbcon = con)  dbDisconnect(con)"},{"path":"https://rformassspectrometry.github.io/Metabonaut/articles/large-scale-analysis.html","id":"session-information","dir":"Articles","previous_headings":"","what":"Session information","title":"Large Scale Data Preprocessing with xcms","text":"R code run : Information computer system: Information R session:","code":"date() #> [1] \"Fri Apr 18 10:43:40 2025\" library(benchmarkme) get_cpu() #> $vendor_id #> [1] \"GenuineIntel\" #> #> $model_name #> [1] \"13th Gen Intel(R) Core(TM) i7-1370P\" #> #> $no_of_cores #> [1] 20 get_ram() #> 67.1 GB sessionInfo() #> R version 4.5.0 (2025-04-11) #> Platform: x86_64-pc-linux-gnu #> Running under: Arch Linux #> #> Matrix products: default #> BLAS:   /home/jo/R/R-4.5.0/lib64/R/lib/libRblas.so #> LAPACK: /usr/lib/liblapack.so.3.12.0  LAPACK version 3.12.0 #> #> locale: #>  [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C #>  [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8 #>  [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8 #>  [7] LC_PAPER=en_US.UTF-8       LC_NAME=C #>  [9] LC_ADDRESS=C               LC_TELEPHONE=C #> [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C #> #> time zone: Europe/Rome #> tzcode source: system (glibc) #> #> attached base packages: #> [1] stats4    stats     graphics  grDevices utils     datasets  methods #> [8] base #> #> other attached packages: #>  [1] benchmarkme_1.0.8           pander_0.6.6 #>  [3] peakRAM_1.0.2               xcms_4.7.1 #>  [5] MsIO_0.0.9                  MsExperiment_1.10.0 #>  [7] ProtGenerics_1.40.0         MsBackendMetaboLights_1.2.0 #>  [9] Spectra_1.18.0              BiocParallel_1.42.0 #> [11] S4Vectors_0.46.0            BiocGenerics_0.54.0 #> [13] generics_0.1.3              BiocStyle_2.36.0 #> #> loaded via a namespace (and not attached): #>   [1] DBI_1.2.3                   rlang_1.1.6 #>   [3] magrittr_2.0.3              clue_0.3-66 #>   [5] MassSpecWavelet_1.74.0      matrixStats_1.5.0 #>   [7] compiler_4.5.0              RSQLite_2.3.9 #>   [9] vctrs_0.6.5                 reshape2_1.4.4 #>  [11] stringr_1.5.1               pkgconfig_2.0.3 #>  [13] MetaboCoreUtils_1.16.0      crayon_1.5.3 #>  [15] fastmap_1.2.0               dbplyr_2.5.0 #>  [17] XVector_0.48.0              rmarkdown_2.29 #>  [19] preprocessCore_1.70.0       UCSC.utils_1.4.0 #>  [21] purrr_1.0.4                 bit_4.6.0 #>  [23] xfun_0.52                   MultiAssayExperiment_1.34.0 #>  [25] cachem_1.1.0                GenomeInfoDb_1.44.0 #>  [27] jsonlite_2.0.0              progress_1.2.3 #>  [29] blob_1.2.4                  rhdf5filters_1.20.0 #>  [31] DelayedArray_0.34.0         Rhdf5lib_1.30.0 #>  [33] parallel_4.5.0              prettyunits_1.2.0 #>  [35] cluster_2.1.8.1             R6_2.6.1 #>  [37] stringi_1.8.7               RColorBrewer_1.1-3 #>  [39] limma_3.64.0                GenomicRanges_1.60.0 #>  [41] iterators_1.0.14            Rcpp_1.0.14 #>  [43] SummarizedExperiment_1.38.0 knitr_1.50 #>  [45] IRanges_2.42.0              BiocBaseUtils_1.10.0 #>  [47] Matrix_1.7-3                igraph_2.1.4 #>  [49] tidyselect_1.2.1            abind_1.4-8 #>  [51] yaml_2.3.10                 doParallel_1.0.17 #>  [53] affy_1.86.0                 codetools_0.2-20 #>  [55] curl_6.2.2                  lattice_0.22-7 #>  [57] tibble_3.2.1                plyr_1.8.9 #>  [59] withr_3.0.2                 Biobase_2.68.0 #>  [61] benchmarkmeData_1.0.4       evaluate_1.0.3 #>  [63] BiocFileCache_2.16.0        alabaster.schemas_1.8.0 #>  [65] affyio_1.78.0               pillar_1.10.2 #>  [67] BiocManager_1.30.25         filelock_1.0.3 #>  [69] MatrixGenerics_1.20.0       foreach_1.5.2 #>  [71] MALDIquant_1.22.3           MSnbase_2.34.0 #>  [73] ncdf4_1.24                  ggplot2_3.5.2 #>  [75] hms_1.1.3                   munsell_0.5.1 #>  [77] scales_1.3.0                alabaster.base_1.8.0 #>  [79] glue_1.8.0                  MsFeatures_1.16.0 #>  [81] lazyeval_0.2.2              tools_4.5.0 #>  [83] mzID_1.46.0                 data.table_1.17.0 #>  [85] vsn_3.76.0                  QFeatures_1.18.0 #>  [87] mzR_2.42.0                  XML_3.99-0.18 #>  [89] fs_1.6.6                    rhdf5_2.52.0 #>  [91] grid_4.5.0                  impute_1.82.0 #>  [93] tidyr_1.3.1                 MsCoreUtils_1.20.0 #>  [95] colorspace_2.1-1            GenomeInfoDbData_1.2.14 #>  [97] PSMatch_1.12.0              cli_3.6.4 #>  [99] S4Arrays_1.8.0              dplyr_1.1.4 #> [101] AnnotationFilter_1.32.0     pcaMethods_2.0.0 #> [103] gtable_0.3.6                digest_0.6.37 #> [105] SparseArray_1.8.0           memoise_2.0.1 #> [107] htmltools_0.5.8.1           lifecycle_1.0.4 #> [109] httr_1.4.7                  statmod_1.5.0 #> [111] bit64_4.6.0-1               MASS_7.3-65"},{"path":"https://rformassspectrometry.github.io/Metabonaut/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Philippine Louail. Author, maintainer.            European Union HORIZON-MSCA-2021 project \t\t    Grant . 101073062: HUMAN – Harmonising Unifying Blood \t\t    Metabolic Analysis Networks Anna Tagliaferri. Contributor. Vinicius Verri Hernandes. Contributor. Daniel Marques de Sá e Silva. Contributor.            European Union HORIZON-MSCA-2021 project \t\t    Grant . 101073062: HUMAN – Harmonising Unifying Blood \t\t    Metabolic Analysis Networks Johannes Rainer. Author. Marilyn De Graeve. Contributor.","code":""},{"path":"https://rformassspectrometry.github.io/Metabonaut/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Philippine Louail, Marilyn De Graeve, Anna Tagliaferri, Vinicius Verri Hernandes, Daniel Marques de Sá e Silva, & Johannes Rainer. (2025). rformassspectrometry/Metabonaut: v1.2.0. Zenodo. https://doi.org/10.5281/zenodo.15554287","code":"@Misc{,   title = {rformassspectrometry/Metabonaut: v1.2.0},   author = {Philippine Louail and Marilyn {De Graeve} and Anna Tagliaferri and Vinicius {Verri Hernandes} and Daniel {Marques de Sá e Silva} and Johannes Rainer},   publisher = {Zenodo},   year = {2025},   month = {may},   version = {v1.2.0},   doi = {10.5281/zenodo.15554287},   url = {https://doi.org/10.5281/zenodo.15554287}, }"},{"path":[]},{"path":"https://rformassspectrometry.github.io/Metabonaut/index.html","id":"welcome-to-metabonaut-rocket","dir":"","previous_headings":"","what":"Welcome to Metabonaut! 🚀","title":"Exploring and Analyzing LC-MS Data","text":"Metabonaut presents series workflows based small LC-MS/MS dataset, utilizing R Bioconductor packages. workflows demonstrate adapt various algorithms specific datasets seamlessly integrate R packages efficient, reproducible data processing.","code":""},{"path":[]},{"path":"https://rformassspectrometry.github.io/Metabonaut/index.html","id":"id_1-complete-end-to-end-lc-msms-metabolomic-data-analysis","dir":"","previous_headings":"Available Vignettes","what":"1. Complete End-to-End LC-MS/MS Metabolomic Data Analysis","title":"Exploring and Analyzing LC-MS Data","text":"primary workflow guides step analysis, preprocessing raw data statistical analysis metabolite annotation. 📄 Full R code: end--end-untargeted-metabolomics.qmd","code":""},{"path":"https://rformassspectrometry.github.io/Metabonaut/index.html","id":"id_2-dataset-investigation","dir":"","previous_headings":"Available Vignettes","what":"2. Dataset Investigation","title":"Exploring and Analyzing LC-MS Data","text":"diving analysis, learn key aspects examine dataset ensure smooth processing avoid troubleshooting later.","code":""},{"path":"https://rformassspectrometry.github.io/Metabonaut/index.html","id":"id_3-seamless-alignment-merging-new-data-with-an-existing-preprocessed-dataset","dir":"","previous_headings":"Available Vignettes","what":"3. Seamless Alignment: Merging New Data with an Existing Preprocessed Dataset","title":"Exploring and Analyzing LC-MS Data","text":"Discover use flexible alignment algorithm integrate new datasets previously processed ones based features interest.","code":""},{"path":"https://rformassspectrometry.github.io/Metabonaut/index.html","id":"id_4-lc-msms-data-annotation-using-r-and-python","dir":"","previous_headings":"Available Vignettes","what":"4. LC-MS/MS Data Annotation using R and Python","title":"Exploring and Analyzing LC-MS Data","text":"Explore SpectriPy package LC-MS/MS data annotation. tutorial demonstrates combining strengths Python R MS libraries annotation.","code":""},{"path":"https://rformassspectrometry.github.io/Metabonaut/index.html","id":"id_4-large-scale-processing-using-xcms","dir":"","previous_headings":"Available Vignettes","what":"4. Large Scale Processing Using xcms","title":"Exploring and Analyzing LC-MS Data","text":"often boast scalability xcms, show actually deal large dataset (>4000 files) processing ordinary computer. full list available vignettes, visit Metabonaut website.","code":""},{"path":"https://rformassspectrometry.github.io/Metabonaut/index.html","id":"pushpin-reproducibility--updates","dir":"","previous_headings":"","what":"📌 Reproducibility & Updates","title":"Exploring and Analyzing LC-MS Data","text":"strive reproducibility. workflows designed remain stable time, allowing run vignettes together one comprehensive super-vignette. Metabonaut now works stable version Bioconductor (3.21), exception SpectriPy package part Bioconductor 3.22. Minor updates can found News section.","code":""},{"path":"https://rformassspectrometry.github.io/Metabonaut/index.html","id":"mortar_board-for-r-beginners","dir":"","previous_headings":"","what":"🎓 For R Beginners","title":"Exploring and Analyzing LC-MS Data","text":"tutorials assume basic knowledge R RMarkdown. ’re new , recommend starting short tutorial running vignettes. Learn Quarto (used vignettes): Quarto Guide Learn RMarkdown: RMarkdown Book Intro R: Learn-R.org Interactive R course: Swirl Best Practices Cheatsheet: GitHub Repository","code":""},{"path":"https://rformassspectrometry.github.io/Metabonaut/index.html","id":"hammer_and_wrench-known-issues","dir":"","previous_headings":"","what":"🛠️ Known Issues","title":"Exploring and Analyzing LC-MS Data","text":"just beginning Metabonaut journey, ’re actively refining website. ’re experiencing issues: ✅ Ensure latest versions required packages. 🐛 issue persists, report reproducible example GitHub Issues. Currently, known issues code.","code":""},{"path":"https://rformassspectrometry.github.io/Metabonaut/index.html","id":"handshake-contribution","dir":"","previous_headings":"","what":"🤝 Contribution","title":"Exploring and Analyzing LC-MS Data","text":"Interested contributing? Please check RforMassSpectrometry Contributions Guide.","code":""},{"path":"https://rformassspectrometry.github.io/Metabonaut/index.html","id":"scroll-code-of-conduct","dir":"","previous_headings":"🤝 Contribution","what":"📜 Code of Conduct","title":"Exploring and Analyzing LC-MS Data","text":"follow RforMassSpectrometry Code Conduct maintain inclusive respectful community.","code":""},{"path":"https://rformassspectrometry.github.io/Metabonaut/index.html","id":"raised_hands-acknowledgements","dir":"","previous_headings":"","what":"🙌 Acknowledgements","title":"Exploring and Analyzing LC-MS Data","text":"work funded European Union HORIZON-MSCA-2021 project 101073062: HUMAN – Harmonising Unifying Blood Metabolic Analysis Networks. 🔗 Learn : HUMAN Project Website","code":""},{"path":"https://rformassspectrometry.github.io/Metabonaut/reference/Metabonaut.html","id":null,"dir":"Reference","previous_headings":"","what":"Learning to analysis LC-MS/MS data — Metabonaut","title":"Learning to analysis LC-MS/MS data — Metabonaut","text":"resource hosts tutorials end--end workflows describing analyze LC-MS/MS data, raw files annotation, using Bioconductor packages. tutorials rendered can found page Metabonaut information can find source code ","code":""},{"path":[]},{"path":"https://rformassspectrometry.github.io/Metabonaut/news/index.html","id":"changes-in-1-2","dir":"Changelog","previous_headings":"","what":"Changes in 1.2.1","title":"Metabonaut 1.2","text":"Addition libary(knitr) end--end workflow.","code":""},{"path":"https://rformassspectrometry.github.io/Metabonaut/news/index.html","id":"changes-in-1-2-1","dir":"Changelog","previous_headings":"","what":"Changes in 1.2.0","title":"Metabonaut 1.2","text":"Addition new vignette depicting large scale processing using xcms. Due size, added pre-computed vignette prevent re-knitting much possible. Docker image now based stable version Bioconductor (3.21) instead devel.","code":""},{"path":[]},{"path":"https://rformassspectrometry.github.io/Metabonaut/news/index.html","id":"changes-in-1-1","dir":"Changelog","previous_headings":"","what":"Changes in 1.1.2","title":"Metabonaut 1.1","text":"Adding authors contributed specific method/vignettes respective vignette’s header. Update README.md add link SpectriPy vignette. fix ORCID description gets recognize ORCID.","code":""},{"path":"https://rformassspectrometry.github.io/Metabonaut/news/index.html","id":"changes-in-1-1-1","dir":"Changelog","previous_headings":"","what":"Changes in 1.1.1","title":"Metabonaut 1.1","text":"Update docker skip installation R packages caching data files root user. Fix GHA properly install Python libraries library(SpectriPy).","code":""},{"path":"https://rformassspectrometry.github.io/Metabonaut/news/index.html","id":"changes-in-1-1-2","dir":"Changelog","previous_headings":"","what":"Changes in 1.1.0","title":"Metabonaut 1.1","text":"Add vignette combined R/Python data analysis using reticulate SpectriPy.","code":""},{"path":"https://rformassspectrometry.github.io/Metabonaut/news/index.html","id":"changes-in-1-1-3","dir":"Changelog","previous_headings":"","what":"Changes in 1.1.0","title":"Metabonaut 1.1","text":"Addition devel branch repository maintain stable version.","code":""},{"path":"https://rformassspectrometry.github.io/Metabonaut/news/index.html","id":"changes-in-1-1-4","dir":"Changelog","previous_headings":"","what":"Changes in 1.0.1","title":"Metabonaut 1.1","text":"Minor fixes DESCRIPTION .yml Addition devel branch repository maintain stable version.","code":""},{"path":"https://rformassspectrometry.github.io/Metabonaut/news/index.html","id":"changes-in-1-1-5","dir":"Changelog","previous_headings":"","what":"Changes in 1.0.0","title":"Metabonaut 1.1","text":"plots data investigation vignette. main end end vignette: added saving Spectra object significant features associated MS1 MS2 data. used later vignettes.","code":""},{"path":[]},{"path":"https://rformassspectrometry.github.io/Metabonaut/news/index.html","id":"changes-in-0-0","dir":"Changelog","previous_headings":"","what":"Changes in 0.0.7","title":"Metabonaut 0.0","text":"Fix typo cut-MS2 annotation. Updated figure numbering. Added acknowledgment community. added figure retention time alignment vignette.","code":""},{"path":"https://rformassspectrometry.github.io/Metabonaut/news/index.html","id":"changes-in-0-0-1","dir":"Changelog","previous_headings":"","what":"Changes in 0.0.6","title":"Metabonaut 0.0","text":"Moving PercentMissing filtering end pre-processing steps needs done normalization. Addition collapsing code improve readability. Reduction table size","code":""},{"path":"https://rformassspectrometry.github.io/Metabonaut/news/index.html","id":"changes-in-0-0-2","dir":"Changelog","previous_headings":"","what":"Changes in 0.0.5","title":"Metabonaut 0.0","text":"Require MsIO version 0.0.8 allow reading stored MsBackendMetaboLights objects. simplify import previously stored result object avoid using variable name param every parameter object","code":""},{"path":"https://rformassspectrometry.github.io/Metabonaut/news/index.html","id":"changes-in-0-0-3","dir":"Changelog","previous_headings":"","what":"Changes in 0.0.4","title":"Metabonaut 0.0","text":"Required alabaster.se. Removal Spectra data depth visualisation move Data investigation vignette Removal internal standard matching features Normalization part. Save load lcms1 res object end--end workflow used Seamless Alignment vignette. Using MsIO alabaster.se","code":""},{"path":"https://rformassspectrometry.github.io/Metabonaut/news/index.html","id":"changes-in-0-0-4","dir":"Changelog","previous_headings":"","what":"Changes in 0.0.3","title":"Metabonaut 0.0","text":"Require xcms version 4.3.4 install package github.","code":""},{"path":"https://rformassspectrometry.github.io/Metabonaut/news/index.html","id":"changes-in-0-0-5","dir":"Changelog","previous_headings":"","what":"Changes in 0.0.2","title":"Metabonaut 0.0","text":"Switch Quarto instead Rmarkdown Addition Alignment reference dataset vignette Addition Data investigation vignette Addition Install vignette","code":""},{"path":"https://rformassspectrometry.github.io/Metabonaut/news/index.html","id":"changes-in-0-0-6","dir":"Changelog","previous_headings":"","what":"Changes in 0.0.1","title":"Metabonaut 0.0","text":"Addition basic files workflow package. Addition end--end vignette.","code":""}]
